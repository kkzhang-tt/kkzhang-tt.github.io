I"&<h1 id="分布式事务与共识">分布式事务与共识</h1>

<p>共识问题也是分布式系统中最基本的问题之一，共识的目的是让几个节点就某一事件达成一致。</p>

<p>在许多场景中都需要集群中的节点达成某种一致：</p>

<ul>
  <li>
    <p><strong>主节点选举</strong></p>

    <p>对于主从复制的数据库，需要<em>对谁来充当主节点达成一致</em>。如果由于网络问题使得部分节点之间无法通信，可能会导致两个节点都认为自己是主节点，从而产生数据异常等问题；而共识能够避免这种错误的故障切换。</p>
  </li>
  <li>
    <p><strong>原子事务提交</strong></p>

    <p>对于跨节点或者跨分区的事务，在执行中可能会存在部分节点成功，其他节点失败的情况。为了保证事务的原子性，需要所有节点<em>对事务的执行结果达成一致</em>：要么成功提交，要么失败回滚。</p>
  </li>
</ul>

<h2 id="两阶段提交2pc">两阶段提交（2PC）</h2>

<p>2PC 是一种在多节点之间实现事务原子提交的算法，用来确保所有的节点要么全部提交，要么全部终止。</p>

<p>2PC 引入了一个组件：协调者（事务管理器）；参与分布式事务的数据库节点称为参与者。整体流程如下：</p>

<p><img src="/images/ddia/ddia_3_1.png" alt="" /></p>

<p>2PC 事务从应用程序在多个数据库节点上执行数据读写开始。当应用程序准备提交事务时，协调者开始阶段 1：发送一个准备请求到所有节点，询问它们是否可以提交，然后等待所有参与者的响应：</p>

<ul>
  <li>如果所有参与者都回答“是”，则表示所有参与者均准备好提交，那么协调者就会在阶段 2 发出提交请求，事务提交开始实际执行。</li>
  <li>如果有任何参与者回复“否”，则协调者在阶段 2 中向所有节点发送放弃请求。</li>
</ul>

<h3 id="系统承若">系统承若</h3>

<p>2PC 为什么能确保跨节点的原子性，需要进一步分析下：</p>

<ol>
  <li>当应用程序开启一个分布式事务时，首先向协调者请求事务 ID（全局唯一）</li>
  <li>应用程序在每个参与者上执行单节点事务，并将全局唯一的事务 ID 附加到事务上。此时的读写操作都是在单节点上完成，如果在该阶段出现问题，则协调者与其他参与者都可以安全终止事务</li>
  <li>当应用程序准备提交事务时，协调者向所有参与者发送准备请求，并附带之前的全局事务 ID。如果准备请求有任何一个发生失败或者超时，则协调者都会通知所有参与者放弃事务</li>
  <li>参与者在收到准备请求之后，需要检查自己是否可以安全地提交事务。一旦向事务协调者响应“是”之后，该节点就会承诺会提交事务</li>
  <li>当协调者收到所有准备请求的响应后，就是否提交事务做出明确的决定（只有所有参与者都响应“是”时才会提交）。协调者将决定写入到磁盘的事务日志中，防止系统崩溃，该时刻称为提交点</li>
  <li>协调者将事务提交的决定写入磁盘后，向所有参与者发送提交（放弃）事务的请求。如果该请求出现超时或者失败的情况，则协调者必须一直重试直至成功。如果有参与者此时出现了故障，则在其恢复后也必须继续执行。</li>
</ol>

<p>在整个流程中存在两个承诺，用来确保 2PC 的原子性：</p>

<ul>
  <li>当参与者投票“是”时，做出了肯定提交的承诺</li>
  <li>协调者对于事务提交（放弃）的决定也做了承诺</li>
</ul>

<h3 id="协调者发生故障">协调者发生故障</h3>

<p>如果协调者在发送准备请求之前发生故障，则参与者可以安全地终止事务。</p>

<p>如果参与者收到了准备的请求并响应了“是”，则该参与者必须等待协调者的决定，不能单方面放弃；即使协调者出现故障，也要一直等待下去。</p>

<h2 id="支持容错的共识">支持容错的共识</h2>

<p>共识问题通常形式化描述为：一个或者多个节点可以提议某些值，由共识算法来决定最终值。</p>

<p>共识算法必须满足以下性质：</p>

<ul>
  <li>
    <p><strong><em>协商一致性（Uniform agreement）</em></strong></p>

    <p>所有节点都接收相同的决议</p>
  </li>
  <li>
    <p><strong><em>诚实性（Integrity）</em></strong></p>

    <p>所有节点不能反悔，即对一项提议不能有两次决定</p>
  </li>
  <li>
    <p><strong><em>合法性（Validity）</em></strong></p>

    <p>如果最终决定了值 v，那么 v 一定是由某个节点所提议的</p>
  </li>
  <li>
    <p><strong><em>可终止性（Termination）</em></strong></p>

    <p>节点如果不崩溃，则最终一定可以达成决议</p>
  </li>
</ul>

<p>协商一致性 &amp; 诚实性定义了共识的核心思想：<em>决定一致的结果，一旦决定，就不能有所改变</em>。</p>

<p>可终止性引入了容错的思想，它强调一个共识算法必须取得实质性进展，不能原地空转（在 2PC 中，如果协调者出现故障，则参与者就只能继续等待）。<strong>即使某些节点出现故障，其他节点也必须做出决定（前提是需要大部分节点仍能正确运行）</strong>。</p>

<blockquote>
  <p>可终止性属于活性，另外三个属性属于安全性</p>
</blockquote>

<h3 id="共识算法与全序广播">共识算法与全序广播</h3>

<p>常见的容错式共识算法有 Paxos, Raft, Zab 和 VSR。这些算法其实并不是直接采用上面的形式化模型（提议并决定某个值，同时满足上面 4 个属性）；相反，它们是决定了一系列的值，然后采用全序关系广播算法。</p>

<p>全序关系广播需要将消息按照相同的顺序发送到所有节点，有且只有一次，相当于进行了多轮共识过程：在每一轮，节点提出它们接下来想要发送的消息，然后决定下一个消息的全局顺序。所以全序关系广播相当于持续的多轮共识（每轮共识对应一条消息）。</p>

<h3 id="主从复制与共识">主从复制与共识</h3>

<p>在主从复制中，所有的写入操作都由主节点负责，并以相同的顺序发送到从节点来保持副本更新，所以主从复制实际上就是全序关系广播。</p>

<p>不过，主从复制可能不能满足共识算法的可终止性：如果主节点故障，如何选举新的主节点？而为了选举新的主节点，又需要共识算法来实现。</p>

<p>重新梳理下，<strong>全序关系广播相当于多轮共识，主从复制就是全序关系广播，主从复制的主节点选举又依赖共识 ⇒ 共识算法的实现，需要依赖共识</strong>。看起来像一个循环依赖。</p>

<h3 id="epoch--quorum">Epoch &amp; Quorum</h3>

<p>目前的共识算法都是用了某种形式上的主节点，主节点并不固定。这些算法使用了一种弱化的保证：<strong>定义一个世代编号（Raft: term number, Paxos: ballot number），并保证在每个世代里，主节点是唯一的</strong>。</p>

<p>如果发现当前主节点失效，节点就开始新的一轮主节点选举。<strong>选举会赋予一个单调递增的 epoch 号；如果出现两个不同的节点对应不同的 epoch 号码，则具有更高的 epoch 号码的主节点将获胜</strong>。</p>

<p>在主节点做决定之前，需要先检查是否存在比它更高的 epoch 号码，确保不会同时存在多个主节点。主节点如果想要做某个决定，需要将提议发送给其他所有的节点，等待 quorum 节点响应；如果其他节点没有发现更高的 epoch 主节点存在时，才会对该提议进行投票。</p>

<p>所以，每次提议都会进行两轮投票：</p>

<ol>
  <li>对主节点投票：如果没有更高的 epoch，则当前主节点的地位保持不变</li>
  <li>对主节点的提议投票</li>
</ol>

<blockquote>
  <p>两轮投票的 quorum 必须有重叠</p>
</blockquote>

<h3 id="共识的局限性">共识的局限性</h3>

<p><strong>共识可以提供全序关系广播，以容错的方式实现线性化的原子操作。</strong></p>

<p>不过，共识的实现是有局限性的：</p>

<ol>
  <li>在达成一致性决议之前，节点投票过程是一个同步复制过程，性能会有影响</li>
  <li>共识体系需要多数节点运行才行</li>
  <li>多数共识算法假定参与投票的节点数是固定的，意味着不能动态调整节点</li>
  <li>共识系统通常依靠超时机制检测节点失效，不过由于网络延迟可能会导致主节点被频繁选举</li>
</ol>

<h2 id="小结">小结</h2>

<p>共识意味着就某一项提议，所有节点做出一致的决定，而且决定不可撤销。多个广泛的问题都可以归结于共识：</p>

<ul>
  <li>可线性化的 CAS 寄存器</li>
  <li>原子事务提交</li>
  <li>全序关系广播</li>
  <li>锁与租约</li>
  <li>唯一性约束</li>
  <li>成员服务（系统决定节点的存活状态）</li>
</ul>

<p>主从复制系统能够提供线性化操作，唯一性约束，完全有序的复制日志等能力，但是如果唯一的主节点发生故障，为了保证服务的可用性，我们需要重新选取一个主节点。共识算法能够帮助我们选出唯一的主节点。</p>

<p>共识算法对于主从数据库系统来说，主要用于主节点角色的维护与主节点变更的处理。对于多主复制和无主复制系统来说，通常不支持全局共识。</p>
:ET