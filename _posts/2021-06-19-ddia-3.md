---

layout: post
title: "DDIA: 一致性与共识（三）"
category: "ddia"
author: "kkzhang"
---

# 分布式事务与共识

共识问题也是分布式系统中最基本的问题之一，共识的目的是让几个节点就某一事件达成一致。

在许多场景中都需要集群中的节点达成某种一致：

- **主节点选举**

    对于主从复制的数据库，需要*对谁来充当主节点达成一致*。如果由于网络问题使得部分节点之间无法通信，可能会导致两个节点都认为自己是主节点，从而产生数据异常等问题；而共识能够避免这种错误的故障切换。

- **原子事务提交**

    对于跨节点或者跨分区的事务，在执行中可能会存在部分节点成功，其他节点失败的情况。为了保证事务的原子性，需要所有节点*对事务的执行结果达成一致*：要么成功提交，要么失败回滚。

## 两阶段提交（2PC）

2PC 是一种在多节点之间实现事务原子提交的算法，用来确保所有的节点要么全部提交，要么全部终止。

2PC 引入了一个组件：协调者（事务管理器）；参与分布式事务的数据库节点称为参与者。整体流程如下：

<img src="https://raw.githubusercontent.com/kkzhang-tt/kkzhang-tt.github.io/main/_images/ddia_5.png"/>

2PC 事务从应用程序在多个数据库节点上执行数据读写开始。当应用程序准备提交事务时，协调者开始阶段 1：发送一个准备请求到所有节点，询问它们是否可以提交，然后等待所有参与者的响应：

- 如果所有参与者都回答“是”，则表示所有参与者均准备好提交，那么协调者就会在阶段 2 发出提交请求，事务提交开始实际执行。
- 如果有任何参与者回复“否”，则协调者在阶段 2 中向所有节点发送放弃请求。

### 系统承若

2PC 为什么能确保跨节点的原子性，需要进一步分析下：

1. 当应用程序开启一个分布式事务时，首先向协调者请求事务 ID（全局唯一）
2. 应用程序在每个参与者上执行单节点事务，并将全局唯一的事务 ID 附加到事务上。此时的读写操作都是在单节点上完成，如果在该阶段出现问题，则协调者与其他参与者都可以安全终止事务
3. 当应用程序准备提交事务时，协调者向所有参与者发送准备请求，并附带之前的全局事务 ID。如果准备请求有任何一个发生失败或者超时，则协调者都会通知所有参与者放弃事务
4. 参与者在收到准备请求之后，需要检查自己是否可以安全地提交事务。一旦向事务协调者响应“是”之后，该节点就会承诺会提交事务
5. 当协调者收到所有准备请求的响应后，就是否提交事务做出明确的决定（只有所有参与者都响应“是”时才会提交）。协调者将决定写入到磁盘的事务日志中，防止系统崩溃，该时刻称为提交点
6. 协调者将事务提交的决定写入磁盘后，向所有参与者发送提交（放弃）事务的请求。如果该请求出现超时或者失败的情况，则协调者必须一直重试直至成功。如果有参与者此时出现了故障，则在其恢复后也必须继续执行。

在整个流程中存在两个承诺，用来确保 2PC 的原子性：

- 当参与者投票“是”时，做出了肯定提交的承诺
- 协调者对于事务提交（放弃）的决定也做了承诺

### 协调者发生故障

如果协调者在发送准备请求之前发生故障，则参与者可以安全地终止事务。

如果参与者收到了准备的请求并响应了“是”，则该参与者必须等待协调者的决定，不能单方面放弃；即使协调者出现故障，也要一直等待下去。

## 支持容错的共识

共识问题通常形式化描述为：一个或者多个节点可以提议某些值，由共识算法来决定最终值。

共识算法必须满足以下性质：

- ***协商一致性（Uniform agreement）***

    所有节点都接收相同的决议

- ***诚实性（Integrity）***

    所有节点不能反悔，即对一项提议不能有两次决定

- ***合法性（Validity）***

    如果最终决定了值 v，那么 v 一定是由某个节点所提议的

- ***可终止性（Termination）***

    节点如果不崩溃，则最终一定可以达成决议

协商一致性 & 诚实性定义了共识的核心思想：*决定一致的结果，一旦决定，就不能有所改变*。

可终止性引入了容错的思想，它强调一个共识算法必须取得实质性进展，不能原地空转（在 2PC 中，如果协调者出现故障，则参与者就只能继续等待）。**即使某些节点出现故障，其他节点也必须做出决定（前提是需要大部分节点仍能正确运行）**。

> 可终止性属于活性，另外三个属性属于安全性

### 共识算法与全序广播

常见的容错式共识算法有 Paxos, Raft, Zab 和 VSR。这些算法其实并不是直接采用上面的形式化模型（提议并决定某个值，同时满足上面 4 个属性）；相反，它们是决定了一系列的值，然后采用全序关系广播算法。

全序关系广播需要将消息按照相同的顺序发送到所有节点，有且只有一次，相当于进行了多轮共识过程：在每一轮，节点提出它们接下来想要发送的消息，然后决定下一个消息的全局顺序。所以全序关系广播相当于持续的多轮共识（每轮共识对应一条消息）。

### 主从复制与共识

在主从复制中，所有的写入操作都由主节点负责，并以相同的顺序发送到从节点来保持副本更新，所以主从复制实际上就是全序关系广播。

不过，主从复制可能不能满足共识算法的可终止性：如果主节点故障，如何选举新的主节点？而为了选举新的主节点，又需要共识算法来实现。

重新梳理下，**全序关系广播相当于多轮共识，主从复制就是全序关系广播，主从复制的主节点选举又依赖共识 ⇒ 共识算法的实现，需要依赖共识**。看起来像一个循环依赖。

### Epoch & Quorum

目前的共识算法都是用了某种形式上的主节点，主节点并不固定。这些算法使用了一种弱化的保证：**定义一个世代编号（Raft: term number, Paxos: ballot number），并保证在每个世代里，主节点是唯一的**。

如果发现当前主节点失效，节点就开始新的一轮主节点选举。**选举会赋予一个单调递增的 epoch 号；如果出现两个不同的节点对应不同的 epoch 号码，则具有更高的 epoch 号码的主节点将获胜**。

在主节点做决定之前，需要先检查是否存在比它更高的 epoch 号码，确保不会同时存在多个主节点。主节点如果想要做某个决定，需要将提议发送给其他所有的节点，等待 quorum 节点响应；如果其他节点没有发现更高的 epoch 主节点存在时，才会对该提议进行投票。

所以，每次提议都会进行两轮投票：

1. 对主节点投票：如果没有更高的 epoch，则当前主节点的地位保持不变
2. 对主节点的提议投票

> 两轮投票的 quorum 必须有重叠

### 共识的局限性

**共识可以提供全序关系广播，以容错的方式实现线性化的原子操作。**

不过，共识的实现是有局限性的：

1. 在达成一致性决议之前，节点投票过程是一个同步复制过程，性能会有影响
2. 共识体系需要多数节点运行才行
3. 多数共识算法假定参与投票的节点数是固定的，意味着不能动态调整节点
4. 共识系统通常依靠超时机制检测节点失效，不过由于网络延迟可能会导致主节点被频繁选举

## 小结

共识意味着就某一项提议，所有节点做出一致的决定，而且决定不可撤销。多个广泛的问题都可以归结于共识：

- 可线性化的 CAS 寄存器
- 原子事务提交
- 全序关系广播
- 锁与租约
- 唯一性约束
- 成员服务（系统决定节点的存活状态）

主从复制系统能够提供线性化操作，唯一性约束，完全有序的复制日志等能力，但是如果唯一的主节点发生故障，为了保证服务的可用性，我们需要重新选取一个主节点。共识算法能够帮助我们选出唯一的主节点。

共识算法对于主从数据库系统来说，主要用于主节点角色的维护与主节点变更的处理。对于多主复制和无主复制系统来说，通常不支持全局共识。