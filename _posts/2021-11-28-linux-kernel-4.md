---

layout: post
title: "Linux Kernel: Processes"
category: "Operating-System"
author: "kkzhang"
image: linux_kernel/chapter_4/lk_1.png
---
进程被定义为**程序执行的一个实例**。在 Linux 中，通常把进程称为任务（task）或者线程（thread）。

> 如果有 n 个用户同时运行 vim 命令，那么就会有 n 个独立的进程；尽管它们共享同一个可执行代码
> 

# 1-进程 & 轻量级进程 & 线程

从内核角度来看，**进程是系统资源（CPU 时间，内存等）分配的实体**。

当一个进程创建时，几乎与父进程相同。子进程接受父进程地址空间的一个逻辑拷贝，并从进程创建系统调用的下一条指令开始执行与父进程相同的代码。尽管父子进程可以共享含有程序代码的页，但是它们有各自独立的数据拷贝（堆 & 栈），因此，子进程对一个内存单元的修改对父进程是不可见的（反之亦然）。

> 父子进程的地址空间采用 copy on write 机制
> 

现代 Unix 系统支持多线程应用程序：一个进程由几个用户线程组成，**每个线程都代表进程的一个执行流**。

> 大部分多线程应用程序都是基于 POSIX thread 标准库实现
> 

从 Linux 内核来看，多线程应用程序仅仅是一个普通的进程。***多线程应用程序多个执行流的创建，处理，调度等都是在用户态进行的***。这种实现方式存在不足：假设一个应用进程中存在两个线程，A 线程在执行部分流程之后需要暂停执行，并等待 B 线程的执行结果。如果 A 线程只是简单的触发阻塞系统调用，试图将 CPU 交给 B，那么 B 线程也会被阻塞（它们同属于一个进程）。相反，A 线程必须使用比较复杂的非阻塞技术来确保进程仍然是可运行的。

**Linux 使用轻量级进程（lightweight process）来实现对多线程应用程序更好的支持**。两个轻量级进程基本上可以共享一些资源，如地址空间，打开的文件等。只要其中一个轻量级进程修改了共享资源，另一个就能立即查看这种修改。

实现多线程应用程序的一个简单方式就是**把轻量级进程与每个线程关联起来**。线程之间可以通过简单共享同一内存地址空间，同一打开文件集等来访问相同的应用程序数据结构集；同时，每个线程都可以由内核单独调度，以便阻塞一个线程的同时，另一个线程仍然是可运行的。

# 2-进程描述符

进程描述符包含了与进程相关的所有信息，类型为 task_struct。

![]({{site.baseurl}}/images/linux_kernel/chapter_4/lk_1.png)

## 2-1 进程状态

进程描述符中的 state 字段标识了进程当前所处的状态（某一时刻只能处于一种状态下）。

- 可运行状态（TASK_RUNNING）
    - 进程要么正在 CPU 上执行，要么准备执行
- 可中断的等待状态（TASK_INTERRUPTIBLE）
    - **进程被挂起（休眠），直到某个条件变成真**。产生一个硬件中断，释放进程正等待的系统资源或者传递一个信号都可以是唤醒进程的条件（进程的状态被重新置为 TASK_RUNNING）
- 不可中断的等待状态（TASK_UNINTERRUPTIBLE）
    - 与可中断的等待状态蕾西，但是有一点不同，把信号传递到休眠进程并不能改变进程的状态（该状态只会在一些特定的情况下使用）
- 暂停状态（TASK_STOPPED）
    - 进程的执行被暂停：当进程收到 SIGSTOP, SIGTSTP, SIGTTIN or SIGTTOU 信号后，进入暂停状态
- 跟踪状态（TASK_TRACED）
    - 进程的执行已由 debugger 程序暂停
- 僵死状态（TASK_ZOMBIE）
    - 进程的执行被终止，但是父进程还没有发布 wait4() or waitpid() 系统调用来返回有关死亡进程的信息
- 僵死撤销状态（EXIT_DEAD）
    - 最终状态：由于父进程刚发出 wait4() or waitpid() 系统调用，因而进程被系统删除

## 2-2 标识进程