---

layout: post
title: "Linux Kernel: Signals"
category: "Operating-System"
author: "kkzhang"
---
信号最早在 Unix 系统中被引入，**用于在用户态进程间通信；内核也用信号通知进程系统所发生的事件**。

# 1-信号的作用

**信号（signal）**是很短的消息，**可以被发送到一个进程或者一组进程**。发送给进程的唯一信息通常是一个数，以此来标识信号。

使用信号有两个目的：

1. *让进程知道已经发生了一个特定的事件*
2. *强迫进程执行其自己代码中的信号处理程序*

> 这两个目的并不互斥

![]({{site.baseurl}}/images/linux_kernel/chapter_11/lk_1.png)

上图是 Linux 中前 31 个**常规信号（regular signal）**。除了常规信号，POSIX 标准还引入了新的信号，被称为**实时信号（real-time signal）**：在 Linux 中的编码范围为 32~64。

- 实时信号必须排队以便发送的多个信号能够被接收到
- 同种类型的常规信号并不排队：如果一个常规信号被连续发送多次，那么只有其中一个信号能够发送到接收进程

> Linux 内核并不使用实时信号，但还是通过几个特定的系统调用完全实现了 POSIX 标准

**许多系统调用允许应用进程发送信号，并决定应用进程如何响应所接收到的信号**。下图是一些与信号相关的重要系统调用。

![]({{site.baseurl}}/images/linux_kernel/chapter_11/lk_2.png)

信号的一个比较重要的特点：**信号可以随时被发送给状态不可预知的进程**。

- 发送给非运行进程的信号必须由内核保存，直到进程恢复执行

- 阻塞一个信号要求信号的传递拖延，直到阻塞解除

  > 使得信号产生一段时间之后才能对其传递这一问题变得更加严重

内核将信号传递分为两个阶段：

1. **信号产生**

   内核更新目标进程的数据结构以表示一个新信号已被发送

2. **信号传递**

   内核强迫目标进程对信号做出反应：要么*改变目标进程的执行状态*，要么*开始执行一个特定的信号处理程序*，要么两者都是

**每个产生的信号至多被传递一次**。

> 信号是可消费资源，一旦已经被传递出去，那么进程描述符中有关这个信号的所有信息都被取消

**挂起信号（pending signal）**：已经产生但还没有被传递的信号。*任何时候，一个进程仅存在给定类型的一个挂起信号，同一进程同种类型的其他信号不会被排队，只是简单地丢弃*。但是，实时信号有所不同：同种类型的挂起信号可以有多个。







