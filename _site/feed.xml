<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-03-02T23:43:05+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Find a needle in haystack</title><subtitle>Code.
</subtitle><author><name>kkzhang</name></author><entry><title type="html">状语从句</title><link href="http://localhost:4000/adverbial-clause.html" rel="alternate" type="text/html" title="状语从句" /><published>2022-03-02T00:00:00+08:00</published><updated>2022-03-02T00:00:00+08:00</updated><id>http://localhost:4000/adverbial-clause</id><content type="html" xml:base="http://localhost:4000/adverbial-clause.html">&lt;h1 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h1&gt;
&lt;p&gt;状语从句指句子用作状语时, 起副词作用的句子。它可以修饰谓语、非谓语动词、定语、状语或整个句子。根据其作用可分为时间、地点、原因、条件、目的、结果、让步、方式和比较等从句。
状语从句一般由连词(从属连词)引导，也可以由词组引起。从句位于句首或句中时通常用逗号与主句隔开，位于句尾时可以不用逗号隔开。&lt;/p&gt;

&lt;h1 id=&quot;2-地点状语从句&quot;&gt;2-地点状语从句&lt;/h1&gt;
&lt;h2 id=&quot;2-1-介绍&quot;&gt;2-1-介绍&lt;/h2&gt;

&lt;p&gt;地点状语从句表示地点，方位，通常由 where 引导。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He lives there. (there 做地点状语)&lt;/li&gt;
  &lt;li&gt;He lives in Inner Mongolia. (in inner Mongolia 做地点状语)&lt;/li&gt;
  &lt;li&gt;He lives where the climate is mild. (where … 做地点状语从句)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-2-引导词&quot;&gt;2-2-引导词&lt;/h2&gt;

&lt;p&gt;常用引导词 &lt;strong&gt;where&lt;/strong&gt;，特殊引导词 &lt;strong&gt;wherever, anywhere, everywhere.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;| 引导词 | 含义 | 说明 |
| — | — | — |
| where | 在……地方 | 通常表示一个确定的地方 |
| wherever | 无论什么地方 | 表示任何地方 |
| anywhere | 任何地方 | 表示任何地方 |
| everywhere | 到处 | 表示任何地方 |&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;We must camp where we can get water.&lt;/li&gt;
  &lt;li&gt;They will go where they are happy.&lt;/li&gt;
  &lt;li&gt;Wherever there is political upheaval, invariably there are refugees.&lt;/li&gt;
  &lt;li&gt;We have sworn to fight cruelty wherever we find it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-3-地点状语从句与定语从句的区别&quot;&gt;2-3-地点状语从句与定语从句的区别&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;where 引导定语从句时，where 是关系副词，并且 &lt;strong&gt;where 在从句中作地点状语&lt;/strong&gt;，&lt;strong&gt;前面有表示地点的先行词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;The bookshop where I bought this book is not far from here.&lt;/li&gt;
      &lt;li&gt;This is the house where I lived two years ago.&lt;/li&gt;
      &lt;li&gt;We will start at the point where we left off.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;where 引导状语从句时，where 是从属连词。&lt;strong&gt;where 引导的从句修饰主句的谓语动词，并且 where 前面没有表示地点的先行词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Wuhan lies where the Changjiang River and the Hanjiang River meet.&lt;/li&gt;
      &lt;li&gt;Make a mark where you have any doubts or questions.&lt;/li&gt;
      &lt;li&gt;I found my books where I had left them.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有时 where 引导的地点状语从句兼有抽象条件含义，&lt;strong&gt;可放在主句的前面&lt;/strong&gt;，而 where 引导的定语从句则不能
    &lt;ul&gt;
      &lt;li&gt;Where there is a will, there is a way.&lt;/li&gt;
      &lt;li&gt;Where there is water, there is life.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在有些情况下，where 引导的定语从句可转换为 where 引导的地点状语从句
    &lt;ul&gt;
      &lt;li&gt;A tall building was put up at the place where there used to be a desert
  = A tall building was put up where there used to be a desert.&lt;/li&gt;
      &lt;li&gt;Bamboo grows best in places where it is warm and where it rains often.
  = Bamboo grows best where it is warm and where it rains often.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;3-时间状语从句&quot;&gt;3-时间状语从句&lt;/h1&gt;
&lt;h2 id=&quot;3-1-介绍&quot;&gt;3-1-介绍&lt;/h2&gt;

&lt;p&gt;时间状语从句用表示时间的连词连接一个句子作状语。连接时间状语从句的连接词有: &lt;strong&gt;when, before, after, while, as soon as, until, since&lt;/strong&gt; 等。&lt;/p&gt;

&lt;h2 id=&quot;3-2-连接词&quot;&gt;3-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;3-2-1-when&quot;&gt;3-2-1 when&lt;/h3&gt;

&lt;p&gt;when 表示 “当…的时候”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;既可以表示时间段，也可以表示时间点&lt;/li&gt;
  &lt;li&gt;从句既可用延续性动词，也可用非延续性动词&lt;/li&gt;
  &lt;li&gt;从句动作&lt;strong&gt;既可与主句的动作同时发生，又可在主句的动作之前或之后发生&lt;/strong&gt;
例句：
    &lt;ul&gt;
      &lt;li&gt;When I met the Gills, I had been gardening for nearly ten years.&lt;/li&gt;
      &lt;li&gt;I’ll start to think about it when I have to write my report.&lt;/li&gt;
      &lt;li&gt;It was raining when we arrived.&lt;/li&gt;
      &lt;li&gt;When I came home, my wife was cooking dinner.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;如果 when 引导的时间状语从句的主语与主句的主语相同，并且从句的谓语动词为 be 动词时，可以省略主语 &amp;amp; be 动词&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When (you are) in trouble, ask her for help.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果 when 引导的从句的主语与主句的主语相同，可以用 &lt;strong&gt;“when + 分词” 代替状语从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When I came into the room ( When coming into the room), I found him lying there asleep.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-2-2-while&quot;&gt;3-2-2 while&lt;/h3&gt;

&lt;p&gt;while 表示 “当…的时候”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;只能表示一段时间，不能表示时间点&lt;/li&gt;
  &lt;li&gt;从句的谓语动词只能是延续性的&lt;/li&gt;
  &lt;li&gt;从句动作&lt;strong&gt;只能与主句同时发生或者存在&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例句：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Don’t interrupt him while he is thinking.&lt;/li&gt;
  &lt;li&gt;While Jim was mending his bike, Lin Tao came to see him.&lt;/li&gt;
  &lt;li&gt;She got married while working as a waitress.&lt;/li&gt;
  &lt;li&gt;You can’t do your homework while you’re watching TV.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-2-3-as&quot;&gt;3-2-3 as&lt;/h3&gt;

&lt;p&gt;as 表示 “当…时，一边…一边”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;侧重两个动作同时发生&lt;/strong&gt;（包括同一个主语同时进行两个动作）；或者一种动作随着另一个动作的变化而变化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Another policeman has been injured as fighting continued this morning.&lt;/li&gt;
  &lt;li&gt;I slipped on the ice as I ran home.&lt;/li&gt;
  &lt;li&gt;I saw him as he was getting off the bus.&lt;/li&gt;
  &lt;li&gt;As the wind rose, the noise increased.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-条件状语从句&quot;&gt;4-条件状语从句&lt;/h1&gt;
&lt;h2 id=&quot;4-1-介绍&quot;&gt;4-1-介绍&lt;/h2&gt;

&lt;p&gt;条件是指某一事情实现之后（状语从句中的动作），其他事情才会发生（主句中的动作），通常表示“如果”。
&lt;strong&gt;在句子中做条件状语的从句叫做条件状语从句（通常置于句首或句尾）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;引导条件状语从句的常用连词是 if，表示“如果”。其他连词有：&lt;strong&gt;unless&lt;/strong&gt;（除非），&lt;strong&gt;as/so long as&lt;/strong&gt;（只要）， &lt;strong&gt;providing/provided that&lt;/strong&gt;（假如），&lt;strong&gt;supposing that&lt;/strong&gt;, &lt;strong&gt;in case,&lt;/strong&gt; &lt;strong&gt;on condition that&lt;/strong&gt; 等。&lt;/p&gt;

&lt;h2 id=&quot;4-2-连接词&quot;&gt;4-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;4-2-1-if&quot;&gt;4-2-1 if&lt;/h3&gt;

&lt;p&gt;if 引导的条件状语从句分为两类：一种是真实条件句，一种是虚拟条件句。&lt;/p&gt;

&lt;p&gt;if 引导的条件状语从句表示在某种条件下，某事发生的可能性大。&lt;/p&gt;

&lt;p&gt;例句：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If you ask him, he will help you.&lt;/li&gt;
  &lt;li&gt;If you fail in the exam, you will let him down.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;if 引导的条件状语从句既可以放在主句之前，也可以放在主句之后。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If it rains, we will stop playing. = We will stop playing if it rains.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如果主句是将来时，从句要用一般现在时代替一般将来时&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If he runs, he will get there in time.&lt;/li&gt;
  &lt;li&gt;The cat will scratch you if you if you pull her tail.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-2-unless&quot;&gt;4-2-2 unless&lt;/h3&gt;

&lt;p&gt;unless 表示“除非，若不，除非在……的时候”，等同于 if … not。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You will fail to arrive there in time unless you start earlier.&lt;/li&gt;
  &lt;li&gt;Unless it rains, the game will be played.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-3-as-long-as--so-long-as&quot;&gt;4-2-3 as long as &amp;amp; so long as&lt;/h3&gt;

&lt;p&gt;as/so long as 表示“只要…”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;As long as my heart still beats, I will go on working for the people.&lt;/li&gt;
  &lt;li&gt;As long as the green hills are there, one need not worry about firewood.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-4-in-case&quot;&gt;4-2-4 in case&lt;/h3&gt;

&lt;p&gt;in case 表示“如果，万一”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In case I forget, please remind me about it.&lt;/li&gt;
  &lt;li&gt;Dad brought a notebook along to the beach, in case he was seized by sudden inspiration.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-5-on-condition-that&quot;&gt;4-2-5 on condition that&lt;/h3&gt;

&lt;p&gt;on condition (that) 表示“在…条件下”，引导的条件是&lt;strong&gt;主句发生的前提条件或者唯一条件&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I can tell you the truth on condition that you promise to keep a secret.&lt;/li&gt;
  &lt;li&gt;You can go swimming on condition (that) you don’t go too far from the river bank.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-6-supposing&quot;&gt;4-2-6 supposing&lt;/h3&gt;

&lt;p&gt;supposing 表示“如果，假设”，引导的条件状语从句表示一种假设的条件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Supposing it rains, shall we continue the sports meeting?&lt;/li&gt;
  &lt;li&gt;Supposing anything should go wrong, what would you do then?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-7-provided-that&quot;&gt;4-2-7 provided that&lt;/h3&gt;

&lt;p&gt;provided (that) 表示“假如，除非，以…为条件”，引导的从句表示一种假设条件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He will sign the contract provided we offer more favorable terms.&lt;/li&gt;
  &lt;li&gt;He won’t be against us in the meeting provided that we ask for his advice in advance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5-原因状语从句&quot;&gt;5-原因状语从句&lt;/h1&gt;
&lt;h2 id=&quot;5-1-介绍&quot;&gt;5-1-介绍&lt;/h2&gt;

&lt;p&gt;原因状语从句用来解释某件事发生的原因，最常用的从属连词为 &lt;strong&gt;because&lt;/strong&gt;，强调原因。&lt;/p&gt;

&lt;p&gt;除此之外，还有其他从属连词：&lt;strong&gt;as, since, for, now (that), when, seeing (that), considering (that), given (that), in that, for the reason that&lt;/strong&gt; 等。&lt;/p&gt;

&lt;h2 id=&quot;5-2-连接词&quot;&gt;5-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;5-2-1-because&quot;&gt;5-2-1 because&lt;/h3&gt;

&lt;p&gt;because 引导的原因状语从句一般放在主句后面。当从句放在主句前面时，需要用逗号隔开；而从句在后面时，可用或者不用逗号分隔。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We didn’t go for an outing last Saturday, &lt;strong&gt;&lt;em&gt;because&lt;/em&gt;&lt;/strong&gt; it was raining hard the whole day.&lt;/li&gt;
  &lt;li&gt;We didn’t go for an outing last Saturday &lt;strong&gt;&lt;em&gt;because&lt;/em&gt;&lt;/strong&gt; it was raining hard the whole day.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Because&lt;/em&gt;&lt;/strong&gt; it was raining hard the whole day, we didn’t go for an outing last Saturday.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;because 的&lt;strong&gt;语气一般比较强&lt;/strong&gt;，常用来回答 why 引导的疑问句。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;Why didn’t you come to my birthday party last night? - Because my sister was ill. I had to take care of her the whole night.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;because 不能与 so 连用&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;because of 也表示原因，为介词短语，后跟名词，代词，动名词及其短语。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He can’t go to school &lt;strong&gt;&lt;em&gt;because of&lt;/em&gt;&lt;/strong&gt; his illness.&lt;/li&gt;
  &lt;li&gt;He can’t go to school &lt;strong&gt;&lt;em&gt;because&lt;/em&gt;&lt;/strong&gt; he is ill.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;not because&lt;/strong&gt; 结构中的否定词有时用来否定主句，有时用来否定从句，容易引起歧义。如果想明否定主句，最好在 because 从句前用逗号隔开。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I didn’t go there yesterday, because I was afraid.（因为害怕，所以没去）&lt;/li&gt;
  &lt;li&gt;I went there yesterday, not because I was afraid.（去那里，并不是因为害怕）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-2-since&quot;&gt;5-2-2 since&lt;/h3&gt;

&lt;p&gt;since 可以理解为“既然”，用来表示双方已知的，显然的理由；相当于 now that，不过更为正式；语气比 because 弱，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;since 引导的原因状语从句常放在主句之前&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Since&lt;/em&gt;&lt;/strong&gt; you are free today, can you help me with the housework?&lt;/li&gt;
  &lt;li&gt;Now that you are grown up, you should rely on yourself.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;since 除了引导原因状语从句，还可以在后面接时间或者过去发生的事情，表示“自从…以来”。此时，&lt;strong&gt;从句常用一般过去时，主句常用完成时&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I have lived here since 2015.&lt;/li&gt;
  &lt;li&gt;She has learned English since she was two years old.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-3-as&quot;&gt;5-2-3 as&lt;/h3&gt;

&lt;p&gt;as 引导原因状语从句时，表示“附带说明的，双方已知的原因”，语气比 since 弱。位置比较灵活，但是常放在主句之前。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;As the wage of the job was low, there were few applicants for it.&lt;/li&gt;
  &lt;li&gt;As you are tired, you had better take a rest.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;除了引导原因状语从句，as 也可以用来引导时间状语从句与方式状语从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A sudden chill of horror sweeps over her as she feels the drip of saliva upon her hand.（时间状语从句）&lt;/li&gt;
  &lt;li&gt;She did it as I had told her to.（方式状语从句）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-4-for&quot;&gt;5-2-4 for&lt;/h3&gt;

&lt;p&gt;for 表示原因，但是并&lt;strong&gt;不构成主句行为发生的直接原因&lt;/strong&gt;，只是提供一些辅助性的补充说明。&lt;/p&gt;

&lt;p&gt;for 引导并列句，且只能放在主句之后并用逗号隔开。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It must have rained last night, for the street is wet all over.（主句与从句不构成直接因果关系）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-5-其他连接词&quot;&gt;5-2-5 其他连接词&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;She is much more mobile &lt;strong&gt;&lt;em&gt;now that&lt;/em&gt;&lt;/strong&gt; she has a car.（既然）&lt;/li&gt;
  &lt;li&gt;I won’t tell you &lt;strong&gt;&lt;em&gt;when&lt;/em&gt;&lt;/strong&gt; you won’t listen.（既然）&lt;/li&gt;
  &lt;li&gt;He looks young &lt;strong&gt;&lt;em&gt;considering&lt;/em&gt;&lt;/strong&gt; his age.（考虑到）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Given that&lt;/em&gt;&lt;/strong&gt; he was still a boy, I forgave him.（考虑到）&lt;/li&gt;
  &lt;li&gt;We aren’t going &lt;strong&gt;&lt;em&gt;for the simple reason that&lt;/em&gt;&lt;/strong&gt; we can’t afford it.（因为）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-目的状语从句&quot;&gt;6-目的状语从句&lt;/h1&gt;
&lt;h2 id=&quot;6-1-介绍&quot;&gt;6-1-介绍&lt;/h2&gt;

&lt;p&gt;目的状语从句：在句子中充当目的状语的从句，主要用来补充说明主句中&lt;strong&gt;谓语动词发生的目的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He got up early &lt;strong&gt;&lt;em&gt;so as to&lt;/em&gt;&lt;/strong&gt; catch the first morning bus.（so as to… 做目的状语）&lt;/li&gt;
  &lt;li&gt;He got up early &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; he could catch the first morning bus.（so that… 做目的状语从句）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-2-连接词&quot;&gt;6-2-连接词&lt;/h2&gt;

&lt;p&gt;连接目的状语从句的连接词有：&lt;strong&gt;so that, in order that, for fear that, in case&lt;/strong&gt; 等。&lt;/p&gt;

&lt;p&gt;目的状语从句的谓语动中通常含有：may, could, will, might, can, should, would 等情态动词。&lt;/p&gt;

&lt;h3 id=&quot;6-2-1-so-that&quot;&gt;6-2-1 so that&lt;/h3&gt;

&lt;p&gt;so that 表示“以便，为了”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I set up the computer so that they could work from home.&lt;/li&gt;
  &lt;li&gt;I’ll give you all the facts so that you can judge for yourself.&lt;/li&gt;
  &lt;li&gt;They put a screen around his bed so that the doctor could examine him.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;so that 有时可以&lt;strong&gt;省略 so&lt;/strong&gt;，只用 that 连接。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bring it closer (so) that I may see it better.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当主句与从句的主语相同时，可以用 &lt;strong&gt;so as to do 短语替代 so that&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;One should learn from past mistakes &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; he or she can avoid falling into the same old trap again.&lt;/li&gt;
  &lt;li&gt;One should learn from past mistakes &lt;strong&gt;&lt;em&gt;so as to&lt;/em&gt;&lt;/strong&gt; avoid falling into the same old trap again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意 so that 与 so … that 的区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;so that 表示目的状语从句：
    &lt;ul&gt;
      &lt;li&gt;He went to bed very early last night &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; he could get up early this morning.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;so … that 表示结果状语从句：
    &lt;ul&gt;
      &lt;li&gt;He stayed up &lt;strong&gt;&lt;em&gt;so&lt;/em&gt;&lt;/strong&gt; late last night &lt;strong&gt;&lt;em&gt;that&lt;/em&gt;&lt;/strong&gt; he couldn’t get up early this morning.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;6-2-2-in-order-that&quot;&gt;6-2-2 in order that&lt;/h3&gt;

&lt;p&gt;in order that 表示“为了，以便”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They flew there &lt;strong&gt;&lt;em&gt;in order that&lt;/em&gt;&lt;/strong&gt; they might be in time to attend the opening ceremony.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;In order that&lt;/em&gt;&lt;/strong&gt; we might get there on time, we should set out early.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当主句与从句的主语相同时，可用 &lt;strong&gt;in order to do 短语代替 in order that 从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I came &lt;strong&gt;&lt;em&gt;in order that&lt;/em&gt;&lt;/strong&gt; I could see Jack.&lt;/li&gt;
  &lt;li&gt;I came &lt;strong&gt;&lt;em&gt;in order to&lt;/em&gt;&lt;/strong&gt; see Jack.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-2-3-for-fear-that&quot;&gt;6-2-3 for fear that&lt;/h3&gt;

&lt;p&gt;for fear that 表示“以免，唯恐”。&lt;/p&gt;

&lt;p&gt;如果从句的情态动词时 should 时，此时 should 可以省略。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He told us to keep quiet &lt;strong&gt;&lt;em&gt;for fear that&lt;/em&gt;&lt;/strong&gt; we might disturb others.&lt;/li&gt;
  &lt;li&gt;We hurried along &lt;strong&gt;&lt;em&gt;for fear that&lt;/em&gt;&lt;/strong&gt; we (should) be late.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当主句与从句的主语相同时，可以用 &lt;strong&gt;for fear of doing 短语代替 for fear that 从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We spoke quietly &lt;strong&gt;&lt;em&gt;for fear that&lt;/em&gt;&lt;/strong&gt; we should wake the guards.&lt;/li&gt;
  &lt;li&gt;We spoke quietly &lt;strong&gt;&lt;em&gt;for fear of&lt;/em&gt;&lt;/strong&gt; waking the guards.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-2-4-in-case&quot;&gt;6-2-4 in case&lt;/h3&gt;

&lt;p&gt;in case 表示“以防，万一”。&lt;/p&gt;

&lt;p&gt;从句一般使用情态动词 should，且 should 可省略；从句表示虚拟语气。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They watched him closely &lt;strong&gt;&lt;em&gt;in case&lt;/em&gt;&lt;/strong&gt; he (should) escape.&lt;/li&gt;
  &lt;li&gt;I stopped suddenly &lt;strong&gt;&lt;em&gt;in case&lt;/em&gt;&lt;/strong&gt; he (should) think that I was showing off.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;in case 还可以表示“假如，如果”。此时引导的从句不再使用虚拟语气，一般也不使用情态动词&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In case she comes back, let me know immediately.&lt;/li&gt;
  &lt;li&gt;I keep a warm coat at work in case it suddenly turns cold.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;in case of 表示“假如，如果发生”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In case of fire, ring the alarm bell.&lt;/li&gt;
  &lt;li&gt;We have an auxiliary generator in case of power cuts.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="nglish-study" /><summary type="html">1-介绍 状语从句指句子用作状语时, 起副词作用的句子。它可以修饰谓语、非谓语动词、定语、状语或整个句子。根据其作用可分为时间、地点、原因、条件、目的、结果、让步、方式和比较等从句。 状语从句一般由连词(从属连词)引导，也可以由词组引起。从句位于句首或句中时通常用逗号与主句隔开，位于句尾时可以不用逗号隔开。</summary></entry><entry><title type="html">编程珠玑: 编写正确的程序</title><link href="http://localhost:4000/programming-pearls-4.html" rel="alternate" type="text/html" title="编程珠玑: 编写正确的程序" /><published>2022-02-27T00:00:00+08:00</published><updated>2022-02-27T00:00:00+08:00</updated><id>http://localhost:4000/programming-pearls-4</id><content type="html" xml:base="http://localhost:4000/programming-pearls-4.html">&lt;h2 id=&quot;二分搜索&quot;&gt;二分搜索&lt;/h2&gt;

&lt;p&gt;二分搜索的目标是确定在排序数组 x[0…n-1] 中是否存在目标元素 t，如果存在则返回对应的索引 p，否则返回 -1。&lt;/p&gt;

&lt;p&gt;该算法实现思路为：通过&lt;strong&gt;持续跟踪数组中包含元素 t 的范围&lt;/strong&gt;（如果 t 存在数组中）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一开始，该范围是整个数组&lt;/li&gt;
  &lt;li&gt;通过将 t 与数组的中间项进行比较并抛弃一半的范围来缩小目标范围&lt;/li&gt;
  &lt;li&gt;持续步骤 2，直到在数组中找到 t 或者确定包含 t 的范围为空时为止&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在包含 n 个元素的数组中，二分搜索需要执行 $logn$ 次比较操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;线性搜索需要 $n/2$ 次比较&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;编写程序&quot;&gt;编写程序&lt;/h2&gt;

&lt;p&gt;二分搜索的思想为：&lt;strong&gt;如果 t 在 x[0…n-1] 中，那么 t 一定存在于 x 的某个特定范围内&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通过使用&lt;strong&gt;循环不变式&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mustbe(range)&lt;/code&gt; 来表示：如果 t 在数组中，那么其一定在 range 内。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;invariant:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mustbe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cumpute&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;middle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;probe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shrink&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;during&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shrinking&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;report&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;循环不变式是程序状态的断言（assertion），在循环迭代之前和之后，该断言都为真。&lt;/p&gt;

&lt;p&gt;range 用下标&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;（l, u）&lt;/code&gt;表示，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mustbe(l,u)&lt;/code&gt; 表示：如果 t 在数组中，则一定在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[l...u]&lt;/code&gt; 内。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;loop:&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;invariant:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mustbe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;t:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;t:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;t:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的伪代码中，如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[m] &amp;lt; t&lt;/code&gt;，那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[0] ≤ x[1] ... ≤ x[m] &amp;lt; t&lt;/code&gt;，所以 t 不会存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[0...m]&lt;/code&gt; 范围内。将该结论与已知条件 t 存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[l...u]&lt;/code&gt; 之内，可知 t 一定在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[m+1, u]&lt;/code&gt; 之内，即为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mustbe(m+1, u)&lt;/code&gt;。因此，通过将 l 设为 m+1 可以再次确立不变式 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mustbe(l, u)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;理解程序&quot;&gt;理解程序&lt;/h2&gt;

&lt;p&gt;上述代码的正确性分为 3 个部分，每部分都与循环不变式相关：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;循环初次执行时，不变式为真。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;保持&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果某次迭代开始的时候 &amp;amp; 循环体执行的时候，不变式都为真，那么，循环体执行完毕的时候不变式仍为真。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;终止&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;循环能够终止，并且可以得到期望的结果（需要用到不变式所确立的事实）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 迭代&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// mustbe(l, u)&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 递归&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>kkzhang</name></author><category term="algrithom" /><summary type="html">二分搜索</summary></entry><entry><title type="html">Redis Cluster Specification</title><link href="http://localhost:4000/redis-cluster-specification.html" rel="alternate" type="text/html" title="Redis Cluster Specification" /><published>2022-02-19T00:00:00+08:00</published><updated>2022-02-19T00:00:00+08:00</updated><id>http://localhost:4000/redis-cluster-specification</id><content type="html" xml:base="http://localhost:4000/redis-cluster-specification.html">&lt;h1 id=&quot;1-main-properties-and-rationales-of-the-design&quot;&gt;1-Main properties and rationales of the design&lt;/h1&gt;

&lt;h2 id=&quot;1-1-redis-cluster-goals&quot;&gt;1-1 Redis Cluster goals&lt;/h2&gt;

&lt;p&gt;Redis Cluster 是 Redis 的分布式实现，按照优先级有以下目标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;高性能&lt;/strong&gt;（high performance）&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;线性扩展&lt;/strong&gt;（linear scalability）至 1000 个节点&lt;/li&gt;
  &lt;li&gt;没有代理；集群节点间通过&lt;strong&gt;异步复制数据&lt;/strong&gt;；不支持数据合并操作&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可接受的写入安全：在网络分区情况下，系统尽可能保存访问到多数派分区的 Client 的写操作。不过，存在一个小的时间窗口，在此期间的写入操作可能会丢失（&lt;em&gt;failover 前的写入可能会在 failover 过程中丢失&lt;/em&gt;）。如果 Client 的写入操作连接到少数派分区，则这个丢失时间窗口会更大。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;网络分区时，集群节点被划分成多数派分区（majority），少数派分区（minority）&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可用性：Redis Cluster 在&lt;strong&gt;大部分 master 节点可用，并且对少部分不可用的 master，每一个 master 至少有一个当前可用的 slave&lt;/strong&gt; 场景下能够保证集群的可用性。&lt;/p&gt;

    &lt;p&gt;另外，通过使用 &lt;strong&gt;replicas migration&lt;/strong&gt; 技术，当前没有 slave 的 master 会从当前拥有多个 slave 的 master 接受到一个新 slave 来确保可用性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-2-implemented-subset&quot;&gt;1-2 Implemented subset&lt;/h2&gt;

&lt;p&gt;Redis Cluster 实现了所有在非分布式 Redis 版本中的单 key 命令；但是对于使用多个 key 的复杂操作没有实现，比如 set 中的 unions &amp;amp; intersections 操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不支持多个 key 的复杂操作是为了避免 key-value 在不同的 Cluster 节点间移动，使得情况更加复杂&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;不过，Redis Cluster 实现了被称为 &lt;strong&gt;Hash Tags&lt;/strong&gt; 的概念：多个 key 可以通过相同的 hash tag 存储在相同的 hash slot 中，从而避免了 key 的迁移。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在手动 resharding 期间，多 key 操作可能变的不可用&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;除了支持的命令不同，Redis Cluster 只支持 database 0，并不像单机版 Redis 支持多个数据库。&lt;/p&gt;

&lt;h3 id=&quot;1-2-1-why-merge-operations-are-avoided&quot;&gt;1-2-1 Why merge operations are avoided&lt;/h3&gt;

&lt;p&gt;Redis Cluster 设计是避免在多个节点中存在相同 key-value 对的冲突版本，因为 Redis 中的值通常都是比较大的，数据类型也是语义复杂的，传输和合并这样的值将会影响性能。&lt;/p&gt;

&lt;h2 id=&quot;1-3-clients-and-servers-roles-in-the-redis-cluster-protocol&quot;&gt;1-3 Clients and Servers roles in the Redis Cluster protocol&lt;/h2&gt;

&lt;p&gt;Cluster 节点主要任务有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据维护&lt;/li&gt;
  &lt;li&gt;集群状态获取&lt;/li&gt;
  &lt;li&gt;将 key 映射到正确的 Cluster 节点&lt;/li&gt;
  &lt;li&gt;自动发现其他 Cluster 节点&lt;/li&gt;
  &lt;li&gt;检测异常 Cluster 节点&lt;/li&gt;
  &lt;li&gt;当某个 master 节点故障时，提升其副本为 master 节点，以保证 Cluster 正常运行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了实现上述功能，所有 Redis Cluster 节点间通过 &lt;strong&gt;Redis Cluster Bus&lt;/strong&gt; 互相连接：由 TCP bus 及二进制协议组成。节点间通过 &lt;strong&gt;Gossip 协议传递集群信息&lt;/strong&gt;，以此来实现新节点发现，节点探活及标定特定状态等功能。&lt;/p&gt;

&lt;p&gt;由于 Cluster 节点不能代理请求，因此 Client 在收到重定向异常（MOVED, ASK）时，需要将请求重定向到其他节点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Client 通过缓存 key → cluster node 的映射关系，减少重定向，提高执行效率&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-4-write-safety&quot;&gt;1-4 Write safety&lt;/h2&gt;

&lt;p&gt;Redis Cluster 通过&lt;strong&gt;节点间异步复制数据&lt;/strong&gt;，及 &lt;strong&gt;last failover wins&lt;/strong&gt; 避免合并功能 。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;last failover wins 指当 master 节点故障时，通过 failover 机制选取的新 master 节点将直接覆盖之前 master 节点的数据，并同步给其他 slaves（新 master 节点中的数据可能不是最新的，或者有所缺失）。通过 last failover wins 机制，最后选举出的新 master 副本数据会覆盖其他所有副本数据。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在网络分区期间，会存在一个写操作丢失的时间窗口。&lt;em&gt;对于发生在 master 节点多数派（majority）分区的写操作丢失窗口与少数派（minority）的丢失窗口是不同的&lt;/em&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于发生在多数派 master 的写操作，Redis Cluster 会尽量保存；但是以下两种场景除外：
 a. client 写操作请求到达 master 节点，当 master 执行完成并回复 client 成功之后，master 出现异常而不可访问；但是之前的写操作并未通过异步复制到其他 slaves 中。如果 master 不可访问的时间较长而导致其中的一个 slave 被选举成新的 master，那么之前的写操作将会丢失。
 b. 由于网络分区，某个 master 不可被访问。网络分区触发了一轮选举，导致其中的一个 slave 被选举成新的 master。网络分区恢复之后，old master 变成 new master 的 slave 之前，一个 client 通过过期的路由表对 old master 节点进行写入，此时的写入将会被全部丢失。&lt;/p&gt;

    &lt;p&gt;不过，对于第二种场景，在一些安全机制的条件下很难发生：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;少数派 master 与多数派 master 无法通信达到一定的时间后，将拒绝 client 的写操作请求&lt;/li&gt;
      &lt;li&gt;当网络分区恢复后，该 master 仍需要继续拒绝写入一段时间用来感知 Cluster 的配置变化，因此留给 client 的时间窗口很小&lt;/li&gt;
      &lt;li&gt;在分区恢复之后，其他节点会尽快尝试访问新加入的节点（携带最新的 Cluster 配置信息）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于发生在少数派 master 的写操作拥有更大的丢失窗口&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;如果少数派 master 节点通过 failover 转移到多数派 master 节点的分区，那么所有发送到少数派分区的写操作都将会被永久丢失&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;发生 failover 的前提是，其中的 master 节点至少在 NODE_TIMEOUT 时间内无法被多数派 master 节点访问&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分区故障时间小于 NODE_TIMEOUT，则不会出现写操作数据丢失&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分区故障时间大于 NODE_TIMEOUT，则对少数派 master 的写入操作将全部丢失&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;不过少数派 master 会在进入不可用状态之后拒绝写入请求&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-5-availability&quot;&gt;1-5 Availability&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Redis Cluster 能容忍集群中少数节点不可访问，但不适合要求大量网络分块的应用&lt;/strong&gt;（如多机房部署）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;集群在少数派分区侧不可用&lt;/li&gt;
  &lt;li&gt;对于多数派 master 分区，如果其他每个不可访问的 master 节点都至少有一个 slave 节点可达，那么在经过 NODE_TIMEOUT 重新选举之后，多数派分区仍然可用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;为了提高集群可用性，Redis Cluster 支持 Replicas Migration：&lt;/strong&gt;自动将转移副本节点到孤立的 master 节点（不再拥有 slave 的 master）；每次 failover 成功之后，都会重新配置 slave 副本分布以提高下一次故障期间的可用性。&lt;/p&gt;

&lt;h1 id=&quot;2-overview-of-redis-cluster-main-components&quot;&gt;2-Overview of Redis Cluster main components&lt;/h1&gt;

&lt;h2 id=&quot;2-1-keys-distribution-model&quot;&gt;2-1 Keys distribution model&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;key 的空间范围被划分为 16834 个 slot&lt;/strong&gt;，间接使得一个集群的最大上限为 16834 个 master 节点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般建议最大节点数少于 1000&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Cluster 中的每个 master 节点处理 16834 个 hash slot 的其中一部分子集。当 Cluster 处于稳定状态时，每个 hash slot 只会由一个节点提供服务。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;没有出现 slot 迁移的情况被认为是稳定状态&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;将 key 映射为对应的 hash slot 方法为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;HASH_SLOT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CRC16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16384&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-2-keys-hash-tags&quot;&gt;2-2 Keys hash tags&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Hash Tags 提供了一种将多个 key 分配到同一个 hash slot 的方式&lt;/strong&gt;。通过 Hash Tags 可以在 Redis Cluster 中实现对多个 key 的同时操作。&lt;/p&gt;

&lt;p&gt;Hash Tags 的规则如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;key 包含一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt; 字符&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;并且&lt;/em&gt; 如果在这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt;的右面有一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;}&lt;/code&gt;字符&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;并且&lt;/em&gt; 如果在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;}&lt;/code&gt;之间存在至少一个字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{ }&lt;/code&gt; 之间的字符将被用来计算 hash slot。如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{user1000}.following&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{user1000}.followers&lt;/code&gt;这两个 key 会被分配到相同的 hash slot 中，因为只有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user1000&lt;/code&gt;会被用来计算 hash slot 值。&lt;/p&gt;

&lt;h2 id=&quot;2-3-cluster-nodes-attributes&quot;&gt;2-3 Cluster nodes attributes&lt;/h2&gt;

&lt;p&gt;集群中的&lt;strong&gt;每个节点都有全局唯一 ID 标识&lt;/strong&gt;。启动时生成，并持久化在配置文件中，一般不会改变。&lt;/p&gt;

&lt;p&gt;每个节点还维护集群中其他节点的信息，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;node id&lt;/li&gt;
  &lt;li&gt;ip &amp;amp; port&lt;/li&gt;
  &lt;li&gt;标签&lt;/li&gt;
  &lt;li&gt;master node id（如果节点是 slave）&lt;/li&gt;
  &lt;li&gt;最后一次被挂起的 ping 的发送时间 &amp;amp; 最后一次收到 pong 的时间&lt;/li&gt;
  &lt;li&gt;该节点的当前 &lt;strong&gt;configuration epoch&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;该节点维护的 hash slots&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-4-the-cluster-bus&quot;&gt;2-4 The Cluster bus&lt;/h2&gt;

&lt;p&gt;每个集群节点使用额外的 TCP 端口用于与集群中的其他节点交互；集群节点间的交互只使用 Cluster bus 及 Cluster bus 协议：一种二进制协议。&lt;/p&gt;

&lt;h2 id=&quot;2-5-cluster-topology&quot;&gt;2-5 Cluster topology&lt;/h2&gt;

&lt;p&gt;Redis Cluster 是全网拓扑，&lt;strong&gt;每个节点都与其他节点维护 TCP 连接&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;N 个节点的集群中，每个节点有 N-1 个传出 TCP 连接，同时有 N-1 个传入 TCP 连接&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;集群节点间使用 &lt;strong&gt;Gossip 协议&lt;/strong&gt;和&lt;strong&gt;配置更新机制&lt;/strong&gt;来避免正常情况下节点间交互过多的消息。&lt;/p&gt;

&lt;h2 id=&quot;2-6-nodes-handshake&quot;&gt;2-6 Nodes handshake&lt;/h2&gt;

&lt;p&gt;对于 Cluster bus port 连接，节点总是接受并回复 ping 请求，即使该 ping 请求来自一个不可信任的节点。但是如果发送节点被认为不是集群的一部分，那么该节点的其他数据包都会被丢弃。&lt;/p&gt;

&lt;p&gt;通过两种方式可以判断一个节点是不是集群节点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;节点出现在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEET&lt;/code&gt; 消息中&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEET&lt;/code&gt; 消息会强制接收者接受一个节点作为集群的一部分&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;CLUSTER&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;节点出现在一个被信任的节点的 Gossip 消息中&lt;/strong&gt;：A 节点是被信任的集群节点，B 出现在 A 的Gossip 消息中，那么 C 收到 A 的消息后也会把 B 标记为集群节点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一旦我们将某个节点加入了连接图中，那么最终所有节点会自动形成一张全连接图（fully connected graph），即&lt;strong&gt;集群可以自动发现其他节点&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该机制使得集群更加健壮，可以防止不同的 Cluster 在 IP 地址变更或者其他网络相关事件导致意外混合&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h1 id=&quot;3-redirection-and-resharding&quot;&gt;3-Redirection and resharding&lt;/h1&gt;

&lt;p&gt;Redis Client 可以向集群中的任意节点发送查询请求，包括 slave 节点。&lt;/p&gt;

&lt;p&gt;收到请求的集群节点会分析该查询请求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果请求是可以接受的，则会判断 key 所属的 hash slot 及对应的节点&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;可以接受的请求是指：a. 请求中只包含一个 key；b. 多个 key 同属一个 hash slot&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;如果目标 hash slot 被当前节点管理，则直接处理请求&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;否则，当前节点回复一个 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 异常：&lt;/strong&gt;&lt;em&gt;异常包含了 key 所属的 hash slot 及管理该 hash slot 的节点（IP + Port）&lt;/em&gt;。&lt;/p&gt;

    &lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-MOVED&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3999&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;127.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6381&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Client 收到重定向的回复之后，需要向指定的 IP + Port 重新补发查询请求。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果在补发请求之前，集群配置再次发生了变化，导致刚才的节点不再管理对应的 hash slot，那么也会返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 异常，Client 仍需要再次补发请求&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 异常，Client 除了重新补发，还&lt;strong&gt;需要缓存 hash slot 与集群节点的映射关系&lt;/strong&gt;，以提高之后请求的效率。不过，该策略不是强制的，Client 还可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLUSTER NODES&lt;/code&gt; 命令&lt;strong&gt;全量刷新 hash slot 与集群节点的映射关系并缓存&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当 Cluster 处于稳定状态时，所有的 Client 最终都可以维护 hash slot → cluster nodes 的映射关系，减少重定向的概率，提升集群处理的效率。&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 重定向，Client 需要能够处理 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt; 重定向。&lt;/p&gt;

&lt;h2 id=&quot;3-2-cluster-live-reconfiguration&quot;&gt;3-2 Cluster live reconfiguration&lt;/h2&gt;

&lt;p&gt;为了支持 Cluster 动态重新配置，需要实现 &lt;strong&gt;hash slot 在集群节点间迁移能力&lt;/strong&gt;。slot 迁移的场景有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;添加节点：需要将一些已经存在 hash slot 集合迁移到新节点上&lt;/li&gt;
  &lt;li&gt;删除节点：将被删除节点上的所有 hash slot 集合转移到其他节点&lt;/li&gt;
  &lt;li&gt;集群 rebalance：将给定的 hash slot 集合在节点间移动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;hash slot 迁移的核心是分布在该 slot 上的 key 集合迁移&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下面是一些 slot 迁移的命令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER ADDSLOTS slot1 [slot2] … [slotN]&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER DELSLOTS slot1 [slot2] … [slotN]&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER SETSLOT slot NODE node&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER SETSLOT slot MIGRATING node&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER SETSLOT slot IMPORTING node&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADDSLOTS&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELSLOTS&lt;/code&gt;只是用来简单地在 Redis Cluster 节点上分配或移除 slot。&lt;strong&gt;在分配了 hash slots 之后，节点会通过 Gossip 协议在集群中传播这些信息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SETSLOT slot NODE node&lt;/code&gt; 用来给特定的节点分配 slot。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLUSTER SETSLOT slot MIGRATING node&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLUSTER SETSLOT slot IMPORTING node&lt;/code&gt; 命令用于将 hash slot 从一个节点迁移到另一个节点。迁移过程总涉及到两个特殊的状态：&lt;strong&gt;MIGRATING&lt;/strong&gt; &amp;amp; &lt;strong&gt;IMPORTING&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当 hash slot 处于 &lt;strong&gt;MIGRATING&lt;/strong&gt; 状态时，如果某个查询请求的 key 在该 slot 中，则当前节点会处理该查询请求；否则，节点就会通过 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 命令重定向到迁移的目标节点&lt;/li&gt;
  &lt;li&gt;当 hash slot 处于 &lt;strong&gt;IMPORTING&lt;/strong&gt; 状态时，如果某个查询请求后紧跟着 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASKING&lt;/code&gt;&lt;/strong&gt; 命令，则该请求就会被执行；否则，该请求就会通过 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt;&lt;/strong&gt; 命令重定向到管理该 hash slot 的真正节点&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-2-1-migration-process&quot;&gt;3-2-1 Migration process&lt;/h3&gt;

&lt;p&gt;假设 Redis Cluster 中存在 A，B 两个节点，我们期望将 hash slot 8 从 A 迁移到 B，则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向 B 发送命令 &lt;em&gt;CLUSTER SETSLOT 8 IMPORTING A&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;向 A 发送命令 &lt;em&gt;CLUSTER SETSLOT 8 MIGRATING B&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有其他节点在收到一个对属于 hash slot 8 的 key 的查询时，仍然会继续将 Client 重定向到 A，会导致：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有对已经存在的 key 查询将会被 A 处理&lt;/li&gt;
  &lt;li&gt;所有在 A 上不存在的 key 都会被 B 处理，因为 A 会将其重定向到 B（&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt;）&lt;/li&gt;
  &lt;li&gt;将&lt;strong&gt;不会在 A 上创建新的 key&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 key 的迁移过程中，从 Client 的视角来看，同一个 key 只会存在 A or B 中。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-3-ask-redirection&quot;&gt;3-3 ASK redirection&lt;/h2&gt;

&lt;p&gt;在 slot 迁移过程中，使用的是 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 命令进行重定向，为什么不使用 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt;&lt;/strong&gt; 命令进行重定向？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;**MOVED**&lt;/code&gt; 表明&lt;strong&gt;目标 hash slot 永久地被一个不同的节点所管理&lt;/strong&gt;，并且以后的请求也应该继续指向该节点；而 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 表明&lt;strong&gt;只是下次查询需要发送给另一个特定节点&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们期望 Client 总是&lt;strong&gt;先尝试访问 A，然后在有必要的时候再访问 B&lt;/strong&gt;。因为同一个 hash slot 中有很多 key，可能某次查询的 key 已经不在 A 上了，需要再次重定向到 B 查询；但是可能下次查询的 key 仍然在 A 上。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 重定向只发生在 hash slot 迁移过程中，对 Cluster 的影响可以接受&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASKING&lt;/code&gt; 命令会为 client 设置一个&lt;strong&gt;单次标签(one-time flag)&lt;/strong&gt;，以允许该 client 可以访问处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;**IMPORTING**&lt;/code&gt; 状态的 slot 一次。&lt;/p&gt;

&lt;p&gt;从 client 的视角来看，当收到 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 重定向命令之后：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;仅仅将这条查询重定向到指定的新节点，&lt;strong&gt;之后的命令还是继续发送给老的节点&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;重定向查询必须以一条&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASKING&lt;/code&gt;命令开始&lt;/li&gt;
  &lt;li&gt;暂时不要在本地将 hash slot 8 映射为节点 B&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当 hash slot 8 迁移完成之后，A 会返回一个 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt;&lt;/strong&gt; 重定向命令，client 需要在本地更新 hash slot 8 的映射节点为 B。&lt;/p&gt;

&lt;h2 id=&quot;3-4-clients-first-connection-and-handling-of-redirections&quot;&gt;3-4 Clients first connection and handling of redirections&lt;/h2&gt;

&lt;p&gt;Redis Cluster 的 Client 如果不将 hash slots → cluster nodes 的映射关系缓存在本地，那么每次查询都需要根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 重定向找到正确的节点，效率会很低。为了提高查询效率，Client 需要将 slots → nodes 的映射缓存在本地，但是该缓存并不总是最新的。&lt;/p&gt;

&lt;p&gt;在以下两个场景中 Client 需要获取全量的 hash slots → cluster nodes 的映射关系：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;启动阶段初始化 slots 配置信息&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;收到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 的重定向信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Client 在收到 MOVED 重定向时，通常会有多个 slots 发生了变动（比如 slave 晋升，该节点的 slots 会重新映射），此时 Client 全量更新 slots 会使问题处理起来比较简单&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-5-multiple-keys-operations&quot;&gt;3-5 Multiple keys operations&lt;/h2&gt;

&lt;p&gt;通过使用 hash tags 可以对多个 key 进行操作。&lt;/p&gt;

&lt;p&gt;不过，在 resharding 期间，多个 key 操作可能会不可用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果这些 key 在同一个节点上，则可以继续可用&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果这些 key 在不同的节点上，则不可用&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;请求的多 key 所属的 slot 在迁移过程中，这些 &lt;strong&gt;key 可能同时分布在源节点与目标节点&lt;/strong&gt;上&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-6-scaling-reads-using-replica-nodes&quot;&gt;3-6 Scaling reads using replica nodes&lt;/h2&gt;

&lt;p&gt;slave 节点默认不可读，&lt;strong&gt;所有对 slave 节点的读请求都会被重定向到 master 节点&lt;/strong&gt;（返回 MOVED 异常）。不过可以通过 READONLY 命令将 slave 节点设置为可读。&lt;/p&gt;

&lt;h1 id=&quot;4-fault-tolerance&quot;&gt;4-Fault Tolerance&lt;/h1&gt;

&lt;h2 id=&quot;4-1-heartbeat-and-gossip-messages&quot;&gt;4-1 Heartbeat and gossip messages&lt;/h2&gt;

&lt;p&gt;Redis Cluster 存在两种&lt;strong&gt;心跳包（heartbeat packets）&lt;/strong&gt;，分别称为 &lt;strong&gt;ping&lt;/strong&gt; 包 &amp;amp; &lt;strong&gt;pong&lt;/strong&gt; 包。这两种心跳包结构相同，并且都会携带重要的配置信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当节点收到 ping 包时，总会回复一个 pong 包&lt;/li&gt;
  &lt;li&gt;有时节点为了尽快将自身的配置信息发送出去，会直接向其他节点发送 pong 包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个节点会随机挑选一些节点并发送一些 ping 包（&lt;strong&gt;Gossip 协议&lt;/strong&gt;），每个节点在指定时间范围内发送的 ping 包与接收到的 pong 包是一个常数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;会主动对 &lt;em&gt;NODE_TIMEOUT/2 时间内没有发送过 ping 或者从其接收到 pong&lt;/em&gt; 的节点发送 ping 包&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;4-2-heartbeat-packet-content&quot;&gt;4-2 Heartbeat packet content&lt;/h2&gt;

&lt;p&gt;ping &amp;amp; pong 包的内容包含两部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;包头（header）&lt;/strong&gt;：该部分不仅可以用于 ping &amp;amp; pong 消息，也可以用于其他类型消息（如重新选举消息）&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;内容&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Node ID&lt;/td&gt;
          &lt;td&gt;节点创建时生成，并在 Redis Cluster 生命周期内保持不变&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;currentEpoch &amp;amp; configEpoch&lt;/td&gt;
          &lt;td&gt;由 Redis Cluster 用来加载分布式算法；如果发送者是 slave 节点，则 configEpoch 就是其 master 的 configEpoch&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;node flags&lt;/td&gt;
          &lt;td&gt;表明发送者是 slave 还是 master；同时包含一些其他信息&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;hash slots 的 bitmap&lt;/td&gt;
          &lt;td&gt;如果发送者是 slave，则表示其 master 的 hash slots 的 bitmap&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TCP Port&lt;/td&gt;
          &lt;td&gt;用于接受命令的普通端口（+10000 表示 Redis Cluster Bus 端口）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Cluster state&lt;/td&gt;
          &lt;td&gt;发送者视角下的集群状态（down or ok）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;master Node ID&lt;/td&gt;
          &lt;td&gt;master 节点的 Node ID（如果发送者是 slave）&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Gossip section&lt;/strong&gt;：仅存在 ping &amp;amp; pong 中；包含&lt;strong&gt;&lt;em&gt;发送者视角下集群中其他节点状态，用于故障检测 &amp;amp; 节点发现&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;内容&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Redis Cluster 中其他节点信息&lt;/td&gt;
          &lt;td&gt;包含 Node ID, IP, Port, Node flags(FAIL, PFAIL)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Gossip section 段中包含的节点数与集群大小成正比&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-3-failure-detection&quot;&gt;4-3 Failure detection&lt;/h2&gt;

&lt;p&gt;Redis Cluster 故障检测机制用来&lt;strong&gt;识别一个 master or slave 节点对集群中大部分 master 节点是否是可达的（reachable）&lt;/strong&gt;。如果一个 master 节点不可达，则会将其一个 slave 节点晋升为 master；&lt;strong&gt;&lt;em&gt;如果无法将 slave 晋升为 master，则集群会被置为 error 状态，并停止接受客户端的请求&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;选举过程需要 master 节点参与&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如何定义不可达？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个已经发送出去，但是没有接收到对方回复的 ping 被称为活跃 ping（active ping）。如果一个活跃 ping 挂起时间超过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT&lt;/code&gt;，则认为接收方不可达。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT&lt;/code&gt; 必须大于正常的网络往返时间。为了增加可靠性，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT/2&lt;/code&gt; 时间过后如果还没收到回复，会尝试联系其他节点，确保自身连接的活跃性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-3-1-pfail--fail&quot;&gt;4-3-1 PFAIL &amp;amp; FAIL&lt;/h3&gt;

&lt;p&gt;Redis Cluster 每个节点都会保存其他节点的一些 flags 信息，其中有两个 flag 用于&lt;strong&gt;故障检测：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL &amp;amp; PFAIL&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; flag (possible fail)&lt;/p&gt;

    &lt;p&gt;可能故障，是一个不需要确认的故障类型。&lt;/p&gt;

    &lt;p&gt;当节点发现某个节点失联超过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT&lt;/code&gt; 时，会在本地将其标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;检测节点与被检测节点都可以是 master 或者 slave&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag（fail）&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; 只是每个节点针对其他节点状态的本地信息，不能以此来判断是否进行选举。为了确认节点确实不可达了，需要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; 升级为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-2-pfail--fail&quot;&gt;4-3-2 PFAIL → FAIL&lt;/h3&gt;

&lt;p&gt;每个 Gossip 消息中都会包含当前节点已知的一部分其他节点的状态（是否 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt;），节点之间会交换自己已知信息；将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; 升级为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;的流程为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点 A 检测到 B 节点不可达，将其标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;节点 A 通过 Gossip 消息收集大部分 master 节点对 B 节点状态标记的 flag&lt;/li&gt;
  &lt;li&gt;多数 master 节点在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间范围内将 B 标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A 将 B 标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A &lt;strong&gt;发送一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 消息给所有可达节点&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FAIL 消息会强制所有接收到消息的节点将不可达节点 B 标记为 FAIL&lt;/strong&gt;，而不管自己当前是否已经将 B 标记为 PFAIL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag 是单向（one way）的：只能 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; → &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;。不过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag 可以在以下情况中被清除：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;节点重新可达，并且该节点是 slave&lt;/strong&gt;：因为 slave 节点不会发生故障转移（failover）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;节点重新可达，并且没有管理任何 hash slots 的 master 节点&lt;/strong&gt;：这种节点实际上没有参与集群管理，需要等待被配置后加入集群&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;节点重新可达，且为 master 节点，同时在较长时间内（N * NODE_TIMEOUT）没有检测到有 slave 节点晋升&lt;/strong&gt;：此时最好将其作为 master 节点重新加入集群&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL → FAIL&lt;/code&gt; 的转换过程使用了&lt;strong&gt;弱一致性&lt;/strong&gt;（weak agreement）:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;节点在一段时间内收集其他 master 节点的视图，即使多数 master 达成一致，也只能说明在不同的时间，不同的节点达成一致，无法确定在什么时刻获得了多数 master 的一致结果。不过，过期的结果会被抛弃掉（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; ），所以&lt;strong&gt;可以确定多数 master 节点一定是在某个时间窗口内达成一致&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 消息虽然可以强制其他节点接受该判断结果，但是无法保证消息被所有节点接收到：如出现了网络分区&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-3-conner-case&quot;&gt;4-3-3 Conner case&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Redis Cluster 所有节点最终会对一个给定的节点状态达成一致&lt;/strong&gt;。两个由于集群脑裂引起的场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果多数派 master 将一个节点标记为 FAIL，那么所有其他节点最终也会将该 master 标记为 FAIL：在指定的时间窗口内，集群中会有足够多的失败报告&lt;/li&gt;
  &lt;li&gt;如果少数派 master 节点将一个节点标记为 FAIL，并不会发生 failover，最终该 FAIL 状态会被清除：在 N*NODE_TIMEOUT 内没有晋升&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-4-moreover&quot;&gt;4-3-4 Moreover&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag 只是一种触发机制，用于触发执行 slave 晋升操作。slave 也可以在发现 master 不可达之后主动启动晋升操作，并尝试获得多数 master 节点的同意。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 机制虽然有些复杂，但是可以使得集群意识到自己处于一个 error 状态，从而拒绝写操作；而且可以减少由于 slave 自身问题触发错误的选举尝试。&lt;/p&gt;

&lt;h1 id=&quot;5-configuration-handling-propagation-and-failovers&quot;&gt;5-Configuration handling, propagation, and failovers&lt;/h1&gt;

&lt;h2 id=&quot;5-1-cluster-current-epoch&quot;&gt;5-1 Cluster current epoch&lt;/h2&gt;

&lt;p&gt;Redis Cluster 使用类似 Raft 算法中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;term&lt;/code&gt; 的概念，被称为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;相当于集群的逻辑时钟，为事件提供递增的版本号&lt;/strong&gt;。当多个节点的信息冲突时，可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 判断哪个信息是最新的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 是一个 64 位无符号整数，用于标识集群 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;；所有节点中最大的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 即为集群  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;节点创建时，所有 Redis Cluster 节点（master or slave）都将自己的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 设置为 0。当从其他节点收到消息时，如果发送方的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 大于当前节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;，则&lt;strong&gt;将自身的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 更新为发送方的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;&lt;/strong&gt;。这样，最终所有节点都会与拥有最大 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 的节点保持一致。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 被设计用于，&lt;em&gt;当集群状态变化时，某个节点请求其他节点的同意来执行一些操作&lt;/em&gt;（如 slave → master）；拥有较大 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 的节点总能获得相对较小节点的同意。&lt;/p&gt;

&lt;h2 id=&quot;5-2-configuration-epoch&quot;&gt;5-2 Configuration epoch&lt;/h2&gt;

&lt;p&gt;当 master 节点被创建时，其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 被置为 0。新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 将会在 slave 晋升为 master 之后被创建。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 由 master 节点创建，在 failover 时产生一个新的，递增唯一值&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在 Redis Cluster 处于稳定状态时，slave 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 为其与 master 节点交互时从 master 节点获取的（与 master 保持一致，不过可能会有所延迟）。&lt;/p&gt;

&lt;p&gt;master 与 slave 节点交互时都会携带自己的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt;，并且会广播给集群中其他节点。当某些节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 发生变化时，收到该消息的节点会将最新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 持久化到各自的本地配置文件中。&lt;/p&gt;

&lt;h2 id=&quot;5-3-replica-election-and-promotion&quot;&gt;5-3 Replica election and promotion&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;选举 &amp;amp; 晋升总是由 slave 节点发起与处理&lt;/strong&gt;，master 节点在选举过程中参与投票。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;选举的条件？
    &lt;ol&gt;
      &lt;li&gt;master 处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 状态&lt;/li&gt;
      &lt;li&gt;master 至少管理一个 hash slot&lt;/li&gt;
      &lt;li&gt;slave 与 master 的复制链接断开时间少于给定值：用于确保晋升的 slave 数据尽可能新&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;什么时候触发选举？
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;当 master 在至少一个 slave 视图中处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 状态时，且 slave 要求晋升为 master，就会触发选举流程&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;多个 slave 都可以发起选举流程，但是只有一个 slave 能赢得选举&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;选举流程？
    &lt;ol&gt;
      &lt;li&gt;slave 增加自己的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;slave 向集群所有 master 节点广播 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_REQUEST&lt;/code&gt; 包请求选票，并且在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间内等待所有 master 节点的回复&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;master 收到投票请求后，如果准备将选票投给对应的 slave，则回复 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_ACK&lt;/code&gt;，并且在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间内不能给其他 slave 进行投票&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;避免多个 slave 赢得选票&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;slave 抛弃那些 epoch 比自己发送选票请求时的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 小的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_ACK&lt;/code&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;避免计算上一次选举的选票&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;如果 slave 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间内赢得了大部分 master 节点的选票，则其赢得选举；否则将会在  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 4&lt;/code&gt; 时间后再次尝试&lt;/li&gt;
      &lt;li&gt;slave 赢得选举后会新增 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt;，该 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 会比其他 master 节点更大。随后会在 ping &amp;amp; pong 中广播该 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch.&lt;/code&gt;为了加速配置更新，新 master 会向其他节点直接发送 pong 包&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-4-masters-reply-to-replica-vote-request&quot;&gt;5-4 Masters reply to replica vote request&lt;/h2&gt;

&lt;p&gt;在选举过程中，master 需要为接收到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_REQUEST&lt;/code&gt; 请求进行投票，投票的条件为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;master 只会对每个 epoch 投票一次，并且拒绝比上次投票更小的 epoch 请求&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lastVoteEpoch&lt;/code&gt; 保存在 master 节点本地&lt;/li&gt;
  &lt;li&gt;请求的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 如果小于当前 master  的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt;，则会被忽略&lt;/li&gt;
  &lt;li&gt;请求的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 如果小于其所属 master 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt;，则也会被忽略。由于 slave 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 从其 master 获取，这种情况说明 slave 并不是比较新的&lt;/li&gt;
  &lt;li&gt;salve 所属的 master 被当前 master 标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-5-hash-slots-configuration-propagation&quot;&gt;5-5 Hash slots configuration propagation&lt;/h2&gt;

&lt;p&gt;Redis Cluster 提供一种机制，用于在集群中传播每个节点管理的 hash slot 配置信息。&lt;/p&gt;

&lt;p&gt;有两种传播 hash slot 配置信息的方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;心跳包：ping &amp;amp; pong 消息的发送方总会携带自己或者其 master 管理的 hash slot 信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息：心跳包的接收方如果发现发送方的消息过期，则会回复 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息，&lt;strong&gt;强制对方更新其过期信息&lt;/strong&gt;。（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息中包含了最新的配置信息）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当新的 Redis Cluster 节点创建时，其本地 hash slots 映射表初始化为 NULL，基本如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;16383&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;hash slots 配置的传播规则如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果在 A 节点的本地一个 hash slot 没有被分配（NULL），此时有 B 节点声明了该 slot，则修改 A 本地的 hash slot 映射关系将该 slot 绑定为 B&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 A 节点中一个 hash slot 已经被 C 分配，此时 B 的广播消息中的 configEpoch 比 C 节点的 configEpoch 大，则将该 hash slot 绑定为 B&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;最终所有节点一定会通过节点间的消息广播就 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 最大的节点获得 slot 的管理权达成一致；这一机制被称为 &lt;strong&gt;last failover wins(最后故障转移者胜)&lt;/strong&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于以上规则，当一个过期的节点收到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息时，会根据最新消息更新自己的配置。&lt;/p&gt;

&lt;p&gt;当一个 master 节点在分区后重新加入集群时，会将自己从属于新的 master 节点，并更新自身配置。&lt;/p&gt;

&lt;h2 id=&quot;5-6-replica-migration&quot;&gt;5-6 Replica migration&lt;/h2&gt;

&lt;p&gt;备份迁移是一种 slave 自动重配的过程，用来将备份节点迁移到当前已经没有可用 slave 的 master上，提高集群可用性。&lt;/p&gt;

&lt;p&gt;假设 A 只有一个 slave A，可能的迁移场景为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A发生故障，A1 被晋升。&lt;/li&gt;
  &lt;li&gt;C2 迁移为 A1 的 slave，否则 A1 将会没有任何 slave&lt;/li&gt;
  &lt;li&gt;一段时间后 A1 也发生了故障&lt;/li&gt;
  &lt;li&gt;C2 被晋升为新的 master 以替代 A1&lt;/li&gt;
  &lt;li&gt;此时，集群还能正常提供服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-appendix&quot;&gt;6-Appendix&lt;/h1&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://redis.io/topics/cluster-spec&quot;&gt;https://redis.io/topics/cluster-spec&lt;/a&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">1-Main properties and rationales of the design</summary></entry><entry><title type="html">同位语从句</title><link href="http://localhost:4000/appositive-clause.html" rel="alternate" type="text/html" title="同位语从句" /><published>2022-02-13T00:00:00+08:00</published><updated>2022-02-13T00:00:00+08:00</updated><id>http://localhost:4000/appositive-clause</id><content type="html" xml:base="http://localhost:4000/appositive-clause.html">&lt;h2 id=&quot;1-同位语&quot;&gt;1-同位语&lt;/h2&gt;

&lt;p&gt;一个名词（或其它形式）&lt;strong&gt;&lt;em&gt;对另一个名词或代词进行解释或补充说明&lt;/em&gt;&lt;/strong&gt;，这个名词（或其它形式）就是同位语。&lt;/p&gt;

&lt;p&gt;同位语与被它限定的词的格式要一致，并常常紧挨在一起。同位语除表示其同位成分的全部意义外，还可以表示部分意义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mr. Smith, our new teacher, is very kind to us.&lt;/li&gt;
  &lt;li&gt;He told me that his brother John was a world-famous doctor.(John 是 brother 的同位语)&lt;/li&gt;
  &lt;li&gt;Yesterday I talked to my English teacher, Mr. James.&lt;/li&gt;
  &lt;li&gt;We Chinese people are brave and hard-working.(Chinese people 是 we 的同位语)&lt;/li&gt;
  &lt;li&gt;He is interested in sports, especially ball games.(ball games 是 sports 的同位语)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-同位语从句&quot;&gt;2-同位语从句&lt;/h2&gt;

&lt;p&gt;同位语从句指的是在复合句中充当同位语的从句，属于名词性从句的范畴。&lt;/p&gt;

&lt;p&gt;同位语从句用来&lt;em&gt;对其前面的抽象名词进行解释说明&lt;/em&gt;，被解释说明的词和同位语在逻辑上是&lt;strong&gt;主表关系&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2-1-先行词&quot;&gt;2-1 先行词&lt;/h3&gt;

&lt;p&gt;可以连接同位语从句的名词有：&lt;strong&gt;news，idea，fact，promise，question，doubt，thought，hope，message，suggestion，words(消息)，possibility, decision&lt;/strong&gt; 等(一般的”抽象”名词)。&lt;/p&gt;

&lt;h3 id=&quot;2-2-引导词&quot;&gt;2-2 引导词&lt;/h3&gt;

&lt;p&gt;引导同位语从句的词语通常有连词 that, whethe, 连接代词和连接副词等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;that 连接从句时，&lt;strong&gt;从句为一个句意完整的陈述句&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;that 不能省略，没有具体的含义，&lt;strong&gt;&lt;em&gt;不充当句子成分，只起连接作用&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The idea &lt;em&gt;that you can do this work well without thinking&lt;/em&gt; is quite wrong.(that 引导的从句作 idea 的同位语)&lt;/li&gt;
      &lt;li&gt;We heard the news &lt;em&gt;that our team had won&lt;/em&gt;.(news 的同位语)&lt;/li&gt;
      &lt;li&gt;They were worried over the fact &lt;em&gt;that you were sick&lt;/em&gt;.(fact 的同位语)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;在某些名词(如 &lt;strong&gt;demand, wish, suggestion, resolution&lt;/strong&gt;等) 后面的同位语从句要&lt;strong&gt;用虚拟语气&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;There was a suggestion &lt;em&gt;that Brown should be dropped from the team&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;引导同位语从句的连词 that 通常不省略，但在&lt;em&gt;非正式文体中也可以省去&lt;/em&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He grabbed his suitcase and gave the impression &lt;em&gt;he was boarding the Tokyo plane&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;whether 引导同位语从句&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;if 不能引导同位语从句&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;There is some doubt &lt;em&gt;whether he will come&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;Answer my question &lt;em&gt;whether you are coming&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;The question &lt;em&gt;whether it is right or wrong&lt;/em&gt; depends on the result.&lt;/li&gt;
      &lt;li&gt;We are not investigating the question &lt;em&gt;whether he is trustworthy&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接代词 what, who, whom, whose 引导同位语从句
    &lt;ul&gt;
      &lt;li&gt;I have no idea &lt;em&gt;what size shoes she wears&lt;/em&gt;.(what 作 size 的定语)&lt;/li&gt;
      &lt;li&gt;The question &lt;em&gt;who will take his place&lt;/em&gt; is still not clear.(who 作同位语从句的主语)&lt;/li&gt;
      &lt;li&gt;Have you any idea &lt;em&gt;what time it starts&lt;/em&gt;?&lt;/li&gt;
      &lt;li&gt;I have no idea &lt;em&gt;who can really understand my complicated mind&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接副词 where, when, why, how 引导同位语从句
    &lt;ul&gt;
      &lt;li&gt;I have no idea &lt;em&gt;when he will come back&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;It is a question &lt;em&gt;how he does it&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;He had no idea &lt;em&gt;why she left&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;You have no idea &lt;em&gt;how worried I was&lt;/em&gt;!&lt;/li&gt;
      &lt;li&gt;We haven’t yet settled the question &lt;em&gt;where we are going to spend our summer vacation&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-同位语</summary></entry><entry><title type="html">Redis Cluster Tutorial</title><link href="http://localhost:4000/redis-cluster-tutorial.html" rel="alternate" type="text/html" title="Redis Cluster Tutorial" /><published>2022-02-13T00:00:00+08:00</published><updated>2022-02-13T00:00:00+08:00</updated><id>http://localhost:4000/redis-cluster-tutorial</id><content type="html" xml:base="http://localhost:4000/redis-cluster-tutorial.html">&lt;h2 id=&quot;1-introduction&quot;&gt;1-Introduction&lt;/h2&gt;

&lt;p&gt;Redis Cluster 支持&lt;strong&gt;数据自动在多个 Redis 节点间分片&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通过 Redis Cluster，能够实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;自动切分数据集到多个节点&lt;/strong&gt;（Sharding）&lt;/li&gt;
  &lt;li&gt;当部分节点故障或不可达的情况下，Redis Cluster 能够继续提供服务（High Availability）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Redis Cluster 提供&lt;strong&gt;&lt;em&gt;一定程度的高可用&lt;/em&gt;&lt;/strong&gt;，当某些节点失败或者不能访问的情况下能够继续提供服务。但是当大量节点失败的情况下集群也会停止服务（例如大多数主节点不可用）。&lt;/p&gt;

&lt;h2 id=&quot;2-tcp-ports&quot;&gt;2-TCP Ports&lt;/h2&gt;

&lt;p&gt;每个 Redis Cluster 节点需要打开两个 TCP 端口用于不同的连接。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;端口 &lt;strong&gt;6379&lt;/strong&gt;：用于提供&lt;strong&gt;客户端连接&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;该端口需要开放给所有与集群交互的客户端；同时，也要开放给集群中的其他节点用于 keys 迁移&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;端口 &lt;strong&gt;16379&lt;/strong&gt;：用于&lt;strong&gt;集群总线&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;该端口需要开放给集群中的其他节点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;客户端只能连接 6379，而不能连接 16739；而集群中的节点可以访问 6379 与 16739 两个端口&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;集群总线用于集群节点之间访问，使用&lt;em&gt;二进制协议&lt;/em&gt;，主要用于&lt;strong&gt;失败检测、配置升级、故障转移授权&lt;/strong&gt;等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;二进制协议更适合节点间使用小的带宽和处理时间来交换数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;3-data-sharding&quot;&gt;3-Data Sharding&lt;/h2&gt;

&lt;p&gt;Redis Cluster 的&lt;strong&gt;数据分片&lt;/strong&gt;不是使用一致性 Hash，而是使用一种 &lt;strong&gt;Hash Slot（哈希槽&lt;/strong&gt;）的形式。&lt;/p&gt;

&lt;p&gt;Redis Cluster 中共有 16384 个 Slot，如何决定每个 key 分配到哪个槽呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Slot_Index = &lt;strong&gt;CRC16(key) % 16384&lt;/strong&gt; 计算 Slot 索引&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cluster 中的每个节点负责一部分 Hash Slot，比如集群中有３个节点，则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A 存储的范围：0 ~ 5500&lt;/li&gt;
  &lt;li&gt;Ｂ存储的范围：5501 ~ 11000&lt;/li&gt;
  &lt;li&gt;Ｃ存储的范围：11001 ~ 16384&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种分配方式便于集群节点的新增与剔除。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新增一个节点Ｄ：需要把Ａ、Ｂ、Ｃ中的部分 Hash Slot 数据移到 Ｄ 节点&lt;/li&gt;
  &lt;li&gt;删除 Ａ 节点：需要把 Ａ 节点的 Hash Slot 的数据移到 Ｂ 和 Ｃ 节点；当 Ａ 节点的数据全部被移走后，Ａ 节点就可以完全从集群中删除&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Slot 在不同节点之间的迁移不需要暂停服务&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过 Hash Tag 的概念，Redis Cluster 可以通过一个命令（或事务, 或 lua 脚本）同时操作多个 key。&lt;/p&gt;

&lt;p&gt;Hash Tag 可以使得&lt;strong&gt;相同 Tag 的不同 key 被分配到同一个 Slot&lt;/strong&gt; 。如：key_1 = “this{foo}”, key_2 = “another{foo}”，这两个 key 的 tag 均为 foo，会被分配到同一个 Slot 中，所以可以在一个命令中操作它们。&lt;/p&gt;

&lt;h2 id=&quot;4-master-replica-model&quot;&gt;4-Master-Replica Model&lt;/h2&gt;

&lt;p&gt;为了提高 Cluster 的可用性，保证在部分节点故障或网络不通时 Cluster 依然能正常工作，Redis Cluster 使用了主从模型：&lt;strong&gt;&lt;em&gt;每个 Hash Slot 有 1（主节点）到 N 个副本（ N-1 个从节点&lt;/em&gt;&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;在上面的例子中，A, B, C 设为主节点，A1, B1, C1 分别为其从节点。如果 B 不可用，则会将 B1 提升为主节点，从而保证集群能够继续提供服务；但是如果 B1 同时也不可用了，则集群就不能继续工作了。&lt;/p&gt;

&lt;h2 id=&quot;5-consistency-guarantees&quot;&gt;5-Consistency Guarantees&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Redis Cluster 不能保证强一致性&lt;/strong&gt;：一些已经向 Client 确认写成功的操作，会在某些不确定的情况下丢失。&lt;/p&gt;

&lt;p&gt;无法保证强一致性的原因有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;主从节点之间使用了异步的方式来同步数据&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;网络分区期间可能导致的写操作数据丢失&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当 Client 向主节点 B 节点提交一个写操作后，主节点 B 将数据保存在本地并回复给 Client 操作成功 ，之后 B 异步地将刚才写操作的变更复制到从节点  B1, B2, B3。&lt;/p&gt;

&lt;p&gt;由于是异步复制，所以在 B 响应 Client 之后，并且同步给从节点之前，主节点 Ｂ 故障了，其中一个没有收到该写操作的从节点会晋升成主节点，该写操作就这样永远丢失了。&lt;/p&gt;

&lt;p&gt;为了提高一致性，可以考虑使用同步复制，不过会使得性能降低。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;在性能和一致性之间，需要一个权衡&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Redis Cluster 支持同步复制，通过 WAIT 命令实现，可以让数据丢失的概率降低。但是&lt;strong&gt;&lt;em&gt;即使使用了同步复制，Redis Cluster 仍不是强一致性的&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;考虑一种网络分区的情况：集群中存在主节点 A, B, C，从节点 A1, B1, C1，客户端 Z1，其中 Z1 与 B 可以网络互通，A, A1, B1, C, C1 之间网络互通，但是与 Z1, B 网络不通（一共两个网络分区）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Z1 可以继续向 B 发起写操作，Ｂ 也接受 Z1 的写操作&lt;/li&gt;
  &lt;li&gt;当网络恢复时，如果这个时间间隔足够短，集群仍然能继续正常工作&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果时间比较长，以至于 &lt;strong&gt;&lt;em&gt;B1 在大多数的这边被重新选为主节点&lt;/em&gt;&lt;/strong&gt;，那么刚才 Z1 发给 Ｂ 的写操作都将丢失&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Z1 给 Ｂ 发送写操作是有一个限制的，如果时间长度达到了大多数节点那边可以选出一个新的主节点时，少数这边的所有主节点都不接受写操作&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如何评断网络分区的时间是长还是短？&lt;/p&gt;

&lt;p&gt;Redis Cluster 中存在一个&lt;strong&gt;节点超时配置&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当达到了这个节点超时的时间之后，主节点被认为已经宕机，可以用它的一个从节点来代替&lt;/li&gt;
  &lt;li&gt;同样，在节点超时时，如果主节点依然不能联系到其他主节点，它将&lt;em&gt;进入错误状态，不再接受写操作&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-appendix&quot;&gt;6-Appendix&lt;/h2&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;https://redis.io/topics/cluster-tutorial#:~:text=Redis%20Cluster%20provides%20a%20way,are%20not%20able%20to%20communicate&quot;&gt;redis-io&lt;/a&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">1-Introduction</summary></entry><entry><title type="html">定语从句</title><link href="http://localhost:4000/attributive-clause.html" rel="alternate" type="text/html" title="定语从句" /><published>2022-02-11T00:00:00+08:00</published><updated>2022-02-11T00:00:00+08:00</updated><id>http://localhost:4000/attributive-clause</id><content type="html" xml:base="http://localhost:4000/attributive-clause.html">&lt;h2 id=&quot;1-基本概念&quot;&gt;1-基本概念&lt;/h2&gt;

&lt;h3 id=&quot;1-1-定义&quot;&gt;1-1 定义&lt;/h3&gt;

&lt;p&gt;一个简单句跟在&lt;em&gt;名词或代词（先行词）后进行修饰限定&lt;/em&gt;，就叫做定语从句；定语从句在主句中充当定语成分。&lt;/p&gt;

&lt;p&gt;被定语从句修饰的词叫&lt;strong&gt;先行词&lt;/strong&gt;；定语从句通常只能放在被修饰的先行词之后。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;单词做定语放在被修饰词之前&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;1-2-引导词&quot;&gt;1-2 引导词&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;引导定语从句的词有：
    &lt;ul&gt;
      &lt;li&gt;关系代词：&lt;strong&gt;that, who, whom, which, as&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;关系副词：&lt;strong&gt;when, where, why&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;引导词位于定语从句之前，先行词之后（as 除外）。&lt;/li&gt;
  &lt;li&gt;引导词的作用有：
    &lt;ul&gt;
      &lt;li&gt;连接先行词和定语从句&lt;/li&gt;
      &lt;li&gt;在定语从句中充当一定的成分（&lt;strong&gt;&lt;em&gt;关系代词充当主语或宾语，关系副词充当状语&lt;/em&gt;&lt;/strong&gt;）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-关系代词的用法&quot;&gt;2-关系代词的用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;who/that&lt;/strong&gt; 指人，是主格；&lt;strong&gt;在定语从句中代替先行词，又作定语从句的主语，不能省略&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Do you know the gentleman who/that is sitting there？&lt;/li&gt;
      &lt;li&gt;The student who/that answered the question was John.&lt;/li&gt;
      &lt;li&gt;Nothing is difficult to the man who/that will try.&lt;/li&gt;
      &lt;li&gt;The windows was broken by the boy who/that lives opposite.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;whom/who/that&lt;/strong&gt; 指人，是宾格；&lt;strong&gt;在定语从句中代替先行词，又作定语从句的宾语(动宾或介宾)&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;当作&lt;strong&gt;动宾&lt;/strong&gt;（动词后接宾语）时，关系代词可省略
        &lt;ul&gt;
          &lt;li&gt;Do you know the gentleman (whom/who/that) we met just now？&lt;/li&gt;
          &lt;li&gt;The author (whom/who/that) you criticized.&lt;/li&gt;
          &lt;li&gt;Then I telephoned the doctor (whom/who/that) Charles had recommended.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;当作&lt;strong&gt;介宾&lt;/strong&gt;（介词后接宾语）时：&lt;em&gt;介词不提前，关系代词可省略；介词提前，关系代词不可省&lt;/em&gt;，即 “介词+whom” (指人时介词后的关系代词只能用whom)
        &lt;ul&gt;
          &lt;li&gt;The man (whom/who/that) I spoke with is my teacher.&lt;/li&gt;
          &lt;li&gt;The man with whom I spoke is my teacher.&lt;/li&gt;
          &lt;li&gt;The man with whom I traveled couldn’t speak English&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;固定的动词短语（动词+介词），如 look for, take care of 等不能把动词与介词拆开，即介词不能提至引导词前。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;She is the right girl (who/whom/that) we are looking for.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;whose&lt;/strong&gt; 是所有格 “…的” 形式；&lt;strong&gt;whose + n. 一起在定语从句中充当主语、宾语(&lt;/strong&gt;动宾或介宾)，即先行词的什么东西。&lt;/p&gt;

    &lt;p&gt;whose 用来指人或物（只用作定语) ，且 whose 不能省略。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;em&gt;whose + n. = the + n. + of which/whom&lt;/em&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;I didn’t find the desk whose leg was broken. (主语)&lt;/li&gt;
      &lt;li&gt;He is the student whose pencil I broke yesterday. (动宾)&lt;/li&gt;
      &lt;li&gt;The boss in whose company I work is very kind. (介宾)&lt;/li&gt;
      &lt;li&gt;They rushed over to help the man whose car had broken down. (主语)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;which/that&lt;/strong&gt; 指物，&lt;strong&gt;代替先行词，且在定语从句中作主语或宾语(动宾或介宾)&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;作主语
        &lt;ul&gt;
          &lt;li&gt;The house which/that was destroyed in the earthquake is weak.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;作宾语&lt;/p&gt;

        &lt;p&gt;which/that 作宾语时，同样分为动宾与介宾两种情况：1. 作动宾时，which/that 可以省略；2. 作介宾时，介词不提前时，关系代词 which/that 可以省略；介词提前时，关系代词 which/that 不可以省略。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;The pen (which/that) you found yesterday is mine.&lt;/li&gt;
          &lt;li&gt;The games (that/which) the young men competed in were difficult.&lt;/li&gt;
          &lt;li&gt;The games in which the young men competed were difficult.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;介词 + which 指物；介词 + whom 指人&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;as&lt;/strong&gt; 指人或物，在定语从句中可作主语，宾语，表语或状语，不能省略&lt;/p&gt;

    &lt;p&gt;主要用于 “&lt;strong&gt;the same …as…；such …as…；so …as…；as … as…；as follows&lt;/strong&gt; ” 固定结构中。在这种形式的结构中，要用 as 代替 who(m), which, 或 that 引导定语从句。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Such people as knew Hill thought he was honest.&lt;/li&gt;
      &lt;li&gt;Such people as Hill knew thought he was honest.&lt;/li&gt;
      &lt;li&gt;My hometown is no longer the same as it was.&lt;/li&gt;
      &lt;li&gt;Here is so big a stone as no one can lift.&lt;/li&gt;
      &lt;li&gt;The child knows as much as grow-ups (know).&lt;/li&gt;
      &lt;li&gt;I’d like to have the same books as are used in your school.&lt;/li&gt;
      &lt;li&gt;He is not such a person as I expected.&lt;/li&gt;
      &lt;li&gt;He will marry as pretty a girl as he can find.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-关系副词的用法&quot;&gt;3-关系副词的用法&lt;/h2&gt;

&lt;p&gt;关系副词，兼有副词与连接词两种作用，在&lt;strong&gt;不及物动词的连接中要求用关系副词&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;关系副词在句中作状语，关系副词=介词+关系代词，定语从句中常用的关系副词有三个：&lt;strong&gt;when，where，why&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;when = during/on/in which  where = in/at/on which  why = for which&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;when&lt;/strong&gt; 主要用于修饰表时间的名词，同时它在定语从句中用作&lt;strong&gt;时间状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;There comes a time when you have to make a choice.&lt;/li&gt;
      &lt;li&gt;Gone are the days when they could do what they liked.&lt;/li&gt;
      &lt;li&gt;We’ll put off the picnic until next week, when the weather may be better.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;先行词为时间名词时不一定用关系副词 when 来引导定语从句；需要进一步判断先行词在定语从句中成分。如果在定语从句中作时间状语，则用 when；如果在定语从句中作主语或者宾语时，要用 that, which 等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Don’t forget the time (that, which) I’ve told you.（先行词 time 作 told 的宾语）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;where&lt;/strong&gt; 主要用于修饰表地点的名词，同时它在定语从句中用作&lt;strong&gt;地点状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;This is the village where he was born.&lt;/li&gt;
      &lt;li&gt;That’s the hotel where we were staying last summer.&lt;/li&gt;
      &lt;li&gt;Barbary was working in Aubury, where she went daily in a bus.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;同样，先行词为地点的名词时，不一定要用 where 引导，需要进一步判断先行词在定语从句中的成分。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He works in a factory that/which makes TV sets.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;why&lt;/strong&gt; 主要用于修饰表原因的名词(主要是the reason)，同时它在定语从句中用作&lt;strong&gt;原因状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;We don’t know the reason why he didn’t show up.&lt;/li&gt;
      &lt;li&gt;She didn’t tell me the reason why she refused the offer.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;why 与 where/when 的用法有点不同：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;why 可以省略或者替换成 that&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;That’s one of the reasons (why, that) I asked you to come.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;why 只能引导限制性定语从句，where/when 可以引导非限制性定语从句
        &lt;ul&gt;
          &lt;li&gt;The main reason, why he lost his job, was that he drank. (wrong)&lt;/li&gt;
          &lt;li&gt;The main reason why he lost his job was that he drank. (right)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-限制性与非限制性定语从句的区别&quot;&gt;4-限制性与非限制性定语从句的区别&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在句中作用不同
    &lt;ul&gt;
      &lt;li&gt;限制性定语从句&lt;strong&gt;对&lt;/strong&gt;被修饰的&lt;strong&gt;先行词有限定制约作用&lt;/strong&gt;，使该词的含义更具体,更明确。&lt;strong&gt;限制性定语从句不能被省略&lt;/strong&gt;，否则句意就不完整。&lt;/li&gt;
      &lt;li&gt;非限制性定语从句&lt;strong&gt;与先行词关系不是十分密切&lt;/strong&gt;，只是对其作一些附加说明，不起限定制约作用。如果将非限制性定语从句省去，主句的意义仍然完整。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表现形式不同&lt;/p&gt;

    &lt;p&gt;限制性定语从句因与先行词关系密切，所以&lt;strong&gt;不可以用逗号将其与主句隔开&lt;/strong&gt;；非限制性定语从句与先行词关系不是十分密切，所以&lt;strong&gt;可用逗号将其与主句隔开。&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Do you remember the girl who taught us English?&lt;/li&gt;
      &lt;li&gt;Clock is a kind of instrument which can tell people time.&lt;/li&gt;
      &lt;li&gt;This is the place where he used to live.&lt;/li&gt;
      &lt;li&gt;Mr. Zhang, who came to see me yesterday, is an old friend of mine.&lt;/li&gt;
      &lt;li&gt;We walked down the village street, where they were having market day.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;前三个例句中，定语从句与先行词关系密切，为限制性定语从句，不可用逗号隔开；后面两个例句中，定语从句与先行词关系不密切，为非限制性定语从句。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先行词内容有所不同&lt;/p&gt;

    &lt;p&gt;大多数限制性和非限制性定语从句的先行词往往为某一个词或短语，而特殊情况下&lt;strong&gt;&lt;em&gt;非限制性定语从句的先行词也可为整个主句,此时非限制性定语从句常由 which 引导&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;A middle-aged woman killed her husband&lt;/em&gt;, &lt;strong&gt;which&lt;/strong&gt; frightened me very much.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;A five-year-old boy can speak two foreign languages&lt;/em&gt;, &lt;strong&gt;which&lt;/strong&gt; surprises all the people present.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用的关系词有所不同
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;that 不可以引导非限制性定语从句&lt;/p&gt;

        &lt;p&gt;所有关系代词和关系副词都可以引导限制性定语从句，大部分关系代词与关系副词都可以引导非限制性定语从句，但是 that 除外。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;He gave his mother a color TV set for her birthday, that pleased her a lot.（wrong）&lt;/li&gt;
          &lt;li&gt;He gave his mother a color TV set for her birthday, &lt;strong&gt;&lt;em&gt;which&lt;/em&gt;&lt;/strong&gt; pleased her a lot.（wright）&lt;/li&gt;
          &lt;li&gt;He didn’t pass the exam, that disappointed me.（wrong）&lt;/li&gt;
          &lt;li&gt;He didn’t pass the exam, &lt;strong&gt;&lt;em&gt;which&lt;/em&gt;&lt;/strong&gt; disappointed me.（wright）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关系词替代情况不同&lt;/p&gt;

        &lt;p&gt;关系代词 whom 在限制性定语从句中作宾语时可用 who 代替 whom ,但 whom 在非限制性定语从句中作宾语时不可用 who 来代替。&lt;/p&gt;

        &lt;p&gt;在限制性定语从句中,先行词指人时可用 that 代替 who/whom ,但在非限制性定语从句中先行词指人时, 不可用 that 代替 who/whom。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关系代词省略情况不同&lt;/p&gt;

        &lt;p&gt;关系代词在&lt;strong&gt;&lt;em&gt;限制性定语从句中作宾语时可以省去&lt;/em&gt;&lt;/strong&gt;,非限制性定语从句的所有关系词均不可省。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;This is the book (&lt;em&gt;which/that&lt;/em&gt;) he lost yesterday.&lt;/li&gt;
          &lt;li&gt;The book, &lt;em&gt;which&lt;/em&gt; he lost yesterday, has been found.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-wich-与-that&quot;&gt;5-wich 与 that&lt;/h2&gt;

&lt;h3 id=&quot;5-1-定语从句中只用-that-不用-which&quot;&gt;5-1 定语从句中只用 that, 不用 which&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;先行词是 &lt;strong&gt;everything, anything, nothing&lt;/strong&gt; (something 除外), &lt;strong&gt;all, none, few, little, some&lt;/strong&gt; 等不定代词时，或当先行词被 &lt;strong&gt;every, any, all, some, no, little, few, much 等词修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Have you set down everything that Mr. Li said?&lt;/li&gt;
      &lt;li&gt;There seems to be nothing that is impossible to him in the world.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;当先行词指人时，偶尔也可用关系代词 who。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Any man that/who has a sense of responsibility won’t do such a thing.&lt;/li&gt;
      &lt;li&gt;All the guests that/who were invited to her wedding were important people.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被序数词修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;The first American movie that I watched was the Titanic.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被形容词最高级修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;This is the best museum that I have visited all my life.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被 the very, the only, the first/last 等修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;She is the only person that understands me.&lt;/li&gt;
      &lt;li&gt;After the big fire, the old car is the only thing that he owns.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;前面有 who, which 等疑问代词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Who is the man that is standing in front of the crowd?&lt;/li&gt;
      &lt;li&gt;Which is the room that Mr. Wang lives in?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词为人与动物或人与物
    &lt;ul&gt;
      &lt;li&gt;Look at the man and his donkey that are walking alone the street.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词是 reason, way 等词时，关系代词常用 that 代替 in which, for which, why，也常可省略
    &lt;ul&gt;
      &lt;li&gt;She admired the way (that) they solved the questions.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5-2-定语从句中只用-which-不用-that&quot;&gt;5-2 定语从句中只用 which, 不用 that&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在非限定性定语从句中，在任何情况下都不能用 that
    &lt;ul&gt;
      &lt;li&gt;This brunch of carnation, which is wound by silk ribbon, is the first gift to my mom.&lt;/li&gt;
      &lt;li&gt;These books, which you can get at any corner of the town, will give you all the information.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;关系代词前面有介词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Those days in which you could travel without a passport has gone.&lt;/li&gt;
      &lt;li&gt;That is the motel at which we stayed several years ago.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词本身为 that (指代作用)
    &lt;ul&gt;
      &lt;li&gt;what about that which had appeared in recent activities.&lt;/li&gt;
      &lt;li&gt;The knowledge are from various fields and that which display the waves of human being.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-基本概念</summary></entry><entry><title type="html">表语从句</title><link href="http://localhost:4000/predicative-clause.html" rel="alternate" type="text/html" title="表语从句" /><published>2022-02-09T00:00:00+08:00</published><updated>2022-02-09T00:00:00+08:00</updated><id>http://localhost:4000/predicative-clause</id><content type="html" xml:base="http://localhost:4000/predicative-clause.html">&lt;h2 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h2&gt;

&lt;p&gt;表语从句放在连系动词之后，充当复合句中的表语。&lt;/p&gt;

&lt;p&gt;表语从句( Predicative Clause )就是指一个&lt;strong&gt;句子作为表语，说明主语是什么或者怎么样&lt;/strong&gt;，由名词、形容词或相当于名词或形容词的词或短语充当，和&lt;strong&gt;连系动词一起构成谓语&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;2-构成&quot;&gt;2-构成&lt;/h2&gt;

&lt;p&gt;主语+连系动词+句子作表语(表语从句)&lt;/p&gt;

&lt;h2 id=&quot;3-引导表语从句的关联词&quot;&gt;3-引导表语从句的关联词&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;引导表语从句的&lt;strong&gt;连系动词&lt;/strong&gt;有：&lt;strong&gt;be，look，seem，sound，appea&lt;/strong&gt;r 等
    &lt;ul&gt;
      &lt;li&gt;China is no longer what she used to be.&lt;/li&gt;
      &lt;li&gt;The question remains whether they will be able to help us.&lt;/li&gt;
      &lt;li&gt;At that time，it seemed as if I couldn’t think of the right word.&lt;/li&gt;
      &lt;li&gt;It seems to me that we should answer for this. (在我看来…)&lt;/li&gt;
      &lt;li&gt;It appears to her that he wants to teach us all he has. (在她看来…)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;从属连词 whether，as，as if / though&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;He looked just as he had looked ten years before.&lt;/li&gt;
      &lt;li&gt;It sounds as if someone is knocking at the door.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;从属连词 that&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;The trouble is that I have lost his address.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;because，why&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;That’s because he didn’t understand me.（强调原因；那是因为…）&lt;/li&gt;
      &lt;li&gt;That’s why he got angry with me.（强调结果；那是为什么…）&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;what 引导的主语从句&lt;strong&gt;表示结果&lt;/strong&gt;或&lt;strong&gt;名词 reason 作主语&lt;/strong&gt;时，后面的表语从句表示原因时要用 that 引导，不宜用 because.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The reason why I was sad was &lt;strong&gt;that&lt;/strong&gt; he didn’t understand me.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;连接代词/连接副词&lt;/strong&gt;引导表语从句&lt;/p&gt;

    &lt;p&gt;连接代词有 : &lt;strong&gt;who，whom，whose，what，which，whoever，whatever，whichever&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The problem is who we can get to replace her.&lt;/li&gt;
      &lt;li&gt;That was what she did this morning on reaching the attic.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;连接副词有：&lt;strong&gt;where，when，how，why&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The question is how he did it.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用虚拟语气的表语从句&lt;/p&gt;

    &lt;p&gt;在&lt;strong&gt;表示建议、劝告、命令含义的名词后的表语从句，谓语动词需用 “should+动词原形” 表示&lt;/strong&gt;(should 可省略)。&lt;/p&gt;

    &lt;p&gt;常见的词有：&lt;strong&gt;advice，suggestion，order，proposal，plan，idea&lt;/strong&gt; 等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;My suggestion is that we (should) start early tomorrow.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-总结&quot;&gt;4-总结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;连系动词 be，appear，seem，look等之后可以跟表语从句&lt;/li&gt;
  &lt;li&gt;引导表语从句的引导词分为：
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;wh-疑问词&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;My question is who left.&lt;/li&gt;
          &lt;li&gt;What I wonder is when he left.&lt;/li&gt;
          &lt;li&gt;That’s what he wants.&lt;/li&gt;
          &lt;li&gt;This is where they once lived.&lt;/li&gt;
          &lt;li&gt;That is why he didn’t come here.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;whether&lt;/strong&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;if 不能引导表语从句&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;ul&gt;
          &lt;li&gt;My question is whether he left (or not).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;that&lt;/strong&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;that 有时可省略&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;ul&gt;
          &lt;li&gt;The fact is that he left.&lt;/li&gt;
          &lt;li&gt;The truth is（that）I didn’t go there.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;because，as，as if，as though&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;It’s just because he doesn’t know her.&lt;/li&gt;
          &lt;li&gt;Things are not always as they seem to be.&lt;/li&gt;
          &lt;li&gt;He looks as if he’s tired.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-介绍</summary></entry><entry><title type="html">宾语从句</title><link href="http://localhost:4000/object-clause.html" rel="alternate" type="text/html" title="宾语从句" /><published>2022-02-08T00:00:00+08:00</published><updated>2022-02-08T00:00:00+08:00</updated><id>http://localhost:4000/object-clause</id><content type="html" xml:base="http://localhost:4000/object-clause.html">&lt;h2 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h2&gt;

&lt;p&gt;定义：&lt;strong&gt;置于动词、介词等词性后面，在句子中起宾语作用的从句叫做宾语从句。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;宾语从句分为三类：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;动词的宾语从句&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;介词的宾语从句&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;形容词的宾语从句&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;宾语从句语法需要关注三点：时态，语序，连词。&lt;/strong&gt;宾语从句的语序必须是陈述语序，谓语动词、介词、动词不定式，v.-ing形式后面都能带宾语从句，有些形容词(afraid，sure，glad等)之后也可以带宾语从句。&lt;/p&gt;

&lt;h2 id=&quot;2-连接词&quot;&gt;2-连接词&lt;/h2&gt;

&lt;p&gt;在复合句中作主句的宾语，连接词有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;连词：that (that 常可省略), whether, if&lt;/li&gt;
  &lt;li&gt;代词：who, whose, what, which&lt;/li&gt;
  &lt;li&gt;副词：when ,where, how, why 等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-1-that-引导的宾语从句&quot;&gt;2-1 that 引导的宾语从句&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;在非正式场合that可以省略&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;可跟 that 从句做宾语的动词有：&lt;strong&gt;say, think, insist, wish, hope, demand, imagine, wonder, know, suppose, see, believe, agree, admit, deny, expect, explain, order, command, feel, dream, suggest, hear, mean, notice, prefer, request, require, propose, declare, report&lt;/strong&gt; 等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The boy believes that he will travel through space to other planets.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，&lt;strong&gt;当主句谓语动词是 think, believe, suppose, expect 等词，而宾语从句的意思是否定时，常把否定转移至主句表示。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I don’t think it is right for him to treat you like that.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在以下情况中 that 不能省略&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当句中的动词后接&lt;em&gt;多于两个由 that 引导的宾语从句&lt;/em&gt;时，第一个 that 可省，但后面的 that 不可省。
    &lt;ul&gt;
      &lt;li&gt;He said (that) you were too young to understand the matter and that he was asked not to tell you.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当&lt;em&gt;主句的谓语动词与 that 宾语从句之间有插入语&lt;/em&gt;时，that 一般不可省。
    &lt;ul&gt;
      &lt;li&gt;Just then I noticed, for the first time, that our master was wearing his fine green coat and his black silk cap.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当 &lt;em&gt;that 从句是双宾语中的直接宾语&lt;/em&gt;时，that 不可省。
    &lt;ul&gt;
      &lt;li&gt;I can’t tell him that his mother died.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;许多带复合宾语的句子，&lt;em&gt;that 引导的宾语从句经常移到句子后部，而用 it 作形式宾语&lt;/em&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I find it necessary that we should do the homework on time.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-2-whetherif-引导的宾语从句&quot;&gt;2-2 whether/if 引导的宾语从句&lt;/h3&gt;

&lt;p&gt;由 whether/if 引导的宾语从句，实际上是&lt;em&gt;一般疑问句演变而来的，&lt;/em&gt;意思是“是否”，此时&lt;strong&gt;宾语从句要用陈述句语序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一般说来，在宾语从句中 whether 与 if 可以互换使用，但在特殊情况下 if 与 whether 是不能互换的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I wonder whether(if) they will come to our party.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下场景不能互换：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;只能用 whether，不能用 if 引导的宾语从句&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;在带 to 的不定式前
        &lt;ul&gt;
          &lt;li&gt;We decided whether to walk there.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在介词的后面
        &lt;ul&gt;
          &lt;li&gt;I’m thinking of whether we should go to see the film.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在 discuss, decided 等动词后面的宾语从句
        &lt;ul&gt;
          &lt;li&gt;We discussed whether we had a sports meeting next week.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;直接与 or not 连用时
        &lt;ul&gt;
          &lt;li&gt;I can’t say whether or not they can come on time.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;只能用 if 不能用 whether 引导的宾语从句&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;if 引导条件状语从句，意为“如果”
        &lt;ul&gt;
          &lt;li&gt;The students will go on a picnic if it is sunny.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;if 引导否定概念的宾语从句时
        &lt;ul&gt;
          &lt;li&gt;He asked if I didn’t come to school yesterday.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;引导状语从句 even if(即使)和 as if(好象)时
        &lt;ul&gt;
          &lt;li&gt;He talks as if he has known all about it.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-连接代词和连接副词引导的宾语从句&quot;&gt;2-3 连接代词和连接副词引导的宾语从句&lt;/h3&gt;

&lt;p&gt;这样的宾语从句实际上是由&lt;em&gt;特殊疑问句变化而来的&lt;/em&gt;，&lt;strong&gt;宾语从句要用陈述句语序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;用于这种结构的动词常常是：&lt;strong&gt;see, say, tell, ask, answer, know, decide, show, find out, imagine, suggest, doubt, wonder, discover, understand, inform, advise&lt;/strong&gt; 等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;连接代词有：who, whom, whose, which, what，在&lt;strong&gt;句中担任主语、宾语、定语或者表语&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;Can you tell me whom you are waiting for?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接副词有：when,where,why,how，在&lt;strong&gt;句中担任状语的成分&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;None of us knows where these new parts can be bought.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-语序&quot;&gt;3-语序&lt;/h2&gt;

&lt;p&gt;无论主句是陈述句还是疑问句，&lt;strong&gt;宾语从句都必须使用陈述语序&lt;/strong&gt;，即“主句+连接词+宾语从句(主语+谓语+……)”句式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Could you tell me who knows the answer?&lt;/li&gt;
  &lt;li&gt;The small children don’t know what is in their stockings.&lt;/li&gt;
  &lt;li&gt;He asked whose handwriting was the best in our class.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-时态&quot;&gt;4-时态&lt;/h2&gt;

&lt;p&gt;含宾语从句的复合句，主句、从句谓语动词的时态呼应，包括以下几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;主句的谓语动词是一般现在时，从句的谓语动词可根据需要，选用相应的&lt;strong&gt;任何时态&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;I don’t know when he will come back.&lt;/li&gt;
      &lt;li&gt;He tells me that his sister came back yesterday.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;主句的谓语动词是过去时，宾语从句的谓语动词只可根据需要，选用过去时态即&lt;strong&gt;一般过去时、过去进行时、过去将来时或过去完成时的某一种形式&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;The children didn’t know who he was.&lt;/li&gt;
      &lt;li&gt;He asked his father how it happened.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果宾语从句所表示的是&lt;em&gt;客观事实、普遍真理、自然现象或习惯性动作&lt;/em&gt;等，不管主句用什么时态，&lt;em&gt;从句时态都用一般现在时&lt;/em&gt;。
    &lt;ul&gt;
      &lt;li&gt;The teacher said that the earth goes round the sun.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-总结&quot;&gt;5-总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;宾语从句可以作及物动词、介词及形容词的宾语。&lt;/li&gt;
  &lt;li&gt;宾语从句的语序一律用陈述句语序。&lt;/li&gt;
  &lt;li&gt;连接词 that 引导宾语从句在句中无词义，不充当句子成份，多数情况下可以省略。&lt;/li&gt;
  &lt;li&gt;whether 和 if 都可引导宾语从句，但 whether 后可紧跟 or not；whether 从句可作介词的宾语。&lt;/li&gt;
  &lt;li&gt;如果从句太长，可以用形式宾语it。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-介绍</summary></entry><entry><title type="html">such &amp;amp; so</title><link href="http://localhost:4000/such-and-so.html" rel="alternate" type="text/html" title="such &amp;amp; so" /><published>2022-01-20T00:00:00+08:00</published><updated>2022-01-20T00:00:00+08:00</updated><id>http://localhost:4000/such-and-so</id><content type="html" xml:base="http://localhost:4000/such-and-so.html">&lt;p&gt;such 和 so 都可以&lt;strong&gt;表示程度&lt;/strong&gt;，含有“如此、这/那样、这/那么”的意思，但它们在用法上有一定区别。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;such 为形容词，一般&lt;strong&gt;修饰名词&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;so 为副词，一般&lt;strong&gt;修饰形容词或副词&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;such-用法&quot;&gt;such 用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;such + a/an + 可数名词单数
    &lt;ul&gt;
      &lt;li&gt;All of us have never seen &lt;strong&gt;&lt;em&gt;such an animal before&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
      &lt;li&gt;He said he would rather be poor than get money &lt;strong&gt;&lt;em&gt;in such a way&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + a/an + 形容词 + 可数名词单数
    &lt;ul&gt;
      &lt;li&gt;She is &lt;strong&gt;&lt;em&gt;such a good teacher&lt;/em&gt;&lt;/strong&gt; just as we expect.&lt;/li&gt;
      &lt;li&gt;I really thank you for giving &lt;strong&gt;&lt;em&gt;such an exciting party&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 可数名词复数
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Such things&lt;/em&gt;&lt;/strong&gt; often happen in our daily life.&lt;/li&gt;
      &lt;li&gt;I don’t think &lt;strong&gt;&lt;em&gt;such people&lt;/em&gt;&lt;/strong&gt; are dangerous.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 形容词 + 可数名词复数
    &lt;ul&gt;
      &lt;li&gt;He told us &lt;strong&gt;&lt;em&gt;such funny stories&lt;/em&gt;&lt;/strong&gt; that we all couldn’t help laughing.&lt;/li&gt;
      &lt;li&gt;He’s amazed to see &lt;strong&gt;&lt;em&gt;such beautiful fishes&lt;/em&gt;&lt;/strong&gt; under the sea.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 不可数名词
    &lt;ul&gt;
      &lt;li&gt;When he knew &lt;strong&gt;&lt;em&gt;such news&lt;/em&gt;&lt;/strong&gt;, he began to cry.&lt;/li&gt;
      &lt;li&gt;It’s dangerous to go swimming in &lt;strong&gt;&lt;em&gt;such weather&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 形容词 + 不可数名词
    &lt;ul&gt;
      &lt;li&gt;We are glad to see that he has made &lt;strong&gt;&lt;em&gt;such rapid progress&lt;/em&gt;&lt;/strong&gt; in English this term.&lt;/li&gt;
      &lt;li&gt;I’ll remember &lt;strong&gt;&lt;em&gt;such delicious food&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;so-用法&quot;&gt;so 用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;so + 形容词/副词
    &lt;ul&gt;
      &lt;li&gt;It’s &lt;strong&gt;&lt;em&gt;so cold&lt;/em&gt;&lt;/strong&gt; outside. We’d better wear warm clothes.&lt;/li&gt;
      &lt;li&gt;He spoke &lt;strong&gt;&lt;em&gt;so fast&lt;/em&gt;&lt;/strong&gt; that I couldn’t follow.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;so + 形容词 + a/an + 可数名词单数
    &lt;ul&gt;
      &lt;li&gt;He’s &lt;strong&gt;&lt;em&gt;so kind a man&lt;/em&gt;&lt;/strong&gt; that everybody here likes him.&lt;/li&gt;
      &lt;li&gt;It’s &lt;strong&gt;&lt;em&gt;so easy an exercise&lt;/em&gt;&lt;/strong&gt; that every one of us can do it.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;这种句式可以和 such + a/an + 形容词 + 可数名词单数换用：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I’ve never seen so amusing a film. = I’ve never seen such an amusing film.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;so + many/much/few/little + 可数名词复数/不可数名词
    &lt;ul&gt;
      &lt;li&gt;There are &lt;strong&gt;&lt;em&gt;so many visitors&lt;/em&gt;&lt;/strong&gt; in our school today.&lt;/li&gt;
      &lt;li&gt;I have eaten &lt;strong&gt;&lt;em&gt;so much food&lt;/em&gt;&lt;/strong&gt;. I don’t want to eat any more.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;so many 已成固定搭配，a lot of 虽相当于 many，但 a lot of 为名词性的，只能用 such 搭配。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I feel very happy that I have such a lot of friends.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">such 和 so 都可以表示程度，含有“如此、这/那样、这/那么”的意思，但它们在用法上有一定区别。</summary></entry><entry><title type="html">过去完成时</title><link href="http://localhost:4000/perfect-past-tense.html" rel="alternate" type="text/html" title="过去完成时" /><published>2022-01-20T00:00:00+08:00</published><updated>2022-01-20T00:00:00+08:00</updated><id>http://localhost:4000/perfect-past-tense</id><content type="html" xml:base="http://localhost:4000/perfect-past-tense.html">&lt;h2 id=&quot;含义与结构&quot;&gt;含义与结构&lt;/h2&gt;

&lt;p&gt;过去完成时表示&lt;strong&gt;&lt;em&gt;过去某一时间或动作&lt;/em&gt;&lt;/strong&gt;以前已经发生或完成了的动作，对过去的某一点造成的某种影响或是结果，用来指&lt;strong&gt;在另一个过去动作之前就已经完成了的事件&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;动作发生的时间是”过去的过去”，侧重事情的结果。&lt;/p&gt;

&lt;p&gt;基本结构为：&lt;strong&gt;主语+had+动词过去分词&lt;/strong&gt;（done）&lt;/p&gt;

&lt;h2 id=&quot;用法&quot;&gt;用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;表示在&lt;strong&gt;过去某一时刻或动作以前完成了的动作&lt;/strong&gt;，表示“过去的过去”；可以用 &lt;strong&gt;by, before&lt;/strong&gt; 等介词短语或一个时间状语从句来表示，也可以用一个表示过去的动作来表示，还可能通过上下文来表示。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;By&lt;/strong&gt; the time I got outside, the bus had already left.&lt;/li&gt;
      &lt;li&gt;She had studied English for six years &lt;strong&gt;before&lt;/strong&gt; she went to college.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示由过去的某一时刻开始，一直&lt;strong&gt;延续到过去另一时间&lt;/strong&gt;的动作或状态，常和 &lt;strong&gt;for, since&lt;/strong&gt; 构成的时间状语连用。
    &lt;ul&gt;
      &lt;li&gt;He had lived in the house &lt;strong&gt;for&lt;/strong&gt; five years.&lt;/li&gt;
      &lt;li&gt;He said he had worked in that factory &lt;strong&gt;since&lt;/strong&gt; 1949.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;叙述过去发生的事情，在已叙述了过去发生的事情后，反过来&lt;strong&gt;追述或补述以前发生的动作&lt;/strong&gt;时，常使用过去完成时。
    &lt;ul&gt;
      &lt;li&gt;Mr. Smith died yesterday. He had been a good friend of mine.&lt;/li&gt;
      &lt;li&gt;I didn’t know a thing about the verbs, for I had not studied my lesson.（因为我没有好好学习，作为补充）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在含有定语从句的&lt;strong&gt;主从复合句&lt;/strong&gt;中，如果&lt;strong&gt;叙述的是过去的事&lt;/strong&gt;，&lt;strong&gt;先发生的动作常用过去完成时&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;I returned the book that I had borrowed.&lt;/li&gt;
      &lt;li&gt;She found the key that she had lost.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;过去完成时常常&lt;strong&gt;用在 told, said, knew, heard, thought 等动词后的宾语从句&lt;/strong&gt;（或间接引语）中，这时从句中的动作发生在主句表示的过去的动作之前。
    &lt;ul&gt;
      &lt;li&gt;He said that he had known her well.&lt;/li&gt;
      &lt;li&gt;I thought I had sent the letter a week before.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;含有时间状语从句，对于过去不同时间发生的两个动作，&lt;strong&gt;发生在前的动作，用过去完成时；发生在后的动作，用一般过去时&lt;/strong&gt;。如 &lt;strong&gt;when, before, after, as soon as, till/until 引导的从句。&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;When&lt;/strong&gt; I woke up, it had already stopped raining.&lt;/li&gt;
      &lt;li&gt;She didn’t go to bed &lt;strong&gt;until&lt;/strong&gt; she had finished her work.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;需要注意的是，如果&lt;strong&gt;两个动作紧接着发生&lt;/strong&gt;，则常常不用过去完成时，特别是在包含 &lt;strong&gt;before&lt;/strong&gt; 和&lt;strong&gt;after&lt;/strong&gt; 的复合句中，因为这时&lt;em&gt;从句的动作和主句的动作发生的先后顺序已经非常明确&lt;/em&gt;，可以用一般过去时代替过去完成时。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;After he arrived in England, Marx worked hard to improve his English.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动词 &lt;strong&gt;think, want, hope, mean, plan, intend 等用过去完成时来表示过去未曾实现&lt;/strong&gt;的想法，希望，打算或意图等。
    &lt;ul&gt;
      &lt;li&gt;They &lt;strong&gt;had wanted&lt;/strong&gt; to help but could not get there in time.&lt;/li&gt;
      &lt;li&gt;We &lt;strong&gt;had hoped&lt;/strong&gt; to be able to come and see you.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;过去完成时还可用在 &lt;strong&gt;hardly…when…, no sooner…than…, It was the first (second, etc) time (that)…&lt;/strong&gt; 等固定句型中。
    &lt;ul&gt;
      &lt;li&gt;Hardly had he begun to speak when the audience interrupted him.（一 … 就 …，倒装句）&lt;/li&gt;
      &lt;li&gt;No sooner had he arrived than he went away again.（一 … 就 …，倒装句）&lt;/li&gt;
      &lt;li&gt;It was the third time that he had been out of work that year.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">含义与结构</summary></entry></feed>