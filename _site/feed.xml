<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-04-04T16:25:57+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Find a needle in haystack</title><subtitle></subtitle><author><name>kkzhang</name></author><entry><title type="html">非谓语动词</title><link href="http://localhost:4000/non-predicate-verb.html" rel="alternate" type="text/html" title="非谓语动词" /><published>2022-04-04T00:00:00+08:00</published><updated>2022-04-04T00:00:00+08:00</updated><id>http://localhost:4000/non-predicate-verb</id><content type="html" xml:base="http://localhost:4000/non-predicate-verb.html">&lt;h1 id=&quot;1-什么是非谓语动词&quot;&gt;1-什么是非谓语动词&lt;/h1&gt;
&lt;h2 id=&quot;1-1-介绍&quot;&gt;1-1-介绍&lt;/h2&gt;

&lt;p&gt;非谓语动词，又叫非限定动词。非谓语动词是指在句子中不是谓语的动词，主要包括&lt;strong&gt;&lt;em&gt;不定式、动名词和分词（现在分词和过去分词）&lt;/em&gt;&lt;/strong&gt;，即动词的非谓语形式。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;动名词与现在分词虽然表现形式相同，但是起到的作用是有所区别的。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;动名词只具有名词词性，在句子中做主语或者宾语。现在分词具有动词词性（与 be 动词连用补足），形容词词性（作定语），副词词性（作状语）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;非谓语动词除了不能独立作谓语外，可以承担句子的其他成分。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;非谓语动词中需要记住的口诀：&lt;strong&gt;&lt;em&gt;主动进行现在分词，被动完成过去分词，不定式表将来&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;需要注意的是，非谓语动词本身不能表示现在，过去，和将来。&lt;strong&gt;&lt;em&gt;非谓语动词表示进行，将来和完成时是相对于谓语动作来说的&lt;/em&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;和谓语动作同时发生表示进行&lt;/li&gt;
  &lt;li&gt;发生在谓语动作之后表示将来&lt;/li&gt;
  &lt;li&gt;发生在谓语动作之前表示完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-1-不定式&quot;&gt;1-1-1 不定式&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;基本形式&lt;/th&gt;
      &lt;th&gt;被动式&lt;/th&gt;
      &lt;th&gt;进行式&lt;/th&gt;
      &lt;th&gt;完成式&lt;/th&gt;
      &lt;th&gt;完成被动式&lt;/th&gt;
      &lt;th&gt;完成进行式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;to do&lt;/td&gt;
      &lt;td&gt;to be done&lt;/td&gt;
      &lt;td&gt;to be doing&lt;/td&gt;
      &lt;td&gt;to have done&lt;/td&gt;
      &lt;td&gt;to have been done&lt;/td&gt;
      &lt;td&gt;to have been doing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示主动，并且一般表示将来&lt;/td&gt;
      &lt;td&gt;表示被动，并且一般表示将来&lt;/td&gt;
      &lt;td&gt;表示主动和进行&lt;/td&gt;
      &lt;td&gt;表示主动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成进行&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;The teacher told us to do morning exercises.(to do)&lt;/li&gt;
  &lt;li&gt;The car to be bought is for his sister. (to be done)&lt;/li&gt;
  &lt;li&gt;She pretended to be reading when the teacher came into the classroom. (to be doing)&lt;/li&gt;
  &lt;li&gt;The thief is said to have escaped. (to have done)&lt;/li&gt;
  &lt;li&gt;The thief is said to have been arrested. (to have been done)&lt;/li&gt;
  &lt;li&gt;She is said to have been working in the factory over the last 20 years. (to have been doing)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-2-动名词&quot;&gt;1-1-2 动名词&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;基本形式&lt;/th&gt;
      &lt;th&gt;被动式&lt;/th&gt;
      &lt;th&gt;完成式&lt;/th&gt;
      &lt;th&gt;完成被动式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;doing&lt;/td&gt;
      &lt;td&gt;being done&lt;/td&gt;
      &lt;td&gt;having done&lt;/td&gt;
      &lt;td&gt;having been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示主动&lt;/td&gt;
      &lt;td&gt;表示被动&lt;/td&gt;
      &lt;td&gt;表示主动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Travelling in space by ordinary people will be common in the future. (doing)&lt;/li&gt;
  &lt;li&gt;Freddy and his band could go nowhere without being followed by their fans. (being done)&lt;/li&gt;
  &lt;li&gt;I have no idea of his having done such a thing against you. (having done)&lt;/li&gt;
  &lt;li&gt;Many customers complain of having been given short weight at that shop. (having been done)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-3-现在分词&quot;&gt;1-1-3 现在分词&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;基本形式&lt;/th&gt;
      &lt;th&gt;被动式&lt;/th&gt;
      &lt;th&gt;完成式&lt;/th&gt;
      &lt;th&gt;完成被动式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;doing&lt;/td&gt;
      &lt;td&gt;being done&lt;/td&gt;
      &lt;td&gt;having done&lt;/td&gt;
      &lt;td&gt;having been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示主动和进行&lt;/td&gt;
      &lt;td&gt;表示被动和进行&lt;/td&gt;
      &lt;td&gt;表示主动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;He sat there，reading a newspaper. (doing)&lt;/li&gt;
  &lt;li&gt;The area being studied may be rich in coal. (being done)&lt;/li&gt;
  &lt;li&gt;Having finished my homework，I began to watch TV. (having done)&lt;/li&gt;
  &lt;li&gt;Having been told many times，she still can’t remember it. (having been done)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-4-过去分词&quot;&gt;1-1-4 过去分词&lt;/h3&gt;

&lt;p&gt;过去分词只有一种形式：done.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;及物动词的过去分词作表语，&lt;strong&gt;&lt;em&gt;与句子的主语是被动关系&lt;/em&gt;&lt;/strong&gt;，表示主语的状态。既表示被动，又强调已完成。
    &lt;ul&gt;
      &lt;li&gt;The cup is broken.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不及物动词的过去分词作表语，&lt;strong&gt;&lt;em&gt;与句子的主语是主动关系&lt;/em&gt;&lt;/strong&gt;，表示主语的状态，同样强调动作的完成。
    &lt;ul&gt;
      &lt;li&gt;He is retired.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;2-动词不定式&quot;&gt;2-动词不定式&lt;/h1&gt;
&lt;h2 id=&quot;2-1-介绍&quot;&gt;2-1-介绍&lt;/h2&gt;

&lt;p&gt;动词不定式是一种非谓语动词形式，其结构为 &lt;strong&gt;to do&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中 to 不是介词，而是动词不定式的符号，称为小品词&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;动词不定式没有人称和数的变化，但有时态和语态的变化。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;动词不定式和其后面的名词等构成不定式短语&lt;/em&gt;，在句子中可以&lt;strong&gt;用作主语、表语、宾语、定语、状语、补足语、独立成分或与疑问词等连用&lt;/strong&gt; 。&lt;/p&gt;

&lt;h2 id=&quot;2-2-时态--语态&quot;&gt;2-2-时态 &amp;amp; 语态&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;不定式&lt;/th&gt;
      &lt;th&gt;主动语态&lt;/th&gt;
      &lt;th&gt;被动语态&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;一般式&lt;/td&gt;
      &lt;td&gt;to do&lt;/td&gt;
      &lt;td&gt;to be done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;进行式&lt;/td&gt;
      &lt;td&gt;to be doing&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成式&lt;/td&gt;
      &lt;td&gt;to have done&lt;/td&gt;
      &lt;td&gt;to have been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成进行式&lt;/td&gt;
      &lt;td&gt;to have been doing&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;They pretended not to see us.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;不定式的一般式表示与谓语动词动作 &lt;strong&gt;&lt;em&gt;几乎同时发生&lt;/em&gt;&lt;/strong&gt; 或者 &lt;strong&gt;&lt;em&gt;发生在谓语动词动作之后&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;He pretended to be sleeping.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;不定式的进行式表示&lt;strong&gt;&lt;em&gt;在谓语动词动作发生的同时,不定式的动作也正在进行&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;She pretended to have known it before.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;完成式表示不定式动作&lt;strong&gt;&lt;em&gt;发生在谓语动作之前&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’re happy to have been working with you.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;完成进行式表示&lt;strong&gt;&lt;em&gt;谓语动作发生之前,不定式的动作一直在进行而且可能之后也继续&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-3-用法&quot;&gt;2-3-用法&lt;/h2&gt;

&lt;h3 id=&quot;2-3-1-主语&quot;&gt;2-3-1 主语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;To be a doctor is hard. &lt;/li&gt;
  &lt;li&gt;To learn English well is not easy.  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;单个不定式作主语时，谓语动词用单数&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;动词不定式（短语）作主语时，为了避免句子的头重脚轻，可以&lt;strong&gt;用 “it” 作形式主语，而把真正的主语即动词不定式（短语）放在句子的后部&lt;/strong&gt;。如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It is not easy to learn English well.&lt;/li&gt;
  &lt;li&gt;It is important for students to use English every day.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-2-宾语&quot;&gt;2-3-2 宾语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;动词不定式当宾语的格式为：vt + to do.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;动词不定式（短语）可以放在一些动词后面用作宾语，能以动词不定式作宾语的动词有：begin, start, want, forget, remember, learn, like, hate, love, ask , decide, expect, want, hope, wish, offer, fail, plan, learn, pretend, refuse, manage, help, agree, promise, prefer, mean 等等&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;I want to tell you a story.&lt;/li&gt;
  &lt;li&gt;They begin to work at eight every morning.&lt;/li&gt;
  &lt;li&gt;Don’t forget to lock the door.&lt;/li&gt;
  &lt;li&gt;Would you like to go and have a picnic with us tomorrow?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果 and 连接两个动词不定式，&lt;em&gt;第二个动词不定式一般省 “to”&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He wants to go and have a swim with us.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;若作宾语的动词不定式（短语）很长，可用 it 作形式宾语&lt;/strong&gt;（与形式主语类似）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I find it interesting to learn English with you.&lt;/li&gt;
  &lt;li&gt;He found it hard to catch up with others.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-3-3-表语&quot;&gt;2-3-3 表语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;表语，属于主语补足语，语法名词，是指说明主语的身份、性质、品性、特征和状态的词或从句。表语常由名词、形容词、介词短语、动名词、不定式、副词来充当，它&lt;em&gt;常位于系动词之后&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;不定式表示目的
    &lt;ul&gt;
      &lt;li&gt;The purpose of education is to develop a fine personality in children.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示事态发展的结果、预期的结果、不幸的命运
    &lt;ul&gt;
      &lt;li&gt;He was to perish in a shipwreck and to leave a wife and two children.&lt;/li&gt;
      &lt;li&gt;You are to die at ninety-eight.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用于第一人称疑问句，表示征求意见
    &lt;ul&gt;
      &lt;li&gt;What am I to say if they ask me the question?&lt;/li&gt;
      &lt;li&gt;What am I to do if I have no money?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示“同意、安排、命令、决定、劝告、意愿、禁止”等
    &lt;ul&gt;
      &lt;li&gt;They are to marry next week.&lt;/li&gt;
      &lt;li&gt;Children are not to smoke.&lt;/li&gt;
      &lt;li&gt;You must be patient and persistent if you are to succeed.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;不定式作表语，可用主动形式表示被动意义&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;She is to blame.&lt;/li&gt;
      &lt;li&gt;Something is still to find out.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-4-定语&quot;&gt;2-3-4 定语&lt;/h3&gt;

&lt;p&gt;动词不定式作定语，&lt;em&gt;放在所修饰的名词或代词后&lt;/em&gt;。与所修饰名词有如下关系:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;主谓关系&lt;/p&gt;

    &lt;p&gt;不定式作定语表示主谓关系，指的是中心词是不定式的逻辑主语&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He is not a man to tell a lie.&lt;/li&gt;
      &lt;li&gt;See if you can get the car to start.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动宾关系&lt;/p&gt;

    &lt;p&gt;不定式作定语表示动宾关系，指的是中心词是不定式的逻辑宾语&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;We have a lot of work to do.&lt;/li&gt;
      &lt;li&gt;I have some clothes to wash.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;当不定式与所修饰的中心词有动宾关系时，不定式的动词需为及物动词，若是不及物动词，不定式后需加上适当的介词。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I need a pen to write with.&lt;/li&gt;
      &lt;li&gt;Give me some paper to write on.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同位关系&lt;/p&gt;

    &lt;p&gt;不定式做定语表示同位关系，指的是不定式是中心词的内容，两者具有同位关系&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I have a wish to go to college.&lt;/li&gt;
      &lt;li&gt;I had a dream to fly in the sky like a bird.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有时不表示任何特别关系&lt;/p&gt;

    &lt;p&gt;有时不定式与被修饰的名词不存在主谓、动宾、同位关系的，此时被修饰的名词多是些抽象名词&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;We have no need to be afraid of them!&lt;/li&gt;
      &lt;li&gt;The dog found out the way to open the door.&lt;/li&gt;
      &lt;li&gt;I am sure of his ability to cope with this.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-5-状语&quot;&gt;2-3-5 状语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;状语的作用：状语说明地点、时间、原因、目的、结果、条件、方向、程度、方式和伴随状语等。状语一般由副词、介词短语、分词和分词短语、不定式或相当于副词的词或短语来担当。其位置一般放在句首，但也可放在句末或句中。状语是一种用来修饰动词，形容词，副词或全句的词，说明时间，地点，程度，方式等概念。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;表示目的&lt;/p&gt;

    &lt;p&gt;不定式用作目的状语时，常常翻译成”为了”，”目的是”。&lt;/p&gt;

    &lt;p&gt;不定式用作目的状语&lt;strong&gt;&lt;em&gt;常放在句首和句末&lt;/em&gt;&lt;/strong&gt;。一般说来，用于句首属于强调性用法，即强调动词的目的。&lt;/p&gt;

    &lt;p&gt;有时为了&lt;strong&gt;&lt;em&gt;特别强调目的状语，可以在不定式之前加上 in order 或 so as，即构成 in order to do sth.和 so as to do sth. 结构&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;To finish my work, I worked overtime late into the night last Friday.&lt;/li&gt;
      &lt;li&gt;He worked day and night to get the money.&lt;/li&gt;
      &lt;li&gt;She sold her hair to buy the watch chain.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;注意不定式放句首时，逻辑主语与句子主语要一致。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;wrong: To save money, every means has been tried.&lt;/li&gt;
      &lt;li&gt;right: To save money, he has tried every means.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表示结果&lt;/p&gt;

    &lt;p&gt;不定式作结果状语只限于下面几个词：&lt;strong&gt;&lt;em&gt;learn（得知），find（发现），see（看见），hear（听见），to be told（被告知），make（使得&lt;/em&gt;&lt;/strong&gt;）等。&lt;/p&gt;

    &lt;p&gt;only + 不定式常表示出乎意料的结果。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I hurried to the library only to find it is closed.&lt;/li&gt;
      &lt;li&gt;He arrived late only to find the train had gone.&lt;/li&gt;
      &lt;li&gt;I visited him only to find him out.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表示原因&lt;/p&gt;

    &lt;p&gt;不定式作原因状语主要&lt;strong&gt;&lt;em&gt;用于表示情绪与心理状态的动词或形容词&lt;/em&gt;&lt;/strong&gt;，表示人对某事某物的反应如何，常译作“因……而……”。&lt;/p&gt;

    &lt;p&gt;常见的这类形容词有 able（有能力的），afraid（害怕的），cruel（残忍的），possible（可能的），proud（自豪的），unable（没能力的），useless（没用的），willing（愿意的）等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I am so glad to hear the news .&lt;/li&gt;
      &lt;li&gt;They were very sad to hear the news.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表示程度&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;It’s too dark for us to see anything.&lt;/li&gt;
      &lt;li&gt;The question is simple for him to answer.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-6-宾语补足语&quot;&gt;2-3-6 宾语补足语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;宾语补足语指有些及物动词，接了宾语意义仍不完整，还需要有一个其他的句子成分，来补充说明宾语的意义、状态等，简称宾补。
宾语和它的补足语构成复合宾语。而复合宾语的第一部分通常由名词或代词充当，第二部分表示第一部分的名词或代词发出的动作或身份、特征等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在复合宾语中，动词不定式可充当宾语补足语，如下动词常跟这种复合宾语: want, wish, ask, tell, order, beg, permit, help, advise, persuade, allow, prepare, cause, force, call on, wait for, invite…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Father will not allow us to play on the street.&lt;/li&gt;
  &lt;li&gt;We believe him to be guilty.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，介词有时也与这种复合宾语连用:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;With a lot of work to do, he didn’t go to the cinema.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;有些动词如 make, let, see, watch, hear, feel, have 等与不带有 to 的不定式连用，但改为被动语态时，不定式要加 to&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I saw him cross the road.&lt;/li&gt;
  &lt;li&gt;He was seen to cross the road.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-动名词&quot;&gt;3-动名词&lt;/h1&gt;
&lt;h2 id=&quot;3-1-介绍&quot;&gt;3-1-介绍&lt;/h2&gt;

&lt;p&gt;动名词是由动词变化而来，一方面保留着动词的某些特征，具有动词的某些变化形式，用以表达名词所不能表达的较为复杂的意念；另一方面动名词在句子的用法及功能与名词类同: 在句子中可以作主语、宾语、表语、定语，它也可以被副词修饰或者用来支配宾语。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;既有动词的变化形式，又具有名词的用法&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-2-用法&quot;&gt;3-2-用法&lt;/h2&gt;

&lt;h3 id=&quot;3-2-1-主语&quot;&gt;3-2-1 主语&lt;/h3&gt;

&lt;p&gt;动名词做主语，&lt;strong&gt;谓语动词用单数&lt;/strong&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;直接位于句首做主语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Swimming is a good sport in summer.&lt;/li&gt;
      &lt;li&gt;Fighting broke out between the South and the North.&lt;/li&gt;
      &lt;li&gt;Breathing became difficult at that altitude.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;用 it 作形式主语&lt;/strong&gt;，把&lt;strong&gt;动名词&lt;/strong&gt;(真实主语)&lt;strong&gt;置于句尾作后置主语&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;动名词做主语时，不太常用 it 作先行主语，多见于某些形容词及名词之后。常见的能用于这种结构的形容词还有：good，better，wonderful, enjoyable，interesting，foolish，difficult，useless，senseless，worthwhile，等。但是 important，essential，necessary 等形容词不能用于上述结构。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;It is no use waiting for him any longer.&lt;/li&gt;
      &lt;li&gt;It is no good learning without practice.&lt;/li&gt;
      &lt;li&gt;It is dangerous using this method to measure the speed of light.&lt;/li&gt;
      &lt;li&gt;It is worthwhile consulting your tutor about it again.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用于 “&lt;strong&gt;There be” 结构&lt;/strong&gt;中
    &lt;ul&gt;
      &lt;li&gt;There is no saying when he’ll come. 很难说他何时回来&lt;/li&gt;
      &lt;li&gt;There is no joking about such matters.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用于&lt;strong&gt;布告形式的省略结构&lt;/strong&gt;中
    &lt;ul&gt;
      &lt;li&gt;No smoking. =  Smoking is not allowed here.&lt;/li&gt;
      &lt;li&gt;No parking.  = parking is not allowed here.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动名词的复合结构作主语&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当动名词有自己的逻辑主语时，常可以在前面加上一个&lt;strong&gt;名词或代词的所有格&lt;/strong&gt;，构成动名词的复合结构(此时，名词或代词的所有格做动名词的逻辑主语)。&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;His coming to help was a great encouragement to us.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-2-定语&quot;&gt;3-2-2 定语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;动名词一般为名词性，很少做定语，不过在&lt;strong&gt;&lt;em&gt;一些特殊的情况下可以用来表示所修饰名词的用途&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;sleeping bag&lt;/li&gt;
      &lt;li&gt;walking stick&lt;/li&gt;
      &lt;li&gt;drinking water&lt;/li&gt;
      &lt;li&gt;swimming pool&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有些动名词已经转化成了形容词，常用作定语修饰物，表示“令人……的”，如 exciting, shocking, puzzling, confusing, disappointing, discouraging, boring, tiring, moving, touching, interesting, satisfying, frightening, amazing 等
    &lt;ul&gt;
      &lt;li&gt;That must be a terrifying experience.&lt;/li&gt;
      &lt;li&gt;The experiment was an amazing success.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-3-宾语&quot;&gt;3-2-3 宾语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;一些动词后用动名词作宾语，如 finish 完成，enjoy享受，mind介意，suggest建议，practise练习，admit 承认，advise 建议，allow 允许，appreciate 感激，avoid 避免，consider 考虑，delay 推迟，deny 否认，discuss 讨论，dislike 不喜欢，enjoy 喜爱，escape 逃脱，excuse 原谅，fancy 设想， forbid 禁止，forgive 原谅，imagine 想像，keep 保持，mention 提及，mind 介意 miss 没赶上，pardon 原谅，permit 允许， prevent 阻止，risk 冒险，understand 理解
    &lt;ul&gt;
      &lt;li&gt;I admit breaking the window.&lt;/li&gt;
      &lt;li&gt;Try to imagine being on the moon.&lt;/li&gt;
      &lt;li&gt;He tried to escape being punished.&lt;/li&gt;
      &lt;li&gt;You shouldn’t keep thinking about it.&lt;/li&gt;
      &lt;li&gt;Would you mind going with her?&lt;/li&gt;
      &lt;li&gt;I can’t understand neglecting children like that.&lt;/li&gt;
      &lt;li&gt;We only missed seeing each other by five minutes.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有些动词短语后跟动名词作宾语，如 insist on, be worth，give up，object/objection to，put off，keep on，insist on，leave off，look forward to，think of, can’t help, be/get used to, spend…in ,can’t stand，feel like 等
    &lt;ul&gt;
      &lt;li&gt;Do you feel like going out for dinner with me tonight?&lt;/li&gt;
      &lt;li&gt;Chinese people are looking forward to holding the 27th Olympic games.&lt;/li&gt;
      &lt;li&gt;I am used to going to bed late and getting up late.&lt;/li&gt;
      &lt;li&gt;The professor was quite used to students’ being late for his lecture.&lt;/li&gt;
      &lt;li&gt;He put off making a decision till he had more information.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-4-表语&quot;&gt;3-2-4 表语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;动名词作表语时句子&lt;strong&gt;主语常是表示无生命的事物名词或 what 引导的名词性从句&lt;/strong&gt;。表语动名词与主语通常是对等的关系，表示主语的内容，&lt;strong&gt;主语、表语可互换位置&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果句中的主语和表语同为动词时，要注意保持两个动词在形式上的一致。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;Your task is cleaning the windows. = Cleaning the windows is your task.&lt;/li&gt;
      &lt;li&gt;What I hate most is being laughed at. = Being laughed at is what I hate most.&lt;/li&gt;
      &lt;li&gt;The most popular pastime is playing chess. = Playing chess is the most popular pastime.&lt;/li&gt;
      &lt;li&gt;The only thing that interests her is working. = Working is the only thing that interests her.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-现在分词&quot;&gt;4-现在分词&lt;/h1&gt;
&lt;h2 id=&quot;4-1-介绍&quot;&gt;4-1-介绍&lt;/h2&gt;

&lt;p&gt;分词分为现在分词与过去分词，均是非谓语动词。分词在句子中不能单独充当谓语，不过可以充当其他成分：定语，表语，补语，状语，并且&lt;strong&gt;&lt;em&gt;分词具有动词性质&lt;/em&gt;&lt;/strong&gt;，因此是类动词的一种。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;动名词只具有名词词性&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;现在分词一方面&lt;strong&gt;&lt;em&gt;具有动词特性，可以拥有自己的宾语与状语&lt;/em&gt;&lt;/strong&gt;；另一方面&lt;strong&gt;&lt;em&gt;具有形容词与副词的特性，可以充当定语，表语，补语，状语&lt;/em&gt;&lt;/strong&gt;。现在分词可以表示主动或者正在进行的动作。&lt;/p&gt;

&lt;h2 id=&quot;4-2-时态与语态&quot;&gt;4-2-时态与语态&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;时态&lt;/th&gt;
      &lt;th&gt;主动语态&lt;/th&gt;
      &lt;th&gt;被动语态&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;一般式&lt;/td&gt;
      &lt;td&gt;doing&lt;/td&gt;
      &lt;td&gt;being done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成式&lt;/td&gt;
      &lt;td&gt;having done&lt;/td&gt;
      &lt;td&gt;having been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;否定式&lt;/td&gt;
      &lt;td&gt;-ing 前加 not&lt;/td&gt;
      &lt;td&gt;-ing 前加 not&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;现在分词的&lt;strong&gt;一般式通常表示其动作与谓语动词同时发生；完成式表示其动作在谓语动词的动作发生之前完成；被动式表示其逻辑主语为现在分词动作的承受者&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;She sat there reading a novel.&lt;/li&gt;
  &lt;li&gt;Having finished her homework, the little girl began to watch TV.&lt;/li&gt;
  &lt;li&gt;The building being built is our library.&lt;/li&gt;
  &lt;li&gt;Having been warned by the teacher, the students didn’t make such mistakes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-3-用法&quot;&gt;4-3-用法&lt;/h2&gt;

&lt;h3 id=&quot;4-3-1-定语&quot;&gt;4-3-1 定语&lt;/h3&gt;

&lt;p&gt;现在分词作定语，表示&lt;em&gt;正在进行的或主动的动作，也可以说明被修饰词的性质和特征&lt;/em&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;现在分词单独做定语，通常放在所修饰词之前
    &lt;ul&gt;
      &lt;li&gt;The sleeping boy is Tom.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;现在分词短语作定语，通常放在所修饰词的后面，类似于定语从句
    &lt;ul&gt;
      &lt;li&gt;Tell the children playing outside not to make noise.&lt;/li&gt;
      &lt;li&gt;Tell the children who are playing outside not to make noise.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-2-表语&quot;&gt;4-3-2 表语&lt;/h3&gt;

&lt;p&gt;现在分词作表语，通常表示主语的特征。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The story is moving.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-3-3-宾语补足语&quot;&gt;4-3-3 宾语补足语&lt;/h3&gt;

&lt;p&gt;现在分词作宾语补足语，表示正在进行的或主动进行的动作，与&lt;strong&gt;&lt;em&gt;前边的宾语有逻辑上的“主表“或”主谓“关系&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We all found his equipment interesting. (主表关系)&lt;/li&gt;
  &lt;li&gt;I saw Mary going upstairs then. (主谓关系)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-3-4-状语&quot;&gt;4-3-4 状语&lt;/h3&gt;

&lt;p&gt;现在分词作状语时，可作时间、条件、结果、原因和伴随状语，表示正在进行的或主动的动作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;分词的逻辑主语就是主句的主语，因此要注意人称、时态和语态的一致性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;作原因状语，相当于原因状语从句
    &lt;ul&gt;
      &lt;li&gt;Being ill, Mary didn’t come to school yesterday.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作时间状语，相当于时间状语从句
    &lt;ul&gt;
      &lt;li&gt;Seeing their teacher coming, the students stopped talking.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作条件状语，相当于条件状语从句
    &lt;ul&gt;
      &lt;li&gt;Working harder, you’ll be No. 1 in your class.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作让步状语，相当于让步状语从句
    &lt;ul&gt;
      &lt;li&gt;Weighing almost two hundred pounds, the stone was moved by him alone.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作结果状语，相当于结果状语从句
    &lt;ul&gt;
      &lt;li&gt;He died, leaving nothing but debts.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作伴随状语，相当于伴随状语从句
    &lt;ul&gt;
      &lt;li&gt;Look at the people lying on the beach.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作方式状语，相当于伴随状语从句
    &lt;ul&gt;
      &lt;li&gt;Please answer the question using another way.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-5-独立成分&quot;&gt;4-3-5 独立成分&lt;/h3&gt;

&lt;p&gt;现在分词作独立成分，即独立主格。常见形式有：generally speaking(一般来说), Judging form/by (由…判断)。&lt;/p&gt;

&lt;p&gt;独立主格没有主语和谓语，只有逻辑上的主语，因此，它在句法上不是句子，而是一个独立于句子成分外的独特结构形式。&lt;/p&gt;

&lt;p&gt;独立主格结构可置于句首或者句尾，用逗号与主句隔开；形式为：&lt;strong&gt;名词/名词短语/代词 + 不定式/ing分词/ed分词/形容词/副词/介词短语（名词前也可以加with）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;独立主格结构主要用于描绘性文字中，其作用相当于一个状语从句，常用来表示时间、原因、条件、行为方式或伴随情况等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;表示时间
    &lt;ul&gt;
      &lt;li&gt;The meeting being over, all of us went home.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示条件
    &lt;ul&gt;
      &lt;li&gt;The condition being favorable, he may succeed.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示原因
    &lt;ul&gt;
      &lt;li&gt;There being no taxis, we had to walk.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示伴随情况
    &lt;ul&gt;
      &lt;li&gt;Almost all metals are good conductors, silver being the best of all.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示补充说明
    &lt;ul&gt;
      &lt;li&gt;We redoubled our efforts, each man working like two.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-什么是非谓语动词 1-1-介绍</summary></entry><entry><title type="html">Distributed Systems</title><link href="http://localhost:4000/distributed-systems.html" rel="alternate" type="text/html" title="Distributed Systems" /><published>2022-03-07T00:00:00+08:00</published><updated>2022-03-07T00:00:00+08:00</updated><id>http://localhost:4000/distributed-systems</id><content type="html" xml:base="http://localhost:4000/distributed-systems.html">&lt;blockquote&gt;
  &lt;p&gt;翻译自 DDIA 作者 Martin Kleppmann 分布式系统课程：&lt;a href=&quot;https://www.youtube.com/watch?v=UEAMfLPZZhE&amp;amp;list=PLeKd45zvjcDFUEv_ohr_HdUFe97RItdiB&quot;&gt;视频&lt;/a&gt;; &lt;a href=&quot;https://www.cl.cam.ac.uk/teaching/2122/ConcDisSys/dist-sys-notes.pdf&quot;&gt;课件&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;1-introduction&quot;&gt;1-Introduction&lt;/h1&gt;

&lt;p&gt;运行在同一个进程中的多个线程共享同一个地址空间，因此单台计算机上的并发也被称为“共享内存并发”（shared-memory concurrency）。在这种模式下，很容易将数据从一个线程传递到另一个线程：比如指针（pointer），变量（variable）。&lt;/p&gt;

&lt;p&gt;在分布式系统中，上述场景就有所不同了。分布式系统中虽然仍存在并发（不同的计算机可以并发执行同一个应用程序），但这些计算机通常不会共享内存（每个计算机都有自己的地址空间，访问自己的内存），此时节点之间只能通过网络进行通信（network）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在一些超级计算机和科研系统中存在有限形式的共享内存模型，比如 RDMA（remote directly memory access）技术可以使得不同计算机通过网络互相访问内存；数据库（database）在某种程度上也可以被看作是共享内存模型，只不过与常见的字节寻址模型不同。总体来说，大部分分布式系统都是基于消息传递（message-passing）。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;分布式系统中的每个节点被称为 Node。Node 含义比较广泛，可以是任何通信计算设备：如桌面计算机，数据中心的服务器，移动设备，网联车，传感器等。&lt;/p&gt;

&lt;p&gt;关于分布式系统，Lamport 给出的定义是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a system in which the failure of a computer you didn’t even know existed can render your own computer unusable.&lt;/li&gt;
  &lt;li&gt;multiple computers communicating via a network&lt;/li&gt;
  &lt;li&gt;trying to achieve some task together&lt;/li&gt;
  &lt;li&gt;Consists of “nodes” (computer, phone, car, robot, . . . )&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-1-about-distributed-systems&quot;&gt;1-1 About distributed systems&lt;/h2&gt;

&lt;p&gt;为什么要使用分布式系统？有以下原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一些应用本质上就是分布式的（intrinsically distributed）：比如手机之间发送短信，该过程不可避免地要求不同手机间通过网络交互&lt;/li&gt;
  &lt;li&gt;提高可靠性（more reliably）：如果系统中只有一个节点，该节点可能会故障，偶尔需要重启，那么系统就继续提供服务。但是如果系统中存在多个节点，当某个节点重启时，其他节点能够继续提供服务。所以，分布式系统要比单点系统更可靠。&lt;/li&gt;
  &lt;li&gt;提升系统性能（performance）：假设一个服务被世界各地的用户访问，如果该服务是单点系统，那么总有一些地区的用户会觉得服务响应很慢，体验很差。如果该服务是分布式系统，可以将系统节点分布在世界各地，通过将用户路由到最近的节点以提高访问速度。&lt;/li&gt;
  &lt;li&gt;提升系统处理能力（solve bigger problems）：随着数据规模增大，处理任务增多，单节点可能无法承载，或者处理速度很慢。通过将任务分散到不同的节点，以提高系统整体处理能力。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然而，分布式系统也存在不足：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;网络异常（network failure）：网络异常时，节点间将无法正常通信&lt;/li&gt;
  &lt;li&gt;节点自身异常（node failure）：节点可能会崩溃（crash），运行过慢，或者由于软件硬件方面的异常导致不符合预期。如果我们想要实现故障转移，我们首先需要能够检测（detect）到故障确实发生了；而准确检测故障并不是一件容易的事&lt;/li&gt;
  &lt;li&gt;网络故障及节点异常经常会发生，系统需要能够处理这些异常&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在单点系统中，如果出现硬件异常，通常我们不会期望服务仍能正常运行，因此不会对这些异常在软件层面做额外的处理。但是在分布式系统中，我们需要容忍部分节点异常：一些节点不可用时，其他节点能够继续提供服务。&lt;/p&gt;

&lt;p&gt;我们把系统组件故障称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fault&lt;/code&gt;，分布式系统需要能够容忍部分组件故障（ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fault tolerance&lt;/code&gt;）：尽管存在故障，整个系统仍然能够正常运行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不过，故障处理通常比较难&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-2-distributed-systems-and-computer-networking&quot;&gt;1-2 Distributed systems and computer networking&lt;/h2&gt;

&lt;p&gt;学习分布式系统，通常需要对硬件进行抽象。&lt;/p&gt;

&lt;p&gt;我们假设节点间通过某种方式通信，而不关心消息如何被编码，通过何种方式发送等物理层表现方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从分布式系统的角度看，我们只需要关注通信延迟（latency）与带宽（boundwith）即可。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;延迟：消息发送到接收的间隔&lt;/li&gt;
  &lt;li&gt;带宽：单位时间内能够被传输的数据量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分布式系统建立在基础设施之上，更专注于如何进行节点之间的协调，以共同完成任务。分布式系统算法主要关于节点发送什么消息，及节点如何处理收到的消息。&lt;/p&gt;

&lt;p&gt;浏览器访问网页是一个我们经常使用的分布式系统例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该例子中的节点有两种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;server：网络站点提供服务&lt;/li&gt;
  &lt;li&gt;client: 浏览器用于展示从站点加载的内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;加载网页时，浏览器发送 HTTP request message 到合适的 server 节点；收到请求后，server 返回携带网页内容的 response message（可能是 HTML 文档，图片，视频等）。&lt;/p&gt;

&lt;p&gt;HTTP 协议运行在 TCP 协议之上：当 HTTP 报文较大时，TCP 将 HTTP request 内容切分为适当大小的报文，对于接收到的 response 报文段会重新拼接。HTTP 允许多个 request &amp;amp; response 复用同一个 TCP 链接。&lt;/p&gt;

&lt;p&gt;网络通信协议有很多细节，然而当我们从分布式系统的角度观察时，具体细节并不重要：&lt;strong&gt;我们只需要把 request &amp;amp; response 分别看作一条消息，忽略底层网络实现&lt;/strong&gt;，使得事情变得更简单（独立于底层网络）。&lt;/p&gt;

&lt;h2 id=&quot;1-3-example-remote-procedure-calls-rpc&quot;&gt;1-3 Example: Remote Procedure Calls (RPC)&lt;/h2&gt;

&lt;p&gt;使用信用卡进行网络购物是另一个分布式系统的例子。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当我们进行购物付款时，就会通过网络给专门处理信用卡支付的服务发送请求&lt;/li&gt;
  &lt;li&gt;付款服务反过来会与发行信用卡的银行进行通信，以确保该信用卡能够完成支付&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在线购物的支付服务实现的代码可能如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Online shop handling customer's card details
Card card = new Card();
card.setCardNumber(&quot;1234 5678 8765 4321&quot;);
card.setExpiryDate(&quot;10/2024&quot;);
card.setCVC(&quot;123&quot;);

Result result = paymentsService.processPayment(card,
   3.99, Currency.GBP);
if (result.isSuccess()) {
   fulfilOrder();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processPayment&lt;/code&gt; 方法调用看起来与本地调用的其他方法类似，不过实际上是向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PaymentService&lt;/code&gt; 发送了一个网络请求并等待响应。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processPayment&lt;/code&gt; 方法需要与发行信用卡的银行进行交互，实现逻辑并不在本地，而是在其他节点。&lt;/p&gt;

&lt;p&gt;这种交互方式（一个节点的代码看起来是调用另一个节点的方法）被称为 &lt;strong&gt;Remote Procedure Call（RPC）&lt;/strong&gt;。在 Java 中，也被称为 Remote Method Invocation（RMI）。实现 RPC 的软件被称为 RPC Framework，或者 Middleware。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;并不是所有的中间件都基于 RPC 通信，还存在其他通信模型&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;当一个服务想要调用运行在其他节点上的方法时，&lt;strong&gt;RPC 框架会在 Client 本地创建 stub 来代替目标方法&lt;/strong&gt;。该 stub 的方法签名与真正的方法签名相同，但是并不真正执行方法，而是&lt;em&gt;将方法参数编码成特定的消息，并将该消息发送到远程节点，请求调用对应方法&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;方法参数编码的过程被称为 marshall；存在多种编码格式，比如 JSON&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;从 RPC Client 发送消息到 RPC Server 可能会使用不同的网络协议（如果使用 HTTP 协议，则被称为 Web Service）。在 Server 端，RPC 框架会解码收到的消息，并通过解析出的方法参数调用目标方法。当调用方法返回时，返回结果同样会被编码成消息发送给 Client。Client 收到后会解码并通过 stub 返回给调用方。因此，对 stub 的调用方来说，方法看起来是在本地执行并返回。&lt;/p&gt;

&lt;p&gt;对应在线支付的执行流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不过，由于网络或者节点可能会出现故障，RPC 实现时有许多问题需要考虑。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法调用期间，服务崩溃&lt;/li&gt;
  &lt;li&gt;消息传递过程中丢失了&lt;/li&gt;
  &lt;li&gt;消息延迟过大&lt;/li&gt;
  &lt;li&gt;调用出现问题时，能否进行安全重试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当 RPC Client 发送请求后却没有收到响应，Client 并不能确定 Server 是否收到消息。此时应该如何处理？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Client 可以进行重试，但是可能会导致请求被执行多次（如多次支付）；并且，我们也无法保证重试的消息能够成功被成功接收&lt;/li&gt;
  &lt;li&gt;Client 也不能长时间等待响应。因此，在实践中，Client 通常在超时之后放弃此次请求&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在过去几十年，RPC 发展了很多变体，包括面向对象的中间件（如 CORBA）。如今最常见的 RPC 形式是&lt;strong&gt;通过 HTTP 发送 JSON 格式数据&lt;/strong&gt;。这种基于 HTTP 的 API 设计原则被称为&lt;strong&gt;表示状态传输（Representational state transfer）或者 REST&lt;/strong&gt;，遵守该设计原则的 API 被认为 RESTful。具体协议包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;资源（resources）通过 URL 表示&lt;/li&gt;
  &lt;li&gt;使用标准方法类型的 HTTP 请求来更新资源状态（state），如 POST, PUT&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;REST 的兴起得益于运行在浏览器上的 JavaScript 代码可以很容易发送该请求。不过，虽然 RESTful API 或者其他以 HTTP 为基础的 RPC 是面向 Web 的，但是也可以用于其他类型的 Client 或者 Server-to-Server 的交互。&lt;/p&gt;

&lt;p&gt;Server-to-Server 交互场景在大型企业服务上比较常见：企业服务由于过大且复杂，以至于单台机器无法运行，因此常被拆分为多个服务。每个服务被不同的团队开发 &amp;amp; 管理，不同的服务可能使用不同的开发语言；RPC 框架实现了不同服务之间的交互。&lt;/p&gt;

&lt;p&gt;当相互通信的服务使用不同的开发语言时，RPC 框架需要能够转化数据类型，使得被调用方能够理解调用方的请求参数；对于返回值也是同样的。&lt;/p&gt;

&lt;p&gt;常见的解决方案是使用 Interface Definition Language（IDL）提供与编程语言无关的 RPC 方法签名。通过 IDL 可以自动生成 marshall &amp;amp; unmarshall 代码，同时可以生成与语言无关的 Server stubs &amp;amp; Client stubs。下面是 gRPC 的 IDL 示例：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message PaymentRequest {
	message Card {
		required string cardNumber = 1;
		optional int32 expiryMonth = 2;
		optional int32 expiryYear = 3;
	}
	
	required Card card = 1;
	required int64 amount = 2;
}

message PaymentStatus { 
	required bool success = 1;
	optional string errorMessage = 2;
}

// service
service PaymentService {
	rpc ProcessPayment(PaymentRequest) returns (PaymentStatus) {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-models-of-distributed-systems&quot;&gt;2-Models of distributed systems&lt;/h1&gt;

&lt;p&gt;系统模型是对系统中 nodes &amp;amp; network 行为的假设及属性的抽象。为了阐述通用的系统模型，先引用两个经典的模型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The Two Generals Problem&lt;/li&gt;
  &lt;li&gt;The Byzantine Generals Problem&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-1-the-two-generals-problem&quot;&gt;2-1 The two generals problem&lt;/h2&gt;

&lt;p&gt;问题描述：假设有两个将军，每人领导一个军队，并且这两个将军都想占领同一座城市。城市的防御很坚固，如果每次只有一个军队进攻，那么会进攻失败；如果两个军队同时进攻，则能够成功占领城市。因此，这两个将军需要协调他们的进攻计划。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目标：只有在军队 2 进攻的情况下，军队 1 才会发起进攻&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;不过，由于这两个军队之间存在一定的距离，彼此间通信只能依靠信使。信使需要通过由城市控制的区域，并且有时候会被捕获，那么消息就无法成功送达。对于发送方来说，&lt;strong&gt;&lt;em&gt;除非发送方收到接收方的明确回复，否则也不确定之前发送的消息是否成功被接收&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果一方没有收到消息，可能是对方确实没有发送消息，也可能是对方发送的所有消息都被截获了。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如何使这两个将军就进攻计划达成一致？对每个将军来说，有两种选择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;承诺在任何情况下都发起进攻&lt;/strong&gt;，即使没有收到对方的明确回复&lt;/p&gt;

    &lt;p&gt;这种情况下，发起进攻的将军可能会冒险独自进攻&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;直到收到对方明确回复才会发起进攻，否则就一直等待&lt;/p&gt;

    &lt;p&gt;这种情况相当于将问题抛给了对方：接收方需要决定是否等待回复消息的确认，还是回复之后就发起进攻（也可能会独自进攻）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;无法达成共识：只能通过消息传递来获取信息&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;两将军的问题在于，不管双方交换了多少次消息，也无法确定对方一定能同时进攻。对于分布式系统来说，&lt;strong&gt;一个节点无法准确判断另一个节点的状态；不过通过消息传递的方式，可以得到一些信息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;上面介绍的在线商店支付流程可以看作是两将军问题的例子：在线商店服务与信用卡支付服务之间通过 RPC 进行消息传递，并且消息可能会丢失；尽管如此，商店只有在商品被支付成功的情况下才会发货，支付服务只有在商品被发货才会进行扣款。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目标：只有商品被支付成功的情况下，在线商店才会发送货物&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;不过，实际上该流程与两将军问题有点不同：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;支付服务在任何情况下都可以先进行扣款操作，如果在线商店始终无法发送货物，可以再进行退款操作。由于&lt;strong&gt;支付操作可以撤回&lt;/strong&gt;，使得在两将军中的问题可以解决。&lt;/li&gt;
  &lt;li&gt;即使由于网络等问题导致在线商店服务暂时无法确定支付状态，可以在连接恢复之后再主动查询确定交易状态。发送方可以稍后再次确认之前的消息送达情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-2-the-byzantine-generals-problem&quot;&gt;2-2 The Byzantine generals problem&lt;/h2&gt;

&lt;p&gt;问题描述：拜占庭将军问题的设定与两将军问题类似。假设多个军队（可以是 3 个以上）需要占领一座城市，不同军队之间仍然通过信使进行通信，只不过此时消息总是能够被成功送达。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在拜占庭将军问题中，有些将军可能是叛徒：他们可能会故意误导及迷惑其他将军。我们把叛徒称为 “malicious”，其他将军称为 “honest”。&lt;/p&gt;

&lt;p&gt;malicious 可能有以下行为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将军 3 分别从将军 1 &amp;amp; 将军 2 收到两条矛盾的消息
    &lt;ul&gt;
      &lt;li&gt;将军 1 声明要进攻&lt;/li&gt;
      &lt;li&gt;将军 2 声明将军 1 想要撤退&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将军 3 无法确定将军 2 是否在撒谎
    &lt;ul&gt;
      &lt;li&gt;第一种场景，将军 2 在撒谎&lt;/li&gt;
      &lt;li&gt;第二种场景，由于将军 1 先后声明了两个矛盾的消息，此时将军 2 并没有撒谎&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;honest 并不知道哪些是 malicious，但是 malicious 之间可以秘密串通协调他们的行动。拜占庭将军问题的目标是需要确保&lt;strong&gt;所有的 honest 对计划达成一致&lt;/strong&gt;：不管是进攻还是撤退。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据设定，我们无法确定 malicious 的行动，所能做的只有让 honest 达成一致&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;然而由于 malicious 的存在及不可预测的通信延迟，使得上述目标很难实现；只有在 malicious 的数目严格少于 1/3 时，拜占庭问题才能得到解决。如果系统中存在 3*f+1 个节点，那么 malicious 数目不能多于 f。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过引入密码学会使得拜占庭将军问题变得相对简单，但是问题仍然存在，例如数字签名：将军 2 需要向将军 3 证明将军 1 的声明。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;那么拜占庭将军问题是否具有实际意义？&lt;/p&gt;

&lt;p&gt;在实际的分布式系统中，通常涉及比较复杂的信任关系。比如，消费者需要信任在线商店真的会发送订单中的商品，尽管消费者在商品无法送达或者其他原因向银行提出异议。但是如果在线商店允许消费者在不支付的情况下就可以下单，这种情况下可能会被欺诈者利用，因此在线商店会假设消费者是潜在的 malicious。另一方面，在线商店的多个服务同属一个数据中心，它们内部间基本互相信任，但是支付服务并不完全信任在线商店服务，因为其他人可能会设立欺诈性的商店或者使用被盗信用卡（不过在线商店服务通常信任支付服务）。最后，我们期望消费者，在线商店，支付服务就任何订单达成一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;拜占庭将军问题可以看作是复杂信任关系的简化&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在一些分布式系统中，会明确处理存在 malicious 节点的可能性，这类系统被称为 &lt;strong&gt;Byzantine fault tolerant&lt;/strong&gt;。近些年来，该观点在区块链及加密货币中逐渐流行起来：即使系统的一些参与者试图欺骗或破坏系统，系统也能提供明确的保证。&lt;/p&gt;

&lt;h2 id=&quot;2-3-describing-nodes-and-network-behavior&quot;&gt;2-3 Describing nodes and network behavior&lt;/h2&gt;

&lt;p&gt;当设计分布式算法时，system model 是对可能发生故障的假设。上文描述了两种 system model：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Two generals problem: a model of networks&lt;/li&gt;
  &lt;li&gt;Byzantine generals problem: a model of node behavior&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 system model 中传递的消息被捕获可能因为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Network behavior：消息丢失等&lt;/li&gt;
  &lt;li&gt;Node behavior：节点崩溃等&lt;/li&gt;
  &lt;li&gt;Timing behavior：延迟等&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-1-network-behavior&quot;&gt;2-3-1 Network behavior&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;不存在完全可靠的网络&lt;/strong&gt;：即使是在精心设计且有冗余连接的网络中。
大多数分布式算法都假设网络在一对节点间提供双向通信服务，被称为&lt;strong&gt;点对点通信（point-to-point）&lt;/strong&gt;或者&lt;strong&gt;单播通信（unicast）&lt;/strong&gt;。在真实的网络中有时确实提供&lt;strong&gt;广播（broadcast）&lt;/strong&gt;或&lt;strong&gt;多播（multicast）&lt;/strong&gt;通信（&lt;em&gt;一个数据包同时发送给多个接收者&lt;/em&gt;）。不过，通常来说，假设只存在单播（unicast）是一个比较好的网络模型。&lt;/p&gt;

&lt;p&gt;接下来我们可以假设网络的可靠性，大部分算法假设如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Reliable&lt;/strong&gt; (perfect) links
只有在消息被发送时，才会收到消息。不过，消息可能会被重排序。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fair-loss&lt;/strong&gt; links
消息可能会丢失，重复或重排序。如果继续重试，消息最终会被成功发送。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Arbitrary&lt;/strong&gt; links (active adversary)
存在 malicious 节点干扰信息传递（窃听，篡改，丢弃，伪造，重放等）。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;网络分区&lt;/strong&gt;（network partition）：一些连接长时间丢弃或延迟所有消息&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;我们可以将上述某些类型的网络转换为其他类型，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如当前网络类型为 Fair-loss link，通过持续发送丢失的消息直到被成功接收，及在接收方过滤重复的消息，可以将 Fair-loss link 类型转换为 Reliable link 类型。&lt;/p&gt;

&lt;p&gt;Fair-loss 类型意味着网络分区（network partition）只会持续一段时间，并不是永久故障；所以消息最终一定会被接收。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不过，网络分区期间发送的消息只能等到故障恢复之后才能被接收，而故障的时间可能比较长&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;之前提到的 TCP 协议在网络数据包层面提供了重试及重复数据过滤的机制，不过 TCP 通常配置了超时时间，在重试了一个确定的时间之后就会放弃重试（一般为 1min）。因此为了应对较长时间的网络分区（network partition），需要在 TCP 之上额外实现一套重试及重复数据过滤机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary 类型是互联网通信的准确模型&lt;/strong&gt;：每当你通过互联网进行通信时（可能是通过咖啡店的 wifi），网络运营商可以任意操作 &amp;amp; 干扰你的网络数据包。操作网络流量的人也被称为 active adversary。不过，通过使用加密技术&lt;strong&gt;&lt;em&gt;几乎（almost）&lt;/em&gt;&lt;/strong&gt;可以将 Arbitrary 类型的网络转换为 Fair-loss 类型。&lt;strong&gt;TLS&lt;/strong&gt;（Transport Layer Security）协议可以防止 active adversary 进行窃听，篡改，伪造，重放流量等操作。不过，TLS 唯一不能阻止 active adversary 进行丢弃（dropping/blocking）网络包操作。所以，只有在 active adversary 永远不会进行 block 操作时，才能将 Arbitrary 类型的网络转换为 Fair-loss 类型。&lt;/p&gt;

&lt;p&gt;Reliable 类型的网络看起来并不是不可实现：&lt;strong&gt;一般来说，只要我们在网络分区期间等待一段时间后进行重试，所有消息都能被成功接收&lt;/strong&gt;。不过，我们也需要考虑消息发送者在重试期间崩溃（crash）的情况，这种情况下消息会永远丢失（permanently lost）。&lt;/p&gt;

&lt;h3 id=&quot;2-3-2-node-behavior&quot;&gt;2-3-2 Node behavior&lt;/h3&gt;

&lt;p&gt;假设每个节点运行模型的算法都为下面的一种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Crash-stop&lt;/strong&gt; (fail-stop)
如果节点在任意时刻崩溃，则出现故障。崩溃之后，节点永久性地停止运行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Crash-recovery&lt;/strong&gt; (fail-recovery)
节点可能在任意时刻崩溃，导致内存数据会丢失，不过持久化到磁盘上的数据并不会丢失。节点可能在一段时间后重新恢复运行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Byzantine&lt;/strong&gt; (fail-arbitrary)
如果节点偏离运行的算法，则出现故障（A node is faulty if it deviates from the algorithm）。故障节点的表现可能有：崩溃或者一些恶意行为。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;不存在故障的节点被称为正常节点（A node that is not faulty is called “correct”）。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在 &lt;strong&gt;Crash-stop&lt;/strong&gt; 模型中，我们假设节点崩溃之后，永远不会恢复。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于无法恢复的硬件故障来说，这是一种合理的模型（reasonable）&lt;/li&gt;
  &lt;li&gt;对于软件崩溃，Crash-stop 模型看起来不太符合，因为在节点重启之后，将会恢复。尽管如此，一些算法为了简化问题，仍然将其看作 Crash-stop 模型。在这种情况下，崩溃后恢复的节点被认为是重新加入系统中的新节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 &lt;strong&gt;Crash-recovery&lt;/strong&gt; 模型中，允许节点崩溃后重启并恢复运行。当节点崩溃重启时，假设内存中的数据全部丢失，但是持久化到磁盘上的数据都会被保存下来。&lt;strong&gt;&lt;em&gt;该模型对节点崩溃后恢复所需要的时间并没有设定，因此崩溃后的节点可能永远都不会恢复&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Byzantine&lt;/strong&gt; 模型是最常见的节点行为模型：正如拜占庭将军问题中的描述，&lt;em&gt;故障节点也许不仅仅是崩溃，也可能以任何方式偏离指定的算法，包括一些恶意行为&lt;/em&gt;。节点服务实现中的错误（bug）也可以归类为拜占庭故障。不过，如果所有节点运行同样的软件，那么这些节点就会有同样的 bug。因此，任何基于拜占庭故障节点数少于 1/3 的算法都无法容忍此类 bug。因此，当涉及到偏离指定算法时，我们通常称为拜占庭问题，而不是 bug。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原则上，我们可以尝试使用同一算法的几种不同的实现，不过这并不是比较实际的选择。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在 network behavior 的介绍中，通过使用特定的协议可以将一种网络模型转换为另一种。不过，在 node behavior 中并不适用；比如，为 Crash-recovery 模型设计的算法与 Byzantine 模型有很大不同。&lt;/p&gt;

&lt;h3 id=&quot;2-3-3-synchrony-timing-assumptions&quot;&gt;2-3-3 Synchrony (timing) assumptions&lt;/h3&gt;

&lt;p&gt;对于同步（计时）模型的假设如下所示：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Synchronous&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;消息延迟不会大于已知的上限。节点以已知的速度执行算法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Partially synchronous&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;系统在某些有限（但未知）的时间内是异步的，否则是同步的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Asynchronous&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;消息延迟时间不定。节点可以在任意时间暂停执行。完全没有时间保证。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;上述术语在其他上下文中具有不同的含义。如，在 RPC &amp;amp; IO 操作中，synchronous 表示调用方会被阻塞直到操作完成；asynchronous 表示调用方在发出请求后继续执行，而不需要等待操作完成&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Synchronous&lt;/strong&gt; 模型是指&lt;strong&gt;&lt;em&gt;通过网络发送的消息延迟永远不会大于已知的最大延迟，并且节点总是以可预测的速度执行&lt;/em&gt;&lt;/strong&gt;。Synchronous 系统的假设会使得分布式计算问题变得简单，并且由于大部分时间（most of time）节点及网络都表现良好，因此该假设大部分情况下没有问题。&lt;/p&gt;

&lt;p&gt;然而，大部分时间表现良好并不代表一直如此。如果系统在某段时间内违反了有界延迟与有界执行速度的假设，那么为 Synchronous 模型设计的算法就会崩溃。在实际系统中，网络延迟与执行速度由于各种原因会导致差异比较大。&lt;/p&gt;

&lt;p&gt;另一个极端的假设是 &lt;strong&gt;Asynchronous&lt;/strong&gt; 模型（不对延迟做任何假设）：&lt;strong&gt;&lt;em&gt;消息在网络中的延迟可以是任意的，不同节点执行速度的差异是任意的&lt;/em&gt;&lt;/strong&gt;（如允许某个节点在其他节点正常运行的时候暂停执行）。为 Asynchronous 模型设计的算法通常非常健壮，因为可以不受任何临时网络中断或延迟峰值的影响。&lt;/p&gt;

&lt;p&gt;不过，Asynchronous 模型并不能解决分布式系统中的全部问题，因此我们使用 &lt;strong&gt;Partially Synchronous&lt;/strong&gt; 模型作为折中方案。在 Partially Synchronous 模型中，假设&lt;strong&gt;&lt;em&gt;大部分情况下（most of time）系统表现良好，表现为 Synchronous；偶尔，可能会切换到 Asynchronous，其中所有定时保证都失效（该情况可能随时发生）&lt;/em&gt;&lt;/strong&gt;。Partially Synchronous 模型对许多实际的系统都比较适用，不过想要正确使用需要多加小心。&lt;/p&gt;

&lt;h3 id=&quot;2-3-4-violations-of-synchrony-in-practice&quot;&gt;2-3-4 Violations of synchrony in practice&lt;/h3&gt;

&lt;p&gt;网络通常具有可预测的延迟，不过偶尔延迟会增大，从而导致系统违背 Synchronous 模型，具体原因可能有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;消息丢失或者重试，导致延迟大幅增加&lt;/li&gt;
  &lt;li&gt;在网络分区修复前，消息不能被成功传递&lt;/li&gt;
  &lt;li&gt;如果网络阻塞导致数据包在交换机缓冲区中排队等待，也会增加延迟&lt;/li&gt;
  &lt;li&gt;网络重新配置同样会增大延迟，即使是在同一个数据中心，也可能会导致延迟超过一分钟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同样，节点通常也会以恒定的速度执行程序代码，偶尔也会因为意外导致程序暂停执行（pause）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;操作系统调度问题：正在运行的进程可能会被抢占，导致暂停，尤其当机器处于高负载的情况下&lt;/li&gt;
  &lt;li&gt;对于一些实现内存管理的语言，比如 Java，当垃圾回收器在运行的时候，需要时不时地暂停正在运行的线程（垃圾回收可能会长达几分钟）&lt;/li&gt;
  &lt;li&gt;缺页中断也会导致线程挂起，尤其是没有多少空闲内存时&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要注意，此处说的 pause 与前文对节点行为描述中的 crash 并不相同。暂停中的进程通常没有意识到自己处于暂停状态，虽然其他节点在没有收到暂停节点的响应时，可能认为其已经崩溃。但是，过了一段时间，暂停的进程会重新恢复运行。另外，重启崩溃的节点需要由程序显示处理，因为其内存状态已经完全丢失，需要从磁盘中重新加载持久化数据；而暂停的进程内存数据并没有丢失&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;综合以上多种原因，如果假设一个系统为 Synchronous 模型，可能并不安全。&lt;strong&gt;因此，大多数分布式系统需要被设计成 Partially synchronous 或者 Asynchronous。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-3-5-system-models-summary&quot;&gt;2-3-5 System models summary&lt;/h3&gt;

&lt;p&gt;在设计分布式系统模型时，需要对网络，节点行为，同步类型等进行合理假设，这些是分布式算法的基础：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Network: reliable, fair-loss, or arbitrary&lt;/li&gt;
  &lt;li&gt;Node: crash-stop, crash-recovery, or Byzantine&lt;/li&gt;
  &lt;li&gt;Timing: synchronous, partially synchronous, or asynchronous&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-4-fault-tolerance-and-high-availability&quot;&gt;2-4 Fault tolerance and high availability&lt;/h2&gt;

&lt;p&gt;对于网站来说，服务的可用性（availability）可能是最重要的。比如，在线商店想要在任何时候都能售卖产品：网站的中断意味着失去赚钱的机会。对于其他服务来说，可能与客户签订了协议保证服务的可用性，如果服务不可用会对其声誉造成损失。&lt;/p&gt;

&lt;p&gt;服务的可用性通常&lt;strong&gt;根据其在特定时间内正确响应请求的能力来衡量&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如何定义服务是可用的还是不可用：如果网站加载网页需要 5s，那么我们认为服务是可用的吗？如果耗时 30s, 1h 呢？服务的可用性预期被定义为 &lt;strong&gt;Service-Level Objective (SLO)：需要在指定超时时间内返回正确响应的请求的百分比&lt;/strong&gt;（由特定客户端在特定时间内测量）。Service-Level Aggrement (SLA) 是规定了一些 SLO 的协议，以及没有满足 SLO 的后果。&lt;/p&gt;

&lt;h3 id=&quot;2-4-1-fault-tolerance&quot;&gt;2-4-1 Fault tolerance&lt;/h3&gt;

&lt;p&gt;故障（faults，如节点崩溃或者网络中断）是影响可用性的常见原因。为了提高可用性，我们可以减少故障发生的频率，或者将系统设计成&lt;strong&gt;&lt;em&gt;即使某些组件故障，仍能继续提供服务&lt;/em&gt;&lt;/strong&gt;，这种方式被称为&lt;strong&gt;容错（fault tolerance）&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过购买高质量的硬件，同时引入冗余，可以降低故障发生的频率，但是这种方式并不能完全杜绝故障发生；因此，需要系统都采用容错的方式提高可用性。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;容错总是相对于最大容忍的故障节点数量&lt;/strong&gt;：一些分布式算法能够在崩溃节点数量少于一半的情况下继续运行，但是如果超过一半节点故障，则无法运行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;想要容忍没有限制的节点故障没有意义：当所有节点崩溃且无法恢复时，没有算法能够继续运行。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在某些系统中，单个组件的故障可能会导致整个系统的中断，这种组件被称为&lt;strong&gt;单点故障（single point of failure, SPOF）&lt;/strong&gt;。&lt;strong&gt;容错系统通常需要避免单点故障&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在这里，我们需要区分下 Fault &amp;amp; Failure:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Fault: 系统的某一部分不可用，可能是由于节点故障或者网络故障导致&lt;/li&gt;
  &lt;li&gt;Failure: 整个系统不可用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-4-2-failure-detection&quot;&gt;2-4-2 Failure detection&lt;/h3&gt;

&lt;p&gt;为了实现容错，首先需要能够检测故障，由故障检测器（failure detector）完成。故障检测器通常能够检测到节点崩溃故障，但是对于拜占庭（Byzantine）故障并不能总是检测出：虽然在某些 Byzantine 行为下会留下一些证据用于识别 malicious 节点。&lt;/p&gt;

&lt;p&gt;大部分情况下，故障检测器周期性地向其他节点发送消息，如果在预期时间内没有收到响应则将节点标记为崩溃（crash）。理想情况下，我们期望只有在节点真正崩溃时才会检测超时（这种检测器被称为 perfect failure detector）。但是，两将军问题表明这并不是一种完全准确的检测方式，没有收到响应可能是因为消息丢失（message loss）或者延迟（delay）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;基于超时检测的 perfect failure detector 只存在于具有可靠网络连接的同步（synchronous）且崩溃中止（crash-stop）系统中&lt;/em&gt;&lt;/strong&gt;。在异步（asynchronous）系统中，超时并不具备实际意义，因此也就不存在基于超时的故障。在部分同步（partially synchronous）系统中，不存在 perfect failure detector；但是存在另一种有用的故障检测器：eventually perfect failure detector。&lt;/p&gt;

&lt;p&gt;对于 eventually perfect failure detector，表现有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;可能暂时（temporarily）将一个正常（correct）的节点标记为崩溃（crash）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;可能暂时（temporarily）将一个崩溃（crash）的节点标记为正常（correct）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;但是最终（eventually），当且仅当节点已经崩溃了，才会将其标记为崩溃&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;从中我们可以看到，检测并不是瞬时的，可能会存在错误的检测结果&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;后面将继续介绍如何使用这种故障检测器来设计容错机制，以及如何从节点崩溃中自动恢复。&lt;/p&gt;

&lt;h1 id=&quot;3-time-clocks-and-ordering-of-events&quot;&gt;3-Time, clocks, and ordering of events&lt;/h1&gt;

&lt;p&gt;在分布式系统中，我们经常需要测量时间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;基于超时的故障检测器需要计算时间用于决定检测是否超时&lt;/li&gt;
  &lt;li&gt;操作系统广泛依赖计时器用于任务调度，CPU 使用情况追踪等&lt;/li&gt;
  &lt;li&gt;应用程序通常会记录事件发生的事件，我们可以根据这些时间重建不同节点上同时发生的事件；或者判断不同节点不同事件发生的顺序&lt;/li&gt;
  &lt;li&gt;在日志文件和数据库中，也需要记录事件发生的时间&lt;/li&gt;
  &lt;li&gt;内存中的缓存需要有一定的实效性（过期失效）&lt;/li&gt;
  &lt;li&gt;应用性能测量&lt;/li&gt;
  &lt;li&gt;….&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们将区分两种类型的时钟：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;物理时钟（physical clocks）&lt;/strong&gt;：计算真实时间（count number of seconds elapsed）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;逻辑时钟（logical clocks）&lt;/strong&gt;：计算事件（count events, e.g. messages sent）&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：数字时钟（振荡器）不等于分布式系统中的时钟（时间戳）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-1-physical-clocks&quot;&gt;3-1 Physical clocks&lt;/h2&gt;

&lt;p&gt;物理时钟以秒为单位测量时间。物理时钟包括基于钟摆或者类似钟摆机制的模拟或机械时钟（analogue/mechanical clocks），也包括基于石英晶体震荡的数字时钟（digital clocks）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;物理时钟有时候也被称为挂在墙上的时钟（wall clock）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;石英时钟出现在大部分手表，计算机，手机等物品中。石英时钟比较便宜，但是并不完全精确（accurate）。由于制造的缺陷，某些时钟可能要比其他的运行快/慢，并且石英震动频率受温度影响。&lt;/p&gt;

&lt;p&gt;时钟震荡频率的快慢被称为&lt;strong&gt;漂移（drift）&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;漂移以 parts per million (ppm)为单位进行测量&lt;/li&gt;
  &lt;li&gt;1 ppm = 1 microsecond/second = 86 ms/day = 32 s/year&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;大部分计算机的时钟精度大约在 50ppm 以内&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-1-1-utc--tai&quot;&gt;3-1-1 UTC &amp;amp; TAI&lt;/h3&gt;

&lt;p&gt;如果需要提高时钟的精度，可以使用&lt;strong&gt;原子时钟（atomic clocks）&lt;/strong&gt;。原子时钟基于某些原子的量子力学特性，如铯或铷（&lt;strong&gt;International Atomic Time，TAI&lt;/strong&gt;，国际原子时间）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;事实上，国际单位制（SI）中一秒的时间单位被定义为铯-133 原子特定共振频率的9,192,631,770个周期。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;另一种获取高精度时钟的方法是依靠 GPS 等卫星定位系统。通过将 GPS 接收器连接到计算机，可以获得精确到几分之一微秒的时钟。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在数据中心，电磁干扰通常太大，无法获得良好的信号，因此 GPS 接收器需要在数据中心大楼的屋顶上安装天线&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;有一点需要指出，地球自转时间并不是严格的 24h，而且收到地震，潮汐等影响，自转周期并不固定。因此，基于量子力学的时钟（原子时钟）与基于天文学的时钟（日出日落）并不完全匹配。通过引入 &lt;strong&gt;UTC（Coordinated Universal Time）&lt;/strong&gt;解决这个问题：&lt;em&gt;UTC 基于原子时间，但包括考虑到地球自转变化的校正&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;日常生活中，我们使用的本地时区为 UTC 的偏移（offset）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;UTC 与 TAI 之间的区别是，UTC 包括了闰秒（leap seconds）。由于闰秒的存在，导致 1 小时不总是 3600 秒，1 天也不总是 86400 秒。在 UTC 时间范围内，1 天可能是 86399 秒，86400 秒或者 86401 秒。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;闰秒发生在每年 6 月 30 日与 12 月 31 日的 23:59:59 UTC&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;3-1-2-how-computers-represent-timestamps&quot;&gt;3-1-2 How computers represent timestamps&lt;/h3&gt;

&lt;p&gt;在计算机中，&lt;strong&gt;timestamp 用于表示一个特定的时间点&lt;/strong&gt;。有两种常见的表示 timestamp 的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Unix time&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ISO 8601&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于 Unix time，0 对应于 1970 年 1 月 1 日（UTC or GMT），也被称为 epoch。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 Java 中，存在一些微小的变化：Java 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.currentTimeMillis()&lt;/code&gt; 表示毫秒而不是秒&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Unix timestamp 直接忽略了闰秒&lt;/em&gt;，假装其不存在；并且这种方式也被 Posix 标准采用。对于那些只需要粗略计时的软件来说，这种方式是可行的，因为几秒的差异并不显著。&lt;/p&gt;

&lt;p&gt;然而，操作系统和分布式系统经常确实会依赖高精度 timestamp 来准确测量时间，其中 1s 的差异非常明显。这种情况下，如果直接忽略闰秒可能会存在风险。假如 Java 程序在闰秒内连续两次调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.currentTimeMillis()&lt;/code&gt; ，每次间隔 500ms。这两次调用结果之间的差值不会是 500，可能是 0，也可能是负数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2012 年 6 月 30 日闰秒处理不当是导致当天许多服务同时失败的原因&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如今，许多软件都额外处理闰秒，比较实用的方法是：当闰秒发生时，并不是在 23:59:59 与 00:00:00 之间插入 1s，而是将这 1s 分散到其他时间段内，可能会加快/减慢时钟的速度。这种fang 被称为抹平（smearing）闰秒。&lt;/p&gt;

&lt;h2 id=&quot;3-2-clock-synchronisation-and-monotonic-clocks&quot;&gt;3-2 Clock synchronisation and monotonic clocks&lt;/h2&gt;

&lt;h3 id=&quot;3-2-1-clock-synchronisation&quot;&gt;3-2-1 Clock synchronisation&lt;/h3&gt;

&lt;p&gt;由于原子时钟（atomic clocks）过于昂贵且笨重，无法内置于计算机与手机上，因此一般使用石英时钟（quartz clocks）。然而，由于时钟漂移（drift），时钟误差会越来越大，因此需要&lt;strong&gt;&lt;em&gt;定期从具有更准确时间源的服务器（原子钟或 GPS 接收器）获取当前时间&lt;/em&gt;&lt;/strong&gt;。一般是通过 Network Time Protocol (NTP) 进行同步。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所有主流操作系统都内置了NTP客户端&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;时钟服务器的层次结构排列为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第 0 层：原子时钟或者 GPS 接收器&lt;/li&gt;
  &lt;li&gt;第 1 层：直接与第 0 层设备同步&lt;/li&gt;
  &lt;li&gt;第 2 层：与第 2 层同步的服务器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于网络延迟的不确定性，通过网络进行时钟同步也存在一定问题。&lt;strong&gt;&lt;em&gt;为了减少偶然性带来的影响，NTP 采集了几个时间测量样本，并通过统计过滤器来消除异常值&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;与多个时钟服务器进行通信，丢弃异常值，并对剩下的取平均值&lt;/li&gt;
  &lt;li&gt;对同一台服务器进行多次请求，减少网络延迟导致的随机异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;时钟倾斜（skew）&lt;/strong&gt;指的是同一个时间点，两个不同时钟的差异。如何通过 NTP 评估客户端与时钟服务器之间的时钟倾斜？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;NTP Client 向 NTP Server 发送请求，请求消息中携带 Client 的当前 timestamp t1（Client 的时钟）&lt;/li&gt;
  &lt;li&gt;NTP Server 收到 Client 的请求，在处理请求前，先计算当前 timestamp t2（Server 时钟）&lt;/li&gt;
  &lt;li&gt;NTP Server 处理完请求并发送响应。响应消息中携带：t1（请求发送 timestamp），t2（请求接收 timestamp），t3（响应 timestamp，Server 时钟）&lt;/li&gt;
  &lt;li&gt;NTP Client 收到响应时，记录当前 timestamp t4（Client 时钟）&lt;/li&gt;
  &lt;li&gt;从 Client 的视角看，请求发出到接收的往返时间为 t4-t1，Server 处理请求的时间为 t3-t2，那么网络传输的时间为 (t4-t1)-(t3-t2)，单向网络延迟约 t = ((t4-t1)-(t3-t2))/2&lt;/li&gt;
  &lt;li&gt;当响应到达 Client 时，我们可以估计 NTP Server 在此刻的时间约为 t3+t&lt;/li&gt;
  &lt;li&gt;此时我们可以预估 Client 与 Server 的时钟偏差（skew）为：t4-(t3+t)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述对时钟偏差的预估依赖网络的往返延迟大致相同的假设。该假设可能是正确的，但是如果网络中的排队时间是网络延迟的重要因素，那么请求与响应的延迟会有很大不同（如某个节点的网络连接负载较重，而其他节点比较空闲）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;然而，大部分网络并无法提供往返延迟基本一致的保证&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;一旦 NTP Client 预估了与 NTP Server 之间的时钟偏差，接下来需要调整自身的时钟与 Server 保持一致。时钟同步的方法取决于时钟倾斜的范围（amount of the skew）t:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;|t|&amp;lt;125ms ，&lt;strong&gt;slew the clock&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Client 通过稍快或者稍慢的速度（500ppm）运行，在之后的几分钟内（5min）逐渐减小偏差&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;125ms &amp;lt; |t| &amp;lt; 1000s ，&lt;strong&gt;step the clock&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果此时仍然采用 slew 的方式，同步周期将会很长。因此，Client 采用 step 的方式强行将自身时钟与 Server 保持一致。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;会导致时钟突然向前或者向后跳了一段&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;|t| &amp;gt; 1000s，&lt;strong&gt;panic and do nothing&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;当偏移很大的时候（默认不超过 15min），NTP Client 会认为此时出现了异常，从而拒绝调整时钟，由运维人员去调整。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;因此，&lt;strong&gt;&lt;em&gt;时钟并不会一直保持同步&lt;/em&gt;&lt;/strong&gt;，运维人员需要关注时钟偏移的范围&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-2-time-of-day-clock-and-monotonic-clock&quot;&gt;3-2-2 Time-of-day clock and Monotonic clock&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;通过 NTP 进行时钟同步可能会导致时钟跳转，因此对那些需要测量经过时间的应用来说有比较大的影响&lt;/em&gt;。下面是 Java 计算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dosomething()&lt;/code&gt; 的耗时，有两种写法：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// bad&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elapsedMillis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// good&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elapsedNanos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这两种写法有什么区别，首先需要清楚 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentTimeMillis()&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nanoTime()&lt;/code&gt; 的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentTimeMillis()&lt;/code&gt; 表示是真实的时间（real-time），表示从 1970.01.01 开始经历的时间。当 NTP 跳转时，该时间也跳转。如果用其计算经过的时间，结果可能比实际值大或者小，甚至为负数。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nanoTime()&lt;/code&gt; 是一个单调时钟（monotonic clock），并不会受 NTP 跳转影响，只会向前计算（NTP slew 只会影响其向前的速度）。因此，用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nanoTime()&lt;/code&gt; 计算经过的时间相对更准确。不过，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nanoTime()&lt;/code&gt; 只是表示从某个任意时间点经过的时间（如计算机启动的时间点）；不同计算机的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nanoTime()&lt;/code&gt; 比较并不具备实际意义。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;大多数操作系统及编程语言都提供了这两种时间&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-3-causality-and-happens-before&quot;&gt;3-3 Causality and happens-before&lt;/h2&gt;

&lt;p&gt;在分布式系统中存在与时间密切相关的问题：&lt;strong&gt;事件排序&lt;/strong&gt;（order events）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，A 发送消息 m1 给 B,C 两个用户；B 在收到 m1 之后，回复 m2 给 A,C 。然而，即使网络是可靠的（reliable），也是会存在重排序的情况。所以可能存在 C 在收到 m1 前就收到了 m2 的现象。从 C 的视角看，结果令人疑惑：先收到了回复，再收到了问题，好像 B 能够未卜先知。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在现实生活中，这种现象不会发生，所以我们也希望在计算机系统中也不发生&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;进一步讨论这个问题，假设 m1 是在数据库中创建对象的指令，m2 是更新该对象的指令。如果节点在处理 m1 操作前就处理了 m2，那么结果就是首先更新一个不存在的对象，之后再创建一个随后不会被更新的对象。在数据库操作中，只有 m1 发生在 m2 之前才会有意义。&lt;/p&gt;

&lt;h3 id=&quot;3-3-1-physical-timestamps-inconsistent-with-causality&quot;&gt;3-3-1 Physical timestamps inconsistent with causality&lt;/h3&gt;

&lt;p&gt;那么对 C 来说，如何确定消息的正确顺序？&lt;/p&gt;

&lt;p&gt;由于&lt;em&gt;单调时钟（monotonic clock）&lt;/em&gt;在不同节点间（A &amp;amp; B）的比较没有实际意义，因此不可采用。&lt;/p&gt;

&lt;p&gt;尝试使用代表&lt;strong&gt;&lt;em&gt;真实时间的物理时钟时间戳&lt;/em&gt;&lt;/strong&gt;：&lt;em&gt;每个消息都附带当前时间戳&lt;/em&gt;。在这种情况下，我们可以合理预估 m2 拥有比 m1 更靠后的时间戳，因为 m2 是对 m1 的响应，所以 m2 一定在 m1 之后发生（happen after）。&lt;/p&gt;

&lt;p&gt;然而在部分同步（partially synchronous）的系统中，这种方式并不可靠。通过 NTP 或者类似协议进行的时钟同步并不能准确判断时钟偏差，尤其是在双向网络延迟不相同的情况下，这种不确定性会加大。因此，我们不能排除下面这种场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A 根据自身时钟将时间戳 t1 附着在消息 m1 上发送&lt;/li&gt;
  &lt;li&gt;B 收到 m1，并根据自身时钟获取当前时间戳 t2。由于 A 的时钟比 B 稍微快一点，导致 t2&amp;lt;t1。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此时，如果按照时间戳进行排序仍然会得到错误的顺序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-3-2-the-happens-before-relation&quot;&gt;3-3-2 The happens-before relation&lt;/h3&gt;

&lt;p&gt;什么是正确的顺序？我们使用 &lt;strong&gt;Happen-before relation&lt;/strong&gt; 来定义正确的顺序。该定义&lt;em&gt;假设每个节点只有一个正在执行的线程，因此对于同一个节点上的两个执行步骤可以明确其先后顺序&lt;/em&gt;。更正式地说，假设&lt;strong&gt;同一个节点上的操作严格全局有序（strict total order）&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于同一个进程的多个线程，可以把每个线程用独立的（separate node）节点表示&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;什么是 Happen-before？当操作 a 与 b 满足以下条件其中一个时，我们可以认为 a Happen-before b，记为 a→b：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;a 与 b 发生在同一个节点，并且 a 的本地执行顺序在 b 之前&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;a 表示发送消息 m，b 表示接收同一个消息 m（假设消息 m 是唯一的）&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;存在操作 c，并且满足 a→c，c→b&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以&lt;strong&gt;把这种顺序扩展到多个节点：定义同一个消息在接收之前被发送（忽略网络延迟）&lt;/strong&gt;。为了方便起见，假设每条消息都是唯一的，当接收到一条消息，总是可以确定其发送方及发送时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Happen-before 关系是偏序关系（partial order），&lt;/strong&gt;因此会出现 a→b 与 b→a 都不满足的情况，此时 a 与 b 称为 &lt;strong&gt;Concurrent&lt;/strong&gt;，记为 a || b。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;此处的 concurrent 并不是指 a &amp;amp; b 同时发生，而是指 &lt;strong&gt;&lt;em&gt;a &amp;amp; b 是独立的，不存在依赖关系&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;下面是 Happen-before 的示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-3-3-causality&quot;&gt;3-3-3 Causality&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Happen-before 是分布式系统中判断因果关系（causality）的一种方式&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因果关系（causality）&lt;/strong&gt;关注信息是否可以从一个事件传递到另一个事件，从而导致一个事件影响到另一个事件。在上面消息传递的例子中，m2 是对 m1 的回复，因此 m1 影响了 m2。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个事件是否真的影响了另一个事件是一个哲学问题；对我们来说 m2 发送前已经收到了 m1 才是我们关心的&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;因果关系的概念借鉴了物理学。人们普遍认为，信息不可能比光速传播得更快。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果有两个事件 a &amp;amp; b 在空间中相距足够远，但在时间上相近。那么事件 a 不可能在事件 b 之前到达 b 的位置，反之亦然。因此，事件 a &amp;amp; b 肯定不存在因果关系（causally unrelated）&lt;/li&gt;
  &lt;li&gt;如果事件 c 在空间上与 a 相近，并且在 a 发生后的一段时间，那么事件 a 可能会给 c 传递信号，从而影响 c&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分布式系统中的情况与之类似。&lt;/p&gt;

&lt;h1 id=&quot;4-broadcast-protocols-and-logical-time&quot;&gt;4-Broadcast protocols and logical time&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;广播协议（broadcast protocols）&lt;/strong&gt;或者&lt;strong&gt;多播协议（multicast protocols）&lt;/strong&gt;是指将一个消息发送给多个接收者的算法；主要用于构建更上一层的分布式算法。在实践中，有几种不同的广播协议，它们之间最大的区别在于消息发送的顺序（order）。&lt;/p&gt;

&lt;p&gt;正如上文描述的，顺序与时间 &amp;amp; 时钟密切相关。接下来，需要进一步研究时钟如何帮助追踪分布式系统中的顺序。&lt;/p&gt;

&lt;h2 id=&quot;4-1-logical-time&quot;&gt;4-1 Logical time&lt;/h2&gt;

&lt;p&gt;在之前的例子中，我们可以看到&lt;strong&gt;&lt;em&gt;物理时钟时间戳可能与因果关系并不一致（inconsistent with causality）&lt;/em&gt;&lt;/strong&gt;，即使使用类似 NTP 协议进行时钟同步。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;尽管 send(m1) → send(m2)，也可能存在 timestamp(m1) &amp;gt; timestamp(m2)&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;相比之下，逻辑时钟（logical clocks）更注重于分布式系统中的事件顺序。&lt;/p&gt;

&lt;h3 id=&quot;4-1-1-logical-vs-physical-clocks&quot;&gt;4-1-1 Logical vs. physical clocks&lt;/h3&gt;

&lt;p&gt;物理时钟：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算经过的秒数&lt;/li&gt;
  &lt;li&gt;可以用于很多方面，但是&lt;strong&gt;&lt;em&gt;可能会与因果关系不一致&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;逻辑时钟：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算事件发生的次数&lt;/li&gt;
  &lt;li&gt;用于&lt;strong&gt;&lt;em&gt;获取因果依赖关系（capture causal dependencies）：&lt;/em&gt;&lt;/strong&gt;(e1-&amp;gt;e2)=&amp;gt;(T(e1)&amp;lt;T(e2)).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有两种类型的逻辑时钟：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Lamport clocks&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Vector clocks&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-1-2-lamport-clocks&quot;&gt;4-1-2 Lamport clocks&lt;/h3&gt;

&lt;p&gt;Lamport 时间戳本质上是一个整数，用于计算已经发生的事件数量；与物理时钟没有直接关系。在每个节点，由于事件的发生，整数就会增加，相应地 Lamport 也会增加。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该算法的假设适用于 crash-stop 模型（如果 crash-recovery 模型将时间戳持久化存储，则也可以用于该模型中）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;当消息通过网络发送，发送者就会&lt;strong&gt;&lt;em&gt;将当前的 Lamport 时间戳附在消息上&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当接收者收到消息后，会&lt;strong&gt;&lt;em&gt;将本地的 Lamport 时钟向前移动到消息携带的时间戳 + 1&lt;/em&gt;&lt;/strong&gt;。如果接收者的时钟已经领先于消息携带的时间戳，那么它只会在本地时间戳上递增。&lt;/p&gt;

&lt;p&gt;Lamport clocks 算法流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：每个节点初始化自己的本地时钟 t&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事件发生在本地&lt;/strong&gt;：本地时钟 t 递增：t = t + 1&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;发送消息&lt;/strong&gt;：本地时钟递增后 t = t + 1，将时间戳附在消息上发送（t, m）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;收到消息&lt;/strong&gt;：收到（t’, m）消息后，更新本地时间戳 t = max(t, t’) + 1，并将消息传递给程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Lamport 时间戳存在这样的性质：如果事件 a happen-before b，那么 b 的时间戳总是比 a 大；也就是说&lt;strong&gt;时间戳与因果关系保持一致&lt;/strong&gt;。然而，反过来并不这样：如果 b 的时间戳比 a 大，我们可以知道 b 不会在 a 之前发生，但是我们不知道是 a → b 还是 a || b。同时，&lt;strong&gt;两个不同的事件可能拥有相同的时间戳&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A 节点上的第三个事件与 B 节点上的第一个事件拥有相同时间戳&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果我们期望每个事件的都对应一个唯一时间戳，那么&lt;strong&gt;每个时间戳都可以使用发生该事件的节点的名称或标识符进行扩展&lt;/strong&gt;（如上图）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单节点范围内，每个事件被赋予唯一的时间戳&lt;/li&gt;
  &lt;li&gt;如果每个节点都有唯一的标识，那么时间戳与节点标识的组合为全局唯一（across all nodes）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上文介绍说 Happen-before 关系是偏序关系（partial order），通过&lt;strong&gt;使用 Lamport 时间戳我们可以把这种偏序关系扩展为全序关系（total order）：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对（timestamp, node name）对进行字典排序：首先比较 timestamp 的大小，如果 timestamp 相同则比较 node name，从而可以对任意两个 (timestamp, node) 对进行比较，确定全序关系&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们使用 -&amp;gt; 表示 Happen-before 关系，对于&lt;strong&gt;全序关系使用 ≺ 表示&lt;/strong&gt;。&lt;strong&gt;全序关系使得所有事件具有线性关系（linear order）&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对任意两个不同的事件 a , b，要么存在 a ≺ b，要么存在 b ≺ a.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;全序&lt;strong&gt;关系也是因果关系，换句话说，≺ 是偏序关系-&amp;gt; 的线性扩展（linear extension）&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不管什么时候，只要存在 a-&amp;gt;b，那么就可以得出 a ≺ b；对于 a ≺ b，我们不一定能得出 a-&amp;gt;b.&lt;/li&gt;
  &lt;li&gt;然而，如果 a||b ，我们可以得出 a ≺ b 或者 b ≺ a，这两个事件的顺序由具体的算法确定.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-1-3-vector-clocks&quot;&gt;4-1-3 Vector clocks&lt;/h3&gt;

&lt;p&gt;对于给定两个事件的 Lamport 时间戳，通常不能判断这两个事件是并发（concurrent）还是存在 Happen-before 关系。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果 b 的 Lamport 时间戳比 a 大，我们可以知道 b 不会在 a 之前发生，但是我们不知道是 a → b 还是 a || b；给定的两个 Lamport 时间戳虽然可以进行全局比较，但是不一定能够确定事件的先后顺序&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果我们想要检测两个事件是否是并发的，需要使用另一种逻辑时钟：&lt;strong&gt;向量时钟（vector clocks）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;与 Lamport 时间戳只使用一个整数（可能会附带 node name）不同，&lt;strong&gt;向量时钟是一组整数列表，每个整数对应系统中的一个节点&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果节点列表用 &amp;lt;N1,N2,N3…Nn&amp;gt; 表示，那么向量时钟用 &amp;lt;t1,t2,t3…tn&amp;gt; 表示，其中 ti 与 Ni 对应.&lt;/li&gt;
  &lt;li&gt;ti 表示在节点 Ni 上发生的事件数量&lt;/li&gt;
  &lt;li&gt;对于向量时钟 T=&amp;lt;t1,t2,t3…tn&amp;gt;，我们使用 T[i] 表示 ti.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lamport 时钟是标量，向量时钟是矢量；除了这点区别外，向量时钟算法与 Lamport 时钟算法很相似。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个节点初始化向量时钟 T := &amp;lt;0,0,…,0&amp;gt;，向量中的元素与系统节点一一对应&lt;/li&gt;
  &lt;li&gt;当事件发生在节点 Ni 时，该节点将向量时钟的第 i 个元素递增：T[i]=T[i]+1.&lt;/li&gt;
  &lt;li&gt;当通过网络发送消息 m 时，发送者递增自己的向量时钟 T[i]=T[i]+1，同时将当前向量时钟被附着在消息上一起发送： (T,m).&lt;/li&gt;
  &lt;li&gt;当收到消息后，接收者将消息中的向量时钟 (T’,m) 与自己本地的向量时钟 T 比较并合并：T[j] := max(T[j],T′[j]),j={1,2,3…n}，之后递增自己的向量时钟：T[i]=T[i]+1，再将消息 m 传递给程序.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面是向量时钟的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当节点 C 从 B 收到消息 m2 时，会将自己本地的向量时钟中表示节点 A 的元素也更新为 2，因为收到消息这个事件与发生在 A 上的两个事件有间接的因果关系（indirect causal）。因此，&lt;strong&gt;向量时间戳反映出了 Happen-before 关系的传递性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通过向量时钟可以定义偏序顺序：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果向量 T 的每个元素都等于另一个向量 T’ 中的对应元素，则 T=T’.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;T =T′ iff T[i] = T′[i] for all i∈{1,…,n}&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果向量 T 的每个元素都小于或者等于另一个向量 T’ 中的对应元素，则 T&amp;lt;=T’.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;T ≤T′  iff T[i] ≤ T′[i] for all i∈{1,…,n}&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果向量 T&amp;lt;=T’ 并且它们间至少存在一个元素不同，则 T&amp;lt;T’.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;T &amp;lt;T′ iff T ≤ T′ and T != T′&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果向量 T 的某个元素比向量 T’ 对应元素大，而 T’ 的另一个元素比 T 对应元素大，那么这两个向量无法比较：T||T’. 如 T = ⟨2,2,0⟩ , T′ = ⟨0,0,1⟩，其中 T[1] &amp;gt; T′[1] 但是 T[3] &amp;lt; T′[3].&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;T || T′ iff T !≤ T′ and T’ !≤ T&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;向量时间戳展现出的偏序关系与 Happen-before 定义的偏序关系完全对应。因此，&lt;strong&gt;向量时钟算法提供了计算 Happen-before 关系的机制&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-1-4-summary&quot;&gt;4-1-4 Summary&lt;/h3&gt;

&lt;p&gt;对于逻辑时钟，我们讨论了两种关键算法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Lamport 时钟：提供了全序关系（total order）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;向量时钟：计算 Happen-before 的偏序关系&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也有许多其他算法提出：如混合时钟（hybrid clocks）将逻辑时钟与物理时钟的特性结合起来。&lt;/p&gt;

&lt;h2 id=&quot;4-2-delivery-order-in-broadcast-protocols&quot;&gt;4-2 Delivery order in broadcast protocols&lt;/h2&gt;

&lt;p&gt;许多网络提供点对点协议（单播，unicast），其中每个消息都有特定的接收者。我们将要讨论广播协议（broadcast），该协议中每个消息被发送给某个组中的所有节点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;网络组中的成员可能是固定的，也可能允许节点的加入与离开&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;一些局域网在硬件层面提供了多播（multicast）或者广播（broadcast），如 IP 多播，但是在互联网上的通信通常只允许单播。不过，硬件层面的广播通常只能提供 Best-effort：允许消息丢失。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;之前讨论的 Node behavior 与 Synchrony model 可以扩展到广播组中&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果我们想在单播协议上构建广播协议，需要使用广播算法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发送者程序通过单播链路向其他节点发送消息&lt;/li&gt;
  &lt;li&gt;接收者程序通过单播链路接收消息&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;广播算法将消息发送给接收者应用程序&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有几种不同类型的广播协议，这些协议都是可靠的（reliable）：&lt;strong&gt;&lt;em&gt;所有消息最终都会发送给每个无故障节点（network  behavior: reliable），但是没有延迟保证（synchrony model: partially synchronous）&lt;/em&gt;&lt;/strong&gt;。这些广播协议在消息传递到每个节点的顺序上有所不同。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息顺序的差异是不同广播算法间重要的区分&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-2-1-fifo-broadcast&quot;&gt;4-2-1 FIFO broadcast&lt;/h3&gt;

&lt;p&gt;定义：&lt;strong&gt;如果消息 m1, m2 由同一个节点广播，并且 broadcast(m1) → broadcast(m2)，那么 m1 一定会在 m2 之前到达&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;FIFO 广播模型是最弱的（weakest），与 FIFO 网络链路密切相关。在该模型中，同一个节点发送的消息按照发送顺序到达；但是不同节点发送的消息可以以任意顺序到达。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;m1 一定会在 m3 之前到达：均由 A 节点发送；m2 相较于 m1, m3，可以在任意时间到达&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;另外，&lt;strong&gt;对于这些广播协议，我们假设一个节点不管什么时候广播消息，同时会将该消息发送给自己&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该特性在全序广播中将会被用到&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-2-2-causal-broadcast&quot;&gt;4-2-2 Causal broadcast&lt;/h3&gt;

&lt;p&gt;FIFO 广播可能会违反因果关系：在上图的示例中，节点 C 在收到 m1 前收到了 m2，即使 B 是在收到 m1 之后再广播 m2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Causal broadcast&lt;/strong&gt; 相对于 FIFO，能够提供更严格的顺序保证：&lt;strong&gt;确保消息按照因果关系到达&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 broadcast(m1) → broadcast(m2)，那么所有节点也必须按照该顺序收到 m1, m2。&lt;/li&gt;
  &lt;li&gt;如果 broadcast(m1) || broadcast(m2)，那么节点可以按照任意顺序接收 m1, m2。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在之前的示例中，如果节点 C 在接收到 m1 之前收到了 m2，那么运行在 C 上的广播算法会 &lt;strong&gt;&lt;em&gt;hold back（保留 or 缓冲）m2，直到接收到 m1&lt;/em&gt;&lt;/strong&gt;，从而确保消息按照因果顺序接收到。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A：broadcast(m1) → broadcast(m3)；B：broadcast(m1) → broadcast(m2)；同时 broadcast(m3) || broadcast(m2)，则节点 C 可以按照 (m1, m2, m3) 的顺序接收，也可以按照 (m1, m3,m2) 的顺序接收，这两个情况都与因果关系保持一致&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-2-3-total-order-broadcast&quot;&gt;4-2-3 Total order broadcast&lt;/h3&gt;

&lt;p&gt;Total order broadcast（全序广播）也被称为原子广播（atomic broadcast）。&lt;/p&gt;

&lt;p&gt;FIFO broadcast 与 Causal broadcast 允许不同的节点按照不同的顺序接收消息，与之不同的是，&lt;strong&gt;Total order broadcast 加强了不同节点间的一致性，保证所有节点都按照相同的顺序接收消息&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;接收的顺序没有准确定义，只要所有节点的顺序相同即可&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所有的节点都按照相同的顺序接收消息：(m1, m2, m3)&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所有的节点都按照相同的顺序接收消息：(m1, m3, m2)&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;只要所有节点能够对消息顺序达成一致，上述两种顺序都是有效的。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;与 Causal 广播一样，节点可能需要 hold back 消息直到该消息之前的消息都被接收&lt;/em&gt;。例如：节点 C 可能会按照任意的顺序收到 m2, m3，如果算法已经确定 m3 应该在 m2 之前收到，但是节点先收到了 m2，那么就会 hold back m2 直到收到 m3。&lt;/p&gt;

&lt;p&gt;另外，在 FIFO broadcast 与 Causal broadcast 中，当一个节点广播了一条消息，那么它可以将该消息立即发送给自己，并不需要与其他节点通信。但是&lt;strong&gt;&lt;em&gt;在 Total broadcast 中需要与其他节点通信以确定发送顺序&lt;/em&gt;&lt;/strong&gt;：在第一个场景中，由于 m2 需要在 m3 前收到，因此节点 A 需要从 B 收到 m2 之后才能将 m3 发送给自己。&lt;/p&gt;

&lt;h3 id=&quot;4-2-4-fifo-total-order-broadcast&quot;&gt;4-2-4 FIFO-total order broadcast&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;FIFO-total order broadcast 与 total order broadcast 类似，但是额外再加上 FIFO 的要求：同一个节点广播的消息需要按照发送的顺序送达&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在 Total order broadcast 中的两个例子实际上满足 FIFO-total order broadcast 要求，因为 m1 总是在 m3 前被接收。&lt;/p&gt;

&lt;h3 id=&quot;4-2-5-summary&quot;&gt;4-2-5 Summary&lt;/h3&gt;

&lt;p&gt;上述不同广播协议之间的层次关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;FIFO-total order broadcast 协议要比 Causal broadcast 更严格：每个有效的 FIFO-total order broadcast 协议都是有效的 Causal broadcast 协议（反过来并不是）。&lt;/p&gt;

&lt;h2 id=&quot;4-3-broadcast-algorithms&quot;&gt;4-3 Broadcast algorithms&lt;/h2&gt;

&lt;p&gt;接下来将会讨论实现广播协议的算法。整体来说，涉及两个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;确保每个节点都能收到每条消息&lt;/strong&gt;：通过重发丢失的消息，使得广播协议变得可靠（reliable）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;将消息按序送达&lt;/strong&gt;：在可靠的广播协议之上使得消息有序送达&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-1-deliver-message-reliably&quot;&gt;4-3-1 Deliver message reliably&lt;/h3&gt;

&lt;p&gt;广播算法实现的一次尝试：当一个节点想要广播一条消息时，它会通过可靠的网络连接（消息丢失后会重试）将消息分别发送给其他节点。然而，&lt;em&gt;在消息重发之前，发送者节点可能已经崩溃&lt;/em&gt;。这种情况下，会存在节点永远不会收到消息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/25.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了提高可用性，可以寻求其他节点的帮助：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当一个节点第一次收到某条特定的消息时，会将其转发到其他节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种方式被称为：&lt;strong&gt;&lt;em&gt;Eager reliable broadcast&lt;/em&gt;&lt;/strong&gt;。该算法能够保证，&lt;strong&gt;当一些节点崩溃后，剩余的所有非故障（non-faulty）节点都能收到每条消息&lt;/strong&gt;。但是一个明显的缺点是，该算法效率很低：在没有故障节点的情况下，每条消息都会被发送 O(n^2) 次（假设系统中有 n 个节点），同时每个节点对于每条消息会收到 n-1  次；&lt;strong&gt;导&lt;em&gt;致大量的网络冗余&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/26.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该算法发展了许多变体，从容错，所有节点收到消息的时间，使用的网络带宽等多个角度进行优化。其中一个比较常见的&lt;strong&gt;广播算法族是 Gossip protocols，也被称为 Epidemic protocols&lt;/strong&gt;。基本流程为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当准备广播消息时，节点将该消息发送给&lt;strong&gt;&lt;em&gt;随机选择的，少量，固定数目&lt;/em&gt;&lt;/strong&gt;的节点.&lt;/li&gt;
  &lt;li&gt;当节点首次收到该消息时，会将该消息转发给&lt;strong&gt;&lt;em&gt;固定数目的，随机选择&lt;/em&gt;&lt;/strong&gt;的节点.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;这种传播方式类似于流言，传染病在人群中传播的方式&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Gossip 协议并不严格保证每条消息都会被所有节点收到&lt;/strong&gt;：在每次随机选择时，可能有些节点总是被遗漏。然而，如果算法参数比较合理，那么这种可能性就会很低。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Gossip 协议保证广播效率的同时，兼顾了消息丢失，节点崩溃的情况&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/27.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过 Eager reliable broadcast 或 Gossip 协议，我们已经保证广播的可靠性（reliable），之后需要讨论在其之上实现具体的广播算法：FIFO, Causal, Total order broadcast。&lt;/p&gt;

&lt;h3 id=&quot;4-3-2-fifo-broadcast-algorithm&quot;&gt;4-3-2 FIFO broadcast algorithm&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/28.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个节点都的本地状态信息由以下组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;sendSeq&lt;/strong&gt;：计算当前节点广播消息的数量（每个消息都会标识该序列号）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;delivered&lt;/strong&gt;：当前节点从其他节点收到消息数目的向量：&amp;lt;0, 0, . . . , 0&amp;gt;，每个元素对应一个节点&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;buffer&lt;/strong&gt;：缓冲区，用于 hold back 接收的消息，直到该消息可以传递给应用进程（如等到之前的消息全部接收到）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每个被广播的消息有以下标识：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;i&lt;/strong&gt;：发送者节点 Ni 的标识&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sendSeq&lt;/strong&gt;：当前消息的序列号（由当前节点计算已经发送的消息数量）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FIFO 算法&lt;em&gt;检查每个发送方消息的序列号，如果与预期序列号匹配，则增加预期编号，确保来自特定发送方的消息有序传递给应用进程&lt;/em&gt;。&lt;/p&gt;

&lt;h3 id=&quot;4-3-3-causal-broadcast-algorithm&quot;&gt;4-3-3 Causal broadcast algorithm&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Causal 广播算法与 FIFO 算法类似，不过在每条广播消息上并不携带消息的序列号，而是&lt;strong&gt;&lt;em&gt;序列号向量&lt;/em&gt;&lt;/strong&gt;。该算法有时也被称为向量时钟（vector clocks）算法，不过它们之间有很大不同：向量时钟算法中的向量元素计算发生在每个节点上的事件数量，而该算法中向量元素由于计算从不同节点收到的消息数量。&lt;/p&gt;

&lt;p&gt;每个节点的本地状态仍然由：sendSeq, delivered, buffer 组成。&lt;/p&gt;

&lt;p&gt;当节点广播消息时，附带的信息有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;i：发送者节点 Ni 的标识&lt;/li&gt;
  &lt;li&gt;deps：表明该消息因果依赖性的向量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;deps 向量以 delivered 进行初始化：delivered 是当前节点从其他节点收到消息数目的向量；deps &lt;strong&gt;&lt;em&gt;在本地发送的所有消息必须按因果顺序出现在该广播消息之前。&lt;/em&gt;&lt;/strong&gt;初始化之后，将 deps 向量中对应该节点的元素更新为 sendSeq：确保此节点广播的每条消息都因果依赖同一节点广播的上一条消息。&lt;/p&gt;

&lt;h3 id=&quot;4-3-4-fifo-total-order-broadcast-algorithms&quot;&gt;4-3-4 (FIFO-)Total order broadcast algorithms&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Total order (FIFO-total order) 广播算法相对更复杂。如上图所示有两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;指定主节点的方式&lt;/li&gt;
  &lt;li&gt;通过使用 Lamport 时间戳的无主节点方式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不过这两种方法都不支持容错：单节点崩溃会导致其他节点都不能发送消息。&lt;/p&gt;

&lt;h1 id=&quot;5-replication&quot;&gt;5-Replication&lt;/h1&gt;

&lt;p&gt;Replication 是指在多个节点上维护相同数据的副本，每个节点被称为&lt;strong&gt;副本（replica）&lt;/strong&gt;。&lt;strong&gt;复制&lt;/strong&gt;是许多分布式数据库，文件系统及其他存储系统中的标准功能。同时，也&lt;strong&gt;是实现容错（fault tolerance）的主要机制&lt;/strong&gt;之一：如果一个副本故障，可以继续访问其他副本。&lt;/p&gt;

&lt;h2 id=&quot;5-1-manipulating-remote-state&quot;&gt;5-1 Manipulating remote state&lt;/h2&gt;

&lt;p&gt;如果数据没有发生变化，那么复制操作比较容易，因为只需要一次数据复制就行。因此，复制的主要问题是管理变更数据。在进一步深入复制流程的细节前，先探讨下在分布式系统中，数据是如何变更的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;考虑这样一个场景，假设用户对某条推文感兴趣，因此点了 “like” 操作；twitter 会把喜欢这条推文的人存储在数据库中，以便展示给当前用户及其他用户。&lt;/p&gt;

&lt;p&gt;我们把存储在数据库中的数据看作&lt;strong&gt;状态（state）&lt;/strong&gt;。由于网络问题，更新数据库的请求可能会丢失，或者更新成功后的确认操作也会丢失。通常我们通过重试请求来提高可靠性，但是如果重试操作处理不当，该请求可能会被多次处理，导致数据库中的状态异常。&lt;/p&gt;

&lt;p&gt;防止更新多次生效的一种方法是&lt;strong&gt;对请求去重（deduplicate requests）&lt;/strong&gt;。然而在 crash-recovery 系统模型中，需要将请求（或者请求的元数据）存储在稳定的存储介质中，这样即使在节点崩溃后也能检测出重复的请求。&lt;/p&gt;

&lt;p&gt;请求去重的一种替代方式是&lt;strong&gt;请求幂等（idempotent）&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;递增操作不是幂等的，但是向集合中添加一个元素是幂等的。因此，如果需要计数器操作，最好维护元素集合，并从集合导出计数值。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;幂等更新操作可以安全重试：执行多次与执行一次的效果一样&lt;/strong&gt;。幂等使得更新操作具有 &lt;strong&gt;exactly once&lt;/strong&gt; 语义：更新操作可能执行多次，但是影响与正好执行一次是相同的。&lt;/p&gt;

&lt;p&gt;对于重试操作的语义有以下几种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;At most once&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;发送请求，但是并不会重试，更新也会并不会执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;At least once&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;收到确认前一直重试，可能会多次更新&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Exactly once&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;重试 + 幂等；或者去重&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在分布式系统中，幂等是非常有用的特性：RPC 操作不可避免地要进行重试。&lt;/p&gt;

&lt;p&gt;然而，当多个更新操作在处理时，幂等具有明显的局限性。下面是几个示例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;添加后删除&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;client 1 将一个 userId A 添加到用户集合中，数据库添加成功但是响应丢失。&lt;/li&gt;
      &lt;li&gt;client 2 从数据库中读取该集合，其中包含了 client 1 刚刚添加的 userId A。&lt;/li&gt;
      &lt;li&gt;client 2 请求数据库将 userId A 从集合中移除，数据库操作成功并返回。&lt;/li&gt;
      &lt;li&gt;此时，client 1 并不知道 client 2 的删除操作，仍在重试刚才的添加请求；该重试操作重新将 userId A 添加到集合中。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;最后的结果不符合预期，因为 client 2 是在 client 1 更新之后的操作，符合因果关系；我们希望 userId A 最后被移除。在这种情况下，&lt;em&gt;幂等操作并不能实现安全重试&lt;/em&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一种形式的添加后删除&lt;/p&gt;

    &lt;p&gt;假设有两个数据副本 A，B。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/34.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;client 将数据 x 添加到两个副本中，添加成功&lt;/li&gt;
      &lt;li&gt;client 之后尝试将 x 从这两个副本中删除，但是对副本 B 的删除请求丢失了&lt;/li&gt;
      &lt;li&gt;client 在重试前崩溃了&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;client 尝试将数据 x 添加到两个副本中，但是向副本 A 添加数据的请求丢失了&lt;/li&gt;
      &lt;li&gt;client 在重试前崩溃了&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;虽然这两个场景的预期效果不一样：第一个场景中，想要从两个副本中删除数据；第二个场景中想要向两个副本中添加数据。但是最后结果都一样：x 存在副本 B 中，但是在副本 A 中不存在。&lt;/p&gt;

    &lt;p&gt;当两个部分协调其不一致的状态时，我们希望它们最后都处于 client 期望的状态。然而，如果副本间无法区分这两种情况，是无法做到的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决这种问题，我们需要做两件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;将逻辑时间戳附在每次的更新操作上，并将时间戳作为数据更新的一部分存储在数据库中&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;当想要将数据记录从数据库中删除时，我们并不真正删除该数据，而是看作一种特殊类型的更新操作，将其标记为删除，称为&lt;strong&gt;墓碑（tombstone）&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在许多分布式系统中，&lt;strong&gt;副本运行一个协议来检测 &amp;amp; 协调副本间的差异（被称为反熵，anti-entropy），最终所有副本都能保证数据的一致性&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由于墓碑，可以区分已经删除的记录和还未创建的记录&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于时间戳，可以区分哪个版本的记录更新，哪个版本更旧；从而可以丢弃旧的版本，保留新的版本&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在第一种添加后删除的场景中，重试操作的时间戳与之前请求的时间戳相同，因此重试操作并不会覆盖 client 2 的更新：因为 client 2 的操作时间戳更大，与之前的请求具有因果性&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;在每次更新操作中附带时间戳的方式对处理并发更新也很有用&lt;/em&gt;&lt;/strong&gt;。如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/38.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;client 1 想要将 x 的值更新为 v1（携带时间戳 t1）&lt;/li&gt;
  &lt;li&gt;与此同时，client 2 想要将 x 的值更新为 v2（携带时间戳 t2）&lt;/li&gt;
  &lt;li&gt;副本 A 首先收到 v2 ，之后收到 v1；副本 B 收到的顺序相反&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了确保两个副本最终状态相同，我们并&lt;em&gt;不依赖它们收到更新请求的顺序，而是根据时间戳的顺序&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;不过，该方法的具体细节依赖采用时间戳的类型。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Last writer wins (LWW)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果使用的是 Lamport 时间戳（能够提供全序关系），并发更新操作就可以进行排序（具体取决于时间戳比较的方式）。这种情况下，我们可以使用 &lt;strong&gt;&lt;em&gt;Last writer wins (LWW) 语义：拥有最大时间戳的更新操作有效，其他对同一 key 并发更新且时间戳较小的操作被丢弃&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;该方法执行比较简单，但是如果&lt;strong&gt;&lt;em&gt;多个更新操作并发执行，会导致数据丢失&lt;/em&gt;&lt;/strong&gt;。不过，这一点取决于具体的应用程序：对有些系统来说，丢弃并发更新是允许的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Multi-value register&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;当不能丢弃并发更新时，我们需要能够&lt;strong&gt;&lt;em&gt;检测并发更新是在什么时候发生的&lt;/em&gt;&lt;/strong&gt;，此时可以使用矢量时钟。矢量时钟具有偏序关系（帮助判断 Happen-before  关系），可以帮助我们判断新值是否应该覆盖旧值（当旧值 Happen-before 新值时可以覆盖）。同时，当多个更新操作并发时，我们可以保留所有并发更新的值。应用程序可以之后将冲突的值合并成一个值。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这些并发写入的值被称为 &lt;strong&gt;&lt;em&gt;conflicts&lt;/em&gt;&lt;/strong&gt; 或者 &lt;strong&gt;&lt;em&gt;siblings&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;

    &lt;p&gt;向量时钟的一个缺点是成本较高：每个 client 是向量时钟的一个元素：&amp;lt;n1,n2,n3..ni&amp;gt;，&lt;strong&gt;&lt;em&gt;如果一个系统中有很多 client，那么向量时钟就会变得很长&lt;/em&gt;&lt;/strong&gt;，可能要比数据本身所占的空间要大。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Dynamo 系统使用的是这种方式，不过对向量时钟进行了优化，确保不会太长。也存在其他的优化方式。&lt;/p&gt;

    &lt;/blockquote&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/39.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-2-quorums&quot;&gt;5-2 Quorums&lt;/h2&gt;

&lt;p&gt;正如之前所说，复制可以提高系统的&lt;strong&gt;&lt;em&gt;可靠性（reliability）：当一个副本不可用时，剩下的副本可以继续处理请求&lt;/em&gt;&lt;/strong&gt;。导致副本不可用的原因有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点故障：崩溃或者硬件故障&lt;/li&gt;
  &lt;li&gt;网络分区：无法通过网络访问节点&lt;/li&gt;
  &lt;li&gt;有计划地维护：重启节点或进行服务升级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过，如何执行复制操作对系统可靠性有很大影响。&lt;em&gt;如果没有容错机制，那么拥有多个副本可能使得系统可靠性更差（worse）&lt;/em&gt;：部分越多，任意副本在任意时间出现故障的可能性越大。如果系统在一些副本故障的情况下仍能继续工作，那么可靠性提高：&lt;em&gt;所有副本同时出现故障的概率远远低于单个副本出现故障的概率&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;在继续讨论如何在复制中实现容错前，先看下一个示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有两个副本 A，B，对于 x 的值都初始化为 v0（关联时间戳为 t0）&lt;/li&gt;
  &lt;li&gt;client 尝试将 x 的值更新为 v1（时间戳 t1）；更新操作在副本 B 上操作成功，但是由于副本 A 暂时不可用，导致更新失败&lt;/li&gt;
  &lt;li&gt;之后，client 尝试读取其写入的值；读取操作在副本 A 上成功，但是在副本 B 上失败&lt;/li&gt;
  &lt;li&gt;结果，返回值并不是 client 之前的写入值 v1，而是初始值 v0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述场景是不符合预期的，因为从 client 的视角来看它写入的值似乎已经丢失了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设你在社交网络上刚刚发布一条动态，之后刷新页面，但是并没有看到刚刚的发布&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;为了解决这类问题，许多系统需要支持&lt;strong&gt;写后读一致性（Read-after- write consistency），也被称为 Read-your-writes consistency&lt;/strong&gt;。这样能够取保，&lt;em&gt;client 更新值之后，同一个 client 能够读取刚刚写入的值&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;严格来说，写后读一致性并不能确保 client 读取其刚刚写入的值，因为其他 client 可能同时并发覆盖了该值。因此，&lt;strong&gt;&lt;em&gt;写后读一致性能够保证读取最后写入的值或者之后的值&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在上面示例中，我们可以通过&lt;em&gt;确保始终写入两个副本或者从两个副本中读&lt;/em&gt;来实现写后读一致性。但是，这意味着&lt;em&gt;读/写操作并不具备容错性&lt;/em&gt;：如果一个副本不可用，那么需要两个副本都响应的读取/写入操作就无法完成。&lt;/p&gt;

&lt;p&gt;我们可以通过使用三个副本来解决这个问题：把每个读写请求发送给全部三个副本，只要收到的响应数 ≥2，就可以认为请求成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/41.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;更新请求在副本 B，C 上执行成功；读取请求在副本 A，B 上执行成功&lt;/li&gt;
  &lt;li&gt;读写请求在 2/3 节点上执行成功；因此可以保证&lt;em&gt;读取的响应至少有一个来自最新写入的副本&lt;/em&gt;（副本 B）；通过比较响应的时间戳就可以判断最新数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在该示例中，响应写请求的副本集合 {B, C} 称为 &lt;strong&gt;&lt;em&gt;write quorum&lt;/em&gt;&lt;/strong&gt;；响应读请求的副本集合 {A, B} 被称为 &lt;strong&gt;&lt;em&gt;read quorum&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quorum 是请求响应的最小节点集合&lt;/strong&gt;。为了确保写后读一致性，write quorum 与 read quorum 必须存在非空交集。换句话说，read quorum 中至少包含一个已经确认写入的节点。&lt;/p&gt;

&lt;p&gt;在分布式系统中，通常选择 &lt;strong&gt;Majority quorum：严格包含一半以上节点的集合&lt;/strong&gt;。假设系统中有 {A, B, C} 节点集合，那么 majority quorum 为 {A, B}，{A, C}，{B, C}。一般来说，&lt;em&gt;对于拥有奇数节点的系统，(n+1)/2 的数目集合即为 majority quorum；对于拥有偶数节点的系统，n/2+1 的数目集合即为 majority quorum&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;majority quorum 的特性为：任何两个 majority quorum 至少存在一个共同节点&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;除了 majority quorum，其他形式的 quorum 也是可能的。&lt;/p&gt;

&lt;h3 id=&quot;5-2-1-read-and-write-quorum&quot;&gt;5-2-1 Read and write quorum&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;write quorum&lt;/strong&gt;：写入操作需要确认的副本数。&lt;strong&gt;read quorum&lt;/strong&gt;：读取操作需要确认的副本数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果 write quorum 为 w，read quorum 为 r，并且 r + w &amp;gt; n，那么读取操作能够获取到最新写入的值：读写 quorum 至少存在一个共同节点&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于 write quorum 为 w 的系统，可以容忍最多 n-w 个副本不可用；对于 read quorum为 r 的系统，可以最多容忍 n-r 个副本不可用&lt;/strong&gt;。对于 majority quorum 系统，3 个副本可以容忍 1 个不可用；5 个副本可以容忍 2 个不可用，以此类推。&lt;/p&gt;

&lt;h3 id=&quot;5-2-2-read-repair&quot;&gt;5-2-2 Read repair&lt;/h3&gt;

&lt;p&gt;在这种 quorum 机制的复制系统中，任意时刻都可能存在部分副本缺少更新。在上面的例子中，副本 A 没有将 x 更新为 v1。为了使副本间保持一致，可以使用之前讨论的反熵机制（anti-entropy）。&lt;/p&gt;

&lt;p&gt;另一种方式是 Client 帮助传播更新。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/42.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;client 从副本 B 读取到 (t1, v1)；从副本 A 中读取到 (t0, v0)；副本 C 未响应&lt;/li&gt;
  &lt;li&gt;由于 client 知道 (t1, v1) 为最新值，且需要传播到副本 A，所以可以向 A 发送更新请求：因为这不是新的更新操作而是之前更新的重试&lt;/li&gt;
  &lt;li&gt;client 也许会将更新请求发送给 C，即使其不知道 C 是否需要再次更新：如果 C 已经执行过这次更新，也仅仅是浪费一小部分带宽&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述的流程被称为&lt;strong&gt;读修复（read repair）&lt;/strong&gt;。client 可以对任意读请求进行读修复操作，而不管之前更新操作是否是当前 client 执行的。&lt;/p&gt;

&lt;h3 id=&quot;5-2-3-summary&quot;&gt;5-2-3 Summary&lt;/h3&gt;

&lt;p&gt;使用 quorum 复制模型的数据库通常被称为Dynamo风格，以 Amazon Dynamo 数据库命名。&lt;/p&gt;

&lt;h2 id=&quot;5-3-replication-using-broadcast&quot;&gt;5-3 Replication using broadcast&lt;/h2&gt;

&lt;p&gt;5.2 节介绍的 &lt;em&gt;quorum 复制方法使用的是 best-effort 广播：client 将每个读写请求广播到所有副本，但是使用的协议并不是可靠的（请求可能会丢失），同时不能提供顺序保证&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;另一种复制方法使用的是 第 4 节介绍的广播协议。首先讨论最可靠的广播协议：&lt;strong&gt;FIFO-total order broadcast&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;使用 FIFO-total order broadcast 比较容易构造一个复制系统，通过&lt;em&gt;将每个更新请求广播到所有副本，副本根据收到的每条消息更新自身状态&lt;/em&gt;。这种方式被称为 &lt;strong&gt;State Machine Replication（SMR）&lt;/strong&gt;：副本充当状态机，消息传递是其输入。&lt;/p&gt;

&lt;p&gt;我们只要求更新逻辑是&lt;strong&gt;稳定的（deterministic）&lt;/strong&gt;：&lt;em&gt;任何两个处于相同状态并拥有相同输入的副本最终一定处于相同的下一个状态&lt;/em&gt;。即使是错误也需要是确定的：如果一个更新操作在一个副本上成功的，但是在另一个副本上失败，那么这两个副本就会变得不一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/43.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;状态机复制的一个优点是：&lt;em&gt;只要执行逻辑是稳定的，那么从一个状态转移到下一个状态的执行逻辑可以是任意复杂度&lt;/em&gt;。例如，可以执行具有任意业务逻辑的数据库事务，该业务逻辑可能依赖广播消息和数据库当前状态。一些分布式数据库以这种方式执行复制，每个副本独立执行相同且稳定的事务代码，被称为&lt;strong&gt;主动复制（active replication）&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该原理还被用于区块链，加密货币，分布式分类账：区块链中的“区块链”只不过是 FIFO-total order 协议传递的消息序列，每个副本确定性地执行这些块中描述的事务，以确定分类账的状态&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;状态机复制的缺点即为全序广播的限制。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;正如之前讨论 FIFO-total order 广播，当一个节点想要通过全序广播协议广播一条消息时，该节点不能立即将消息发送给自己。因此，当一个副本想要更新自身状态时，不能立即更新；必须经历广播过程，与其他节点协调，并等待其他节点的更新响应&lt;/li&gt;
  &lt;li&gt;同时，状态机复制的容错性取决于底层依赖的全序广播协议的容错性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尽管存在上述限制，基于全序广播的复制仍被广泛使用。&lt;/p&gt;

&lt;h3 id=&quot;5-3-1-database-leader-replica&quot;&gt;5-3-1 Database leader replica&lt;/h3&gt;

&lt;p&gt;之前说过，实现 FIFO-total order 广播协议的一个方法是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;指定一个节点作为 leader&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;通过 leader 路由所有的广播消息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个原理也广泛用于数据库复制。许多数据库系统指定一个副本作为 leader, primary 或者 master，任何对数据库更新的事务都必须在 leader 副本上执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/44.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，&lt;strong&gt;&lt;em&gt;leader 可能并发执行多个事务，不过会按照全局关系提交（commit）这些事务。当事务提交时，leader 副本将事务产生的数据变更广播给所有 follower 副本，之后 follower 副本将这些变更按照提交顺序应用到本地&lt;/em&gt;&lt;/strong&gt;。这种方法被称为 &lt;strong&gt;passive replication 或者 primary-backup replication&lt;/strong&gt;。可以看到这种方式相当于事务提交记录的全序广播。&lt;/p&gt;

&lt;p&gt;除了 FIFO-total order broadcast 协议，其他广播模型也可以用于复制，不过需要更加小心以确保副本间保持一致（仅仅确保更新逻辑是稳定的并不够）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/45.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;6-consensus&quot;&gt;6-Consensus&lt;/h1&gt;

&lt;p&gt;在 5.3 节看到了全序关系广播（total order broadcast）对实现状态机复制非常有用。而其中一种实现全序关系广播的方式是：指定一个节点作为 leader，由 leader 路由所有的消息。leader 只需要通过 FIFO broadcast 进行消息分发，足以确保所有的节点以相同的顺序收到相同的消息序列。&lt;/p&gt;

&lt;p&gt;然而，这种方法最大的问题是，&lt;strong&gt;leader 单点故障&lt;/strong&gt;：如果 leader 不可用，整个系统就会不可用。一种解决方案是进行人工干预：当 leder 不可用时，通知管理员重新配置新的 leader 节点。这个过程被为&lt;strong&gt;故障转移（failover）&lt;/strong&gt;，该方式常用于许多数据库系统中。&lt;/p&gt;

&lt;p&gt;在&lt;em&gt;提前计划 leader 不可用&lt;/em&gt;的情况下，故障转移能够运行良好，如需要重启更新 leader 节点。然而对于&lt;em&gt;突然或意料之外的 leader 不可用的情况（如节点崩溃，硬件故障，网络故障等）&lt;/em&gt;，由于人为介入的速度有限，故障转移会受到影响。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;管理员可能需要好几分钟才能响应，那么在此期间服务是不可用的&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;由此引出了一个新的问题，当旧 leader 不可用的时候，能否自动选择另一个节点作为新 leader？而这就是&lt;strong&gt;共识算法（consensus）&lt;/strong&gt;需要做的。&lt;/p&gt;

&lt;h2 id=&quot;6-1-introduction-to-consensus&quot;&gt;6-1 Introduction to consensus&lt;/h2&gt;

&lt;p&gt;对共识问题的简单描述：几个节点想要对某个值达成一致（aggreement）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个或者多个节点可能会提议（porpose）一个值，共识算法将决定（decide）其中一个值。共识算法保证决定的值是从提议的值中选取，所有节点都决定相同的值（除了故障节点）&lt;/strong&gt;。&lt;strong&gt;并且最终决定的值是不变的（当节点决定了某个值，就不会改变）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;需要说明，&lt;strong&gt;共识（consensus）与全序广播（total order broadcast）是等价的&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了将全序广播转化为共识，想要提议 value 的节点需要将其广播，全序广播传递的第一条消息被认为是决定值&lt;/li&gt;
  &lt;li&gt;为了将共识转化为全序广播，使用共识协议的一个单独实例来决定发送的消息。想要广播消息的节点会在一轮共识中提议该消息。共识算法之后确保所有节点对将要发送的消息序列达成一致&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个最著名的共识算法：&lt;strong&gt;&lt;em&gt;Paxos &amp;amp; Raft&lt;/em&gt;&lt;/strong&gt;。最初的 Paxos 只会对单个值达成共识。&lt;strong&gt;&lt;em&gt;Multi-Paxos&lt;/em&gt;&lt;/strong&gt; 是 Paxos 的推广，提供 FIFO-total order 广播。Raft 默认提供 FIFO-total order 广播。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/46.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-1-1-consensus-system-models&quot;&gt;6-1-1 Consensus system models&lt;/h3&gt;

&lt;p&gt;共识算法的关键取决于系统模型。Paxos &amp;amp; Raft 假设系统模型为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网络：fair-loss link&lt;/li&gt;
  &lt;li&gt;节点行为：crash-recovery&lt;/li&gt;
  &lt;li&gt;同步模型：partial synchrony&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;对于网络及节点行为的假设可以削弱为为拜占庭模型&lt;/em&gt;，此类算法用于区块链中。然而，&lt;em&gt;拜占庭容错共识算法比非拜占庭算法复杂得多，效率更低&lt;/em&gt;。因此我们更专注于 fair-loss link &amp;amp; crash-recovery 算法，这些算法在实际环境中很有用（比如受信网络的数据中心）。&lt;/p&gt;

&lt;p&gt;另一方面，&lt;em&gt;同步模型的假设不能从 partial synchrony 削弱为 asynchrony&lt;/em&gt;。因为共识算法需要故障检测器（failure detector），而故障检测器需要本地时钟来触发超时。如果没有时钟，那么确定性共识算法可能不会终止。事实上已经证明，&lt;em&gt;任何确定性异步（asynchronous）算法都不能解决保证终止的共识问题&lt;/em&gt;。这一事实被称为 &lt;strong&gt;FLP Result&lt;/strong&gt;，该理论是分布式系统中最重要的理论之一。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is no deterministic consensus algorithm that is guaranteed to terminate in an asynchronous crash-stop system model.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;6-1-2-leader-election&quot;&gt;6-1-2 Leader election&lt;/h3&gt;

&lt;p&gt;大多数共识算法的核心是&lt;strong&gt;选举（elect）流程&lt;/strong&gt;：当现存 leader 节点不可用时，需要选举一个新的 leader。不同共识算法之间的选举细节有所不同，我们将重点讨论 Raft 算法采取的方法（对其他算法也有借鉴意义）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当其他节点检测到 leader 不可用时（通常是因为持续一段时间没有从 leader 收到任何消息），就会发起 leader 选举流程。其中一个节点成为候选人（candicate），并要求其他节点投票是否接受该候选人作为新的 leader。如果法定数目（quorum）的节点投票给该候选人，那么其就会成为新的 leader&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果使用的是 majority quorum，只要大多数节点可用并且相互间可以通信，投票就会成功。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果同时存在多个 leader，不同的 leader 做的决定可能不一样，会导致违反全序广播的安全属性（被称为 &lt;strong&gt;split brain&lt;/strong&gt;）。因此，我们期望在进行 leader 选举时，任何时候都只会有一个 leader。在 Raft 算法中，“任何时候”的概念用&lt;strong&gt;任期（term）&lt;/strong&gt;来表述：&lt;strong&gt;&lt;em&gt;term 是一个整数，在开始进行 leader 选举时递增&lt;/em&gt;&lt;/strong&gt;。当 leader 当选时，&lt;strong&gt;投票算法能够保证在特定任期（term）内只会有一个 leader&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;不同任期内有不同的 leader&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/47.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-1-3-can-we-guarantee-there-is-only-one-leader&quot;&gt;6-1-3 Can we guarantee there is only one leader?&lt;/h3&gt;

&lt;p&gt;我们之前讨论过，在 partially synchronous 系统中，基于超时的故障检测器可能不准确：比如由于网络延迟增加，可能会将一个功能正常的节点标识为故障。考虑下面一个场景：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/48.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;node 1 是任期 t 内的 leader；node 1 与 node 2, 3 之间的网络暂时中断&lt;/li&gt;
  &lt;li&gt;node 2, 3 可能会检测到 node 1 故障，并在任期 t+1 内选举新的 leader；虽然 node 1 仍在正常运行&lt;/li&gt;
  &lt;li&gt;node 1 可能并没有注意到网络故障，也不知道已经选举出新 leader&lt;/li&gt;
  &lt;li&gt;因此，有两个节点都认为自己是 leader&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于这个原因，即使一个节点已经当选 leader，也需要谨慎操作。&lt;strong&gt;因为在任何时候，系统内都可能包含另一个更大任期（term）并且其从未感知到的 leader&lt;/strong&gt;。如果任何操作只需要 leader 同意，那么就会变得不安全。相反，&lt;strong&gt;当 leader 想要决定下一条准备发送的消息时，必须再次请求其他节点以得到法定节点数（quorum）的确认&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/49.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在第一次往返中，由于其他两个节点的投票，左侧节点当选为 leader，任期为 t&lt;/li&gt;
  &lt;li&gt;在第二次往返中，leader 提议下一条将要发送的消息，这两个 follower 确认没有比任期 t 更大的 leader 存在&lt;/li&gt;
  &lt;li&gt;最后，leader 发送消息 m 并广播给 followers，以此来保证之间的一致&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果另一个新的 leader 当选，那么旧 leader 就可以通过第二次往返中的确认消息发现新 leader。因为至少有一个节点参与第二轮 leader 选举并投票给新 leader。因此，&lt;strong&gt;即使多个 leader 可能同时存在，旧 leader 将不可能再决定新的消息，从而确保算法的安全性&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;6-2-the-raft-consensus-algorithm&quot;&gt;6-2 The Raft consensus algorithm&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;原文在这部分详细介绍了 Raft 算法的实现，鉴于 Raft 论文更详细，因此不在此处讨论&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h1 id=&quot;7-replica-consistency&quot;&gt;7-Replica consistency&lt;/h1&gt;

&lt;p&gt;在上文我们已经了解到两种复制方式：1. 使用 read/write quorum；2. 通过全序广播实现状态机复制。我们期望副本对相同的数据保持一致，但是没有准确定义 “consistent” 的含义。&lt;/p&gt;

&lt;p&gt;“consistency” 在不同的上下文中具有不同的含义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;在事务中，ACID 中的 C 代表一致性，即状态的属性&lt;/strong&gt;：数据库处于一致或者不一致的状态是指，该状态满足或者违反了应用程序定义的某些不变量。&lt;/li&gt;
  &lt;li&gt;在复制上下文中，我们非正式地使用&lt;strong&gt;一致性来表示副本之间的关系&lt;/strong&gt;：期望一个副本与另一个副本保持一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于对一致性没有一个真正的定义，我们讨论的是各种&lt;strong&gt;一致性模型（consistency models）&lt;/strong&gt;。之前介绍过一个一致性模型，read-after-write consistency：限制了同一节点写入同一项数据后的读取值。&lt;/p&gt;

&lt;h2 id=&quot;7-1-two-phase-commit&quot;&gt;7-1 Two-phase commit&lt;/h2&gt;

&lt;p&gt;首先讨论&lt;strong&gt;分布式事务（distributed transaction）&lt;/strong&gt;的一致性问题：&lt;em&gt;在多个节点上进行读写的事务操作&lt;/em&gt;。分布在这些节点上的数据可以是同一数据集的副本，也可以是一份数据集的不同子集；分布式事务对这两种情况都适用。&lt;/p&gt;

&lt;p&gt;事务的关键性质是原子性（atomicity）。当一个事务跨越多个节点时，我们仍然期望整个事务具有原子性：&lt;em&gt;要么所有节点必须提交事务并持久化更新操作，要么所有节点必须中止事务并丢弃或回滚其更新&lt;/em&gt;。因此，需要不同节点就事务是提交还是放弃达成一致（agreement）。&lt;/p&gt;

&lt;p&gt;这里说的一致与第 6 节介绍共识所说的一致并不相同，尽管两者看起来都是达成某种协议。下图介绍两者的区别：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/50.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;确保多个节点间实现原子提交最常见的算法是 &lt;strong&gt;Two-phase commit (2PC)&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;也有个 three-phase commit protocol&lt;strong&gt;，&lt;/strong&gt;不过其假设了不切实际的同步模型，因此不讨论&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;两阶段提交的流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/51.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当使用两阶段提交时，client 首先在参与事务的每个副本上执行常规的单节点事务，并在这些事务中执行正常的读写操作&lt;/li&gt;
  &lt;li&gt;当 client 准备提交事务时，会向 &lt;strong&gt;transaction coordinator&lt;/strong&gt; 发送提交请求：coordinator 是用于管理两阶段提交的节点（在某些系统中，coordinator 是 client 的一部分）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阶段一：coordinator 首先向参与事务的每个副本发送一个 prepare 消息；每个副本回复其能否提交事务&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;副本此时还没有真正提交事务，但是必须能够保证在阶段二收到 coordinator 的确定之后能够提交事务。这意味着，&lt;strong&gt;&lt;em&gt;副本必须将事务的所有更新写入磁盘，并在回复 prepare 消息之前检查任何完整性约束，同时继续为事务保留任何锁&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;coordinator 收集响应，并决定是否真正提交事务。如果所有节点回复 ok，coordinator 决定提交事务。如果任意节点想要中止事务，或者任意节点在指定超时时间没有回复，那么 coordinator 决定中止事务。&lt;/li&gt;
  &lt;li&gt;阶段二：coordinator 将最终决定发送给所有副本，副本收到后按照指示提交或中止事务。如果决定要提交，每个副本都保证能够提交事务（之前的 prepare 请求奠定了基础）。如果决定中止，副本将回滚事务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两阶段提交的问题是，coordinator 存在单点故障（single point of failure）。coordinator 可以将提交/中止事务的决定写入稳定存储中，以应对节点崩溃。但是可能会有很多事务在 coordintor 节点崩溃时，已经准备好单还没来得及提交或中止。&lt;strong&gt;&lt;em&gt;任何不确定的事务只能等到 coordinator 恢复之后才能结束：参与事务的节点不能单方面决定提交还是中止事务，因为可能会导致与 coordinator &amp;amp; 其他节点间的不一致，从而违反原子性&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过使用共识算法或者全序关系广播可以避免 coordinator 单点故障&lt;/strong&gt;。下图展示了基于 Paxos Commit 实现两阶段提交容错机制：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/61.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/62.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;核心思想是，&lt;strong&gt;每个参与事务的节点通过全序广播传播自己对于提交还是中止事务的投票&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;如果节点 A 怀疑节点 B 已经故障（比如在超时时间内没有收到节点 B 的投票），那么节点 A 可能尝试代表 B 投中止票&lt;/em&gt;。这就引入了一个竞争条件：如果节点 B 因为延迟，可能会在 A 代表自己投票的同时，广播自己的提交票。&lt;/p&gt;

&lt;p&gt;所有投票都会通过全序广播发送给每个节点，每个接受者独立计算投票。&lt;/p&gt;

&lt;h2 id=&quot;7-2-linearizability&quot;&gt;7-2 Linearizability&lt;/h2&gt;

&lt;p&gt;原子提交协议是在出现故障时，保证多个副本间一致性的一种方法：确保所有事务参与者要么提交要么中止事务。然而，当多个节点并发读取 &amp;amp; 修改共享数据时，仅仅靠所有节点采取相同的提交或中止决定是不够的。&lt;/p&gt;

&lt;p&gt;接下来介绍&lt;strong&gt;用于并发系统的一致性模型，被称为 Linearizability&lt;/strong&gt;。当提到 linearizability 时，人们有时会说强一致性（strong consistency），不过强一致性的概念相当模糊，不准确。我们使用 linearizability，因为其具有准确的定义。Linearizability 的非正式定义如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/52.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Linearizability 的概念不仅在分布式系统中有用，并且在单机共享内存并发中也很有用。值得注意的是，在具有多个 CPU 的计算机上，内存访问默认不满足 linearizability。因为每个 CPU 都有自己的缓存，在一个 CPU 上的更新并不会立即反映在另一个 CPU 的缓存中。因此，单机也表现的有点像复制系统。&lt;/p&gt;

&lt;p&gt;需要注意 Linearizability 与 Serializability 并不相同，虽然都意味着按照顺序排列。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Serializability 意味着事务执行与某些串行顺序执行的效果相同，但是并没有定义顺序是什么&lt;/li&gt;
  &lt;li&gt;Linearizability 定义了操作必须返回的值，并且取决于操作的并发性与相对顺序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;系统可以同时提供 Linearizability &amp;amp; Serializability：这两者结合被称为 strict serializability 或 one-copy serializability。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linearizability 的主要目的是保证节点能够获取系统的最新状态&lt;/strong&gt;：不会访问到过期的数据。之前讨论的写后读一致性虽然也能保证读取最新的值，但是该一致性模型的读写操作发生在同一个节点；而 Linearizability 将其推广到不同节点同时进行的操作。&lt;/p&gt;

&lt;h3 id=&quot;7-2-1-abd-making-quorum-readswrites-linearizable&quot;&gt;7-2-1 ABD: Making quorum reads/writes linearizable&lt;/h3&gt;

&lt;p&gt;从 client 的角度来看，每次操作都需要花费一些时间。假设操作的开始时间是应用程序发出请求的时刻，结束时间是操作结果返回到应用程序的时刻。在开始与结束之间，可能会发生各种网络通信操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/55.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们把 client 读写操作的时间段看作一个矩形，在矩形内记录下操作的影响：&lt;em&gt;set(x,v) 表示将 x 更新为 v，get(x) → v 表示读取 x 的返回结果为 v&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;Linearizability 不仅涉及 get 操作与前一个 set 操作的关系，还可以一个 get 操作与其他操作关联。下面是使用 quorum 进行读写操作，但并不满足 Linearizability 的示例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/56.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意不同操作的返回结果&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/55.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;client 2 的操作在 client 3 开始前就完成，但是 client 2 读取到了新值，client 3 却读取到了旧值&lt;/li&gt;
  &lt;li&gt;该结果违反了 Linearizability&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quorum 读写也可以满足 Linearizability。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简单起见，假设 set 操作只能由一个指定节点执行（稍后会移除该假设）&lt;/li&gt;
  &lt;li&gt;set 操作与之前一样：发送给所有副本，并等待 quorum 节点确定&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于 get 操作由额外的要求：client 将读取请求发送给所有副本，并等待回复。如果某些节点的回复比其他节点新，&lt;strong&gt;client 必须将最新值回写给所有未响应最新值的副本：read repair。只有在 client 确认最新值存储在 quorum 副本之后才能结束&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/56.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该方法被称为 &lt;strong&gt;ABD 算法：保证了线性读写，因为每当读写操作完成之后，读写操作的值都存在 quorum 副本中，因此后续的 quorum 读都能保证获取到该值（或者之后的值）&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;7-2-2-linearizable-compare-and-swap-cas&quot;&gt;7-2-2 Linearizable compare-and-swap (CAS)&lt;/h3&gt;

&lt;p&gt;ABD 算法虽然能提供线性化，但是其写操作可能会覆盖数据项的值，不管之前是什么值，被称为 blind write。如果多个 client 并发更新同一个数据，ABD 算法会采用 LWW（last write win）冲突解决策略：只有一个值被保留，其他值被丢弃。&lt;/p&gt;

&lt;p&gt;在一些应用中，我们期望&lt;strong&gt;&lt;em&gt;只有在数据项没有被其他节点并发修改时才进行覆盖操作，可以通过原子的 CAS（compare-and-swap）操作来实现&lt;/em&gt;&lt;/strong&gt;。那么如何在分布式复制系统中实现线性化 CAS 操作？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linearizability 的目的是使系统表现得好像只有一份数据副本，系统操作都是原子的&lt;/strong&gt;。虽然该系统实际上是复制系统。这使得 CAS 成为线性化上下文中应该支持的操作。&lt;/p&gt;

&lt;p&gt;通过使用全序广播，可以实现线性化 &amp;amp; 存在复制系统中的 CAS 操作。只需要广播每一个需要执行的操作，并在消息到达后执行该操作，类似状态复制机。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/57.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;7-3-eventual-consistency&quot;&gt;7-3 Eventual consistency&lt;/h2&gt;

&lt;p&gt;Linearizability 是分布式系统中非常方便的同步模型，因为它保证了系统的表现看起来像是只有一份数据副本，即使实际上是分布式复制系统。使得应用程序可以忽略分布式系统中的复杂性。然而&lt;strong&gt;&lt;em&gt;这种强一致的保证有一定成本，因此 Linearizability 并不一定适合所有程序&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;性能成本&lt;/strong&gt;：ABD 算法与以全序广播为基础的线性 CAS 算法都需要通过网络发送大量消息，并且由于网络延迟需要长时间等待&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可扩展性（scalability）成本&lt;/strong&gt;：在需要 leader 对更新操作进行序列化的算法中，如 Raft，leader 可能会称为瓶颈，限制单位时间内可以执行的操作数量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也许线性化最大的问题是，&lt;strong&gt;每个操作都需要与 quorum 副本进行通信&lt;/strong&gt;。如果一个节点暂时无法与足够多的节点通信，那么其将不能进行任何操作。尽管该节点正常运行，由于网络故障导致其实际不可用。&lt;/p&gt;

&lt;p&gt;考虑这个场景，我们的手机，平板，电脑等都有日历程序，不同设备之间可以相互同步日程。假设当前设备离线后我们像要更新日程，如果该应用程序的复制协议是线性化的，那么我们将无法进行更新操作，因为离线设备无法与 quorum 节点通信。相反，日历程序允许设备离线的情况下更新日程，并在后台稍后将更新同步。&lt;/p&gt;

&lt;p&gt;这种权衡被称为 &lt;strong&gt;CAP 理论（consistency, availability, and partition tolerance）&lt;/strong&gt;。CAP 理论指出，当出现网络分区时，我们需要作出选择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果选择线性一致性，那么一些节点就不能响应请求，因为其不能与 quorum 节点通信&lt;/li&gt;
  &lt;li&gt;也可以选择让副本继续响应请求，即使不能与其他副本进行通信。这种情况下，系统继续可用，但是不能保证线性一致性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有时，CAP 理论被表述为 “从3个中选择2个”，这种表述误导性。&lt;strong&gt;在不存在网络分区的情况下，系统可以同时保证 linearizable &amp;amp; available&lt;/strong&gt;。只有在网络分区存在的情况下才需要强制选择。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/58.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;允许每个副本仅根据其本地状态处理读写操作，而无需等待与其他副本通信的方法被称为乐观复制（optimistic replication）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;针对乐观复制系统提出了各种一致性模型，最著名的是&lt;strong&gt;最终一致性（eventual consistency）&lt;/strong&gt;。最终一致性的定义为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;如果没有对对象进行新的更新操作，最终所有读取操作都将返回上次更新的值&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;该定义比较弱：如果更新从未停止，那么该表述的前提假设就不成立&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;一个稍微强一点的一致性模型被称为 &lt;strong&gt;strong eventual consistency&lt;/strong&gt;。它基于这样一种思想：&lt;em&gt;当两个副本通信时，它们会收敛到同一状态（但是没有保证时间）&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/59.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在最终一致性和强最终一致性中，可能存在不同的节点同时更新同一对象，从而导致冲突。有许多算法被提出用来自动解决该冲突，比如 last-writer wins，或者合并冲突。&lt;/p&gt;

&lt;p&gt;下图是对我们讨论的一致性模型的总结：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/60.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">翻译自 DDIA 作者 Martin Kleppmann 分布式系统课程：视频; 课件</summary></entry><entry><title type="html">状语从句</title><link href="http://localhost:4000/adverbial-clause.html" rel="alternate" type="text/html" title="状语从句" /><published>2022-03-02T00:00:00+08:00</published><updated>2022-03-02T00:00:00+08:00</updated><id>http://localhost:4000/adverbial-clause</id><content type="html" xml:base="http://localhost:4000/adverbial-clause.html">&lt;h1 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h1&gt;
&lt;p&gt;状语从句指句子用作状语时, 起副词作用的句子。它可以修饰谓语、非谓语动词、定语、状语或整个句子。根据其作用可分为时间、地点、原因、条件、目的、结果、让步、方式和比较等从句。
状语从句一般由连词(从属连词)引导，也可以由词组引起。从句位于句首或句中时通常用逗号与主句隔开，位于句尾时可以不用逗号隔开。&lt;/p&gt;

&lt;h1 id=&quot;2-地点状语从句&quot;&gt;2-地点状语从句&lt;/h1&gt;
&lt;h2 id=&quot;2-1-介绍&quot;&gt;2-1-介绍&lt;/h2&gt;

&lt;p&gt;地点状语从句表示地点，方位，通常由 where 引导。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He lives there. (there 做地点状语)&lt;/li&gt;
  &lt;li&gt;He lives in Inner Mongolia. (in inner Mongolia 做地点状语)&lt;/li&gt;
  &lt;li&gt;He lives where the climate is mild. (where … 做地点状语从句)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-2-引导词&quot;&gt;2-2-引导词&lt;/h2&gt;

&lt;p&gt;常用引导词 &lt;strong&gt;where&lt;/strong&gt;，特殊引导词 &lt;strong&gt;wherever, anywhere, everywhere.&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;引导词&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;where&lt;/td&gt;
      &lt;td&gt;在……地方&lt;/td&gt;
      &lt;td&gt;通常表示一个确定的地方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wherever&lt;/td&gt;
      &lt;td&gt;无论什么地方&lt;/td&gt;
      &lt;td&gt;表示任何地方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;anywhere&lt;/td&gt;
      &lt;td&gt;任何地方&lt;/td&gt;
      &lt;td&gt;表示任何地方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;everywhere&lt;/td&gt;
      &lt;td&gt;到处&lt;/td&gt;
      &lt;td&gt;表示任何地方&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;We must camp where we can get water.&lt;/li&gt;
  &lt;li&gt;They will go where they are happy.&lt;/li&gt;
  &lt;li&gt;Wherever there is political upheaval, invariably there are refugees.&lt;/li&gt;
  &lt;li&gt;We have sworn to fight cruelty wherever we find it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-3-地点状语从句与定语从句的区别&quot;&gt;2-3-地点状语从句与定语从句的区别&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;where 引导定语从句时，where 是关系副词，并且 &lt;strong&gt;where 在从句中作地点状语&lt;/strong&gt;，&lt;strong&gt;前面有表示地点的先行词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;The bookshop where I bought this book is not far from here.&lt;/li&gt;
      &lt;li&gt;This is the house where I lived two years ago.&lt;/li&gt;
      &lt;li&gt;We will start at the point where we left off.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;where 引导状语从句时，where 是从属连词。&lt;strong&gt;where 引导的从句修饰主句的谓语动词，并且 where 前面没有表示地点的先行词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Wuhan lies where the Changjiang River and the Hanjiang River meet.&lt;/li&gt;
      &lt;li&gt;Make a mark where you have any doubts or questions.&lt;/li&gt;
      &lt;li&gt;I found my books where I had left them.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有时 where 引导的地点状语从句兼有抽象条件含义，&lt;strong&gt;可放在主句的前面&lt;/strong&gt;，而 where 引导的定语从句则不能
    &lt;ul&gt;
      &lt;li&gt;Where there is a will, there is a way.&lt;/li&gt;
      &lt;li&gt;Where there is water, there is life.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在有些情况下，where 引导的定语从句可转换为 where 引导的地点状语从句
    &lt;ul&gt;
      &lt;li&gt;A tall building was put up at the place where there used to be a desert
  = A tall building was put up where there used to be a desert.&lt;/li&gt;
      &lt;li&gt;Bamboo grows best in places where it is warm and where it rains often.
  = Bamboo grows best where it is warm and where it rains often.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;3-时间状语从句&quot;&gt;3-时间状语从句&lt;/h1&gt;
&lt;h2 id=&quot;3-1-介绍&quot;&gt;3-1-介绍&lt;/h2&gt;

&lt;p&gt;时间状语从句用表示时间的连词连接一个句子作状语。连接时间状语从句的连接词有: &lt;strong&gt;when, before, after, while, as soon as, until, since&lt;/strong&gt; 等。&lt;/p&gt;

&lt;h2 id=&quot;3-2-连接词&quot;&gt;3-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;3-2-1-when&quot;&gt;3-2-1 when&lt;/h3&gt;

&lt;p&gt;when 表示 “当…的时候”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;既可以表示时间段，也可以表示时间点&lt;/li&gt;
  &lt;li&gt;从句既可用延续性动词，也可用非延续性动词&lt;/li&gt;
  &lt;li&gt;从句动作&lt;strong&gt;既可与主句的动作同时发生，又可在主句的动作之前或之后发生&lt;/strong&gt;
例句：
    &lt;ul&gt;
      &lt;li&gt;When I met the Gills, I had been gardening for nearly ten years.&lt;/li&gt;
      &lt;li&gt;I’ll start to think about it when I have to write my report.&lt;/li&gt;
      &lt;li&gt;It was raining when we arrived.&lt;/li&gt;
      &lt;li&gt;When I came home, my wife was cooking dinner.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;如果 when 引导的时间状语从句的主语与主句的主语相同，并且从句的谓语动词为 be 动词时，可以省略主语 &amp;amp; be 动词&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When (you are) in trouble, ask her for help.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果 when 引导的从句的主语与主句的主语相同，可以用 &lt;strong&gt;“when + 分词” 代替状语从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When I came into the room ( When coming into the room), I found him lying there asleep.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-2-2-while&quot;&gt;3-2-2 while&lt;/h3&gt;

&lt;p&gt;while 表示 “当…的时候”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;只能表示一段时间，不能表示时间点&lt;/li&gt;
  &lt;li&gt;从句的谓语动词只能是延续性的&lt;/li&gt;
  &lt;li&gt;从句动作&lt;strong&gt;只能与主句同时发生或者存在&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例句：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Don’t interrupt him while he is thinking.&lt;/li&gt;
  &lt;li&gt;While Jim was mending his bike, Lin Tao came to see him.&lt;/li&gt;
  &lt;li&gt;She got married while working as a waitress.&lt;/li&gt;
  &lt;li&gt;You can’t do your homework while you’re watching TV.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-2-3-as&quot;&gt;3-2-3 as&lt;/h3&gt;

&lt;p&gt;as 表示 “当…时，一边…一边”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;侧重两个动作同时发生&lt;/strong&gt;（包括同一个主语同时进行两个动作）；或者一种动作随着另一个动作的变化而变化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Another policeman has been injured as fighting continued this morning.&lt;/li&gt;
  &lt;li&gt;I slipped on the ice as I ran home.&lt;/li&gt;
  &lt;li&gt;I saw him as he was getting off the bus.&lt;/li&gt;
  &lt;li&gt;As the wind rose, the noise increased.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-条件状语从句&quot;&gt;4-条件状语从句&lt;/h1&gt;
&lt;h2 id=&quot;4-1-介绍&quot;&gt;4-1-介绍&lt;/h2&gt;

&lt;p&gt;条件是指某一事情实现之后（状语从句中的动作），其他事情才会发生（主句中的动作），通常表示“如果”。
&lt;strong&gt;在句子中做条件状语的从句叫做条件状语从句（通常置于句首或句尾）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;引导条件状语从句的常用连词是 if，表示“如果”。其他连词有：&lt;strong&gt;unless&lt;/strong&gt;（除非），&lt;strong&gt;as/so long as&lt;/strong&gt;（只要）， &lt;strong&gt;providing/provided that&lt;/strong&gt;（假如），&lt;strong&gt;supposing that&lt;/strong&gt;, &lt;strong&gt;in case,&lt;/strong&gt; &lt;strong&gt;on condition that&lt;/strong&gt; 等。&lt;/p&gt;

&lt;h2 id=&quot;4-2-连接词&quot;&gt;4-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;4-2-1-if&quot;&gt;4-2-1 if&lt;/h3&gt;

&lt;p&gt;if 引导的条件状语从句分为两类：一种是真实条件句，一种是虚拟条件句。&lt;/p&gt;

&lt;p&gt;if 引导的条件状语从句表示在某种条件下，某事发生的可能性大。&lt;/p&gt;

&lt;p&gt;例句：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If you ask him, he will help you.&lt;/li&gt;
  &lt;li&gt;If you fail in the exam, you will let him down.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;if 引导的条件状语从句既可以放在主句之前，也可以放在主句之后。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If it rains, we will stop playing. = We will stop playing if it rains.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如果主句是将来时，从句要用一般现在时代替一般将来时&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If he runs, he will get there in time.&lt;/li&gt;
  &lt;li&gt;The cat will scratch you if you if you pull her tail.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-2-unless&quot;&gt;4-2-2 unless&lt;/h3&gt;

&lt;p&gt;unless 表示“除非，若不，除非在……的时候”，等同于 if … not。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You will fail to arrive there in time unless you start earlier.&lt;/li&gt;
  &lt;li&gt;Unless it rains, the game will be played.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-3-as-long-as--so-long-as&quot;&gt;4-2-3 as long as &amp;amp; so long as&lt;/h3&gt;

&lt;p&gt;as/so long as 表示“只要…”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;As long as my heart still beats, I will go on working for the people.&lt;/li&gt;
  &lt;li&gt;As long as the green hills are there, one need not worry about firewood.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-4-in-case&quot;&gt;4-2-4 in case&lt;/h3&gt;

&lt;p&gt;in case 表示“如果，万一”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In case I forget, please remind me about it.&lt;/li&gt;
  &lt;li&gt;Dad brought a notebook along to the beach, in case he was seized by sudden inspiration.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-5-on-condition-that&quot;&gt;4-2-5 on condition that&lt;/h3&gt;

&lt;p&gt;on condition (that) 表示“在…条件下”，引导的条件是&lt;strong&gt;主句发生的前提条件或者唯一条件&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I can tell you the truth on condition that you promise to keep a secret.&lt;/li&gt;
  &lt;li&gt;You can go swimming on condition (that) you don’t go too far from the river bank.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-6-supposing&quot;&gt;4-2-6 supposing&lt;/h3&gt;

&lt;p&gt;supposing 表示“如果，假设”，引导的条件状语从句表示一种假设的条件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Supposing it rains, shall we continue the sports meeting?&lt;/li&gt;
  &lt;li&gt;Supposing anything should go wrong, what would you do then?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-7-provided-that&quot;&gt;4-2-7 provided that&lt;/h3&gt;

&lt;p&gt;provided (that) 表示“假如，除非，以…为条件”，引导的从句表示一种假设条件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He will sign the contract provided we offer more favorable terms.&lt;/li&gt;
  &lt;li&gt;He won’t be against us in the meeting provided that we ask for his advice in advance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5-原因状语从句&quot;&gt;5-原因状语从句&lt;/h1&gt;
&lt;h2 id=&quot;5-1-介绍&quot;&gt;5-1-介绍&lt;/h2&gt;

&lt;p&gt;原因状语从句用来解释某件事发生的原因，最常用的从属连词为 &lt;strong&gt;because&lt;/strong&gt;，强调原因。&lt;/p&gt;

&lt;p&gt;除此之外，还有其他从属连词：&lt;strong&gt;as, since, for, now (that), when, seeing (that), considering (that), given (that), in that, for the reason that&lt;/strong&gt; 等。&lt;/p&gt;

&lt;h2 id=&quot;5-2-连接词&quot;&gt;5-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;5-2-1-because&quot;&gt;5-2-1 because&lt;/h3&gt;

&lt;p&gt;because 引导的原因状语从句一般放在主句后面。当从句放在主句前面时，需要用逗号隔开；而从句在后面时，可用或者不用逗号分隔。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We didn’t go for an outing last Saturday, &lt;strong&gt;&lt;em&gt;because&lt;/em&gt;&lt;/strong&gt; it was raining hard the whole day.&lt;/li&gt;
  &lt;li&gt;We didn’t go for an outing last Saturday &lt;strong&gt;&lt;em&gt;because&lt;/em&gt;&lt;/strong&gt; it was raining hard the whole day.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Because&lt;/em&gt;&lt;/strong&gt; it was raining hard the whole day, we didn’t go for an outing last Saturday.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;because 的&lt;strong&gt;语气一般比较强&lt;/strong&gt;，常用来回答 why 引导的疑问句。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;Why didn’t you come to my birthday party last night? - Because my sister was ill. I had to take care of her the whole night.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;because 不能与 so 连用&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;because of 也表示原因，为介词短语，后跟名词，代词，动名词及其短语。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He can’t go to school &lt;strong&gt;&lt;em&gt;because of&lt;/em&gt;&lt;/strong&gt; his illness.&lt;/li&gt;
  &lt;li&gt;He can’t go to school &lt;strong&gt;&lt;em&gt;because&lt;/em&gt;&lt;/strong&gt; he is ill.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;not because&lt;/strong&gt; 结构中的否定词有时用来否定主句，有时用来否定从句，容易引起歧义。如果想明否定主句，最好在 because 从句前用逗号隔开。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I didn’t go there yesterday, because I was afraid.（因为害怕，所以没去）&lt;/li&gt;
  &lt;li&gt;I went there yesterday, not because I was afraid.（去那里，并不是因为害怕）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-2-since&quot;&gt;5-2-2 since&lt;/h3&gt;

&lt;p&gt;since 可以理解为“既然”，用来表示双方已知的，显然的理由；相当于 now that，不过更为正式；语气比 because 弱，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;since 引导的原因状语从句常放在主句之前&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Since&lt;/em&gt;&lt;/strong&gt; you are free today, can you help me with the housework?&lt;/li&gt;
  &lt;li&gt;Now that you are grown up, you should rely on yourself.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;since 除了引导原因状语从句，还可以在后面接时间或者过去发生的事情，表示“自从…以来”。此时，&lt;strong&gt;从句常用一般过去时，主句常用完成时&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I have lived here since 2015.&lt;/li&gt;
  &lt;li&gt;She has learned English since she was two years old.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-3-as&quot;&gt;5-2-3 as&lt;/h3&gt;

&lt;p&gt;as 引导原因状语从句时，表示“附带说明的，双方已知的原因”，语气比 since 弱。位置比较灵活，但是常放在主句之前。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;As the wage of the job was low, there were few applicants for it.&lt;/li&gt;
  &lt;li&gt;As you are tired, you had better take a rest.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;除了引导原因状语从句，as 也可以用来引导时间状语从句与方式状语从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A sudden chill of horror sweeps over her as she feels the drip of saliva upon her hand.（时间状语从句）&lt;/li&gt;
  &lt;li&gt;She did it as I had told her to.（方式状语从句）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-4-for&quot;&gt;5-2-4 for&lt;/h3&gt;

&lt;p&gt;for 表示原因，但是并&lt;strong&gt;不构成主句行为发生的直接原因&lt;/strong&gt;，只是提供一些辅助性的补充说明。&lt;/p&gt;

&lt;p&gt;for 引导并列句，且只能放在主句之后并用逗号隔开。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It must have rained last night, for the street is wet all over.（主句与从句不构成直接因果关系）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-5-其他连接词&quot;&gt;5-2-5 其他连接词&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;She is much more mobile &lt;strong&gt;&lt;em&gt;now that&lt;/em&gt;&lt;/strong&gt; she has a car.（既然）&lt;/li&gt;
  &lt;li&gt;I won’t tell you &lt;strong&gt;&lt;em&gt;when&lt;/em&gt;&lt;/strong&gt; you won’t listen.（既然）&lt;/li&gt;
  &lt;li&gt;He looks young &lt;strong&gt;&lt;em&gt;considering&lt;/em&gt;&lt;/strong&gt; his age.（考虑到）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Given that&lt;/em&gt;&lt;/strong&gt; he was still a boy, I forgave him.（考虑到）&lt;/li&gt;
  &lt;li&gt;We aren’t going &lt;strong&gt;&lt;em&gt;for the simple reason that&lt;/em&gt;&lt;/strong&gt; we can’t afford it.（因为）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-目的状语从句&quot;&gt;6-目的状语从句&lt;/h1&gt;
&lt;h2 id=&quot;6-1-介绍&quot;&gt;6-1-介绍&lt;/h2&gt;

&lt;p&gt;目的状语从句：在句子中充当目的状语的从句，主要用来补充说明主句中&lt;strong&gt;谓语动词发生的目的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He got up early &lt;strong&gt;&lt;em&gt;so as to&lt;/em&gt;&lt;/strong&gt; catch the first morning bus.（so as to… 做目的状语）&lt;/li&gt;
  &lt;li&gt;He got up early &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; he could catch the first morning bus.（so that… 做目的状语从句）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-2-连接词&quot;&gt;6-2-连接词&lt;/h2&gt;

&lt;p&gt;连接目的状语从句的连接词有：&lt;strong&gt;so that, in order that, for fear that, in case&lt;/strong&gt; 等。&lt;/p&gt;

&lt;p&gt;目的状语从句的谓语动中通常含有：may, could, will, might, can, should, would 等情态动词。&lt;/p&gt;

&lt;h3 id=&quot;6-2-1-so-that&quot;&gt;6-2-1 so that&lt;/h3&gt;

&lt;p&gt;so that 表示“以便，为了”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I set up the computer so that they could work from home.&lt;/li&gt;
  &lt;li&gt;I’ll give you all the facts so that you can judge for yourself.&lt;/li&gt;
  &lt;li&gt;They put a screen around his bed so that the doctor could examine him.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;so that 有时可以&lt;strong&gt;省略 so&lt;/strong&gt;，只用 that 连接。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bring it closer (so) that I may see it better.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当主句与从句的主语相同时，可以用 &lt;strong&gt;so as to do 短语替代 so that&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;One should learn from past mistakes &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; he or she can avoid falling into the same old trap again.&lt;/li&gt;
  &lt;li&gt;One should learn from past mistakes &lt;strong&gt;&lt;em&gt;so as to&lt;/em&gt;&lt;/strong&gt; avoid falling into the same old trap again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意 so that 与 so … that 的区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;so that 表示目的状语从句：
    &lt;ul&gt;
      &lt;li&gt;He went to bed very early last night &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; he could get up early this morning.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;so … that 表示结果状语从句：
    &lt;ul&gt;
      &lt;li&gt;He stayed up &lt;strong&gt;&lt;em&gt;so&lt;/em&gt;&lt;/strong&gt; late last night &lt;strong&gt;&lt;em&gt;that&lt;/em&gt;&lt;/strong&gt; he couldn’t get up early this morning.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;6-2-2-in-order-that&quot;&gt;6-2-2 in order that&lt;/h3&gt;

&lt;p&gt;in order that 表示“为了，以便”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They flew there &lt;strong&gt;&lt;em&gt;in order that&lt;/em&gt;&lt;/strong&gt; they might be in time to attend the opening ceremony.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;In order that&lt;/em&gt;&lt;/strong&gt; we might get there on time, we should set out early.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当主句与从句的主语相同时，可用 &lt;strong&gt;in order to do 短语代替 in order that 从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I came &lt;strong&gt;&lt;em&gt;in order that&lt;/em&gt;&lt;/strong&gt; I could see Jack.&lt;/li&gt;
  &lt;li&gt;I came &lt;strong&gt;&lt;em&gt;in order to&lt;/em&gt;&lt;/strong&gt; see Jack.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-2-3-for-fear-that&quot;&gt;6-2-3 for fear that&lt;/h3&gt;

&lt;p&gt;for fear that 表示“以免，唯恐”。&lt;/p&gt;

&lt;p&gt;如果从句的情态动词时 should 时，此时 should 可以省略。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He told us to keep quiet &lt;strong&gt;&lt;em&gt;for fear that&lt;/em&gt;&lt;/strong&gt; we might disturb others.&lt;/li&gt;
  &lt;li&gt;We hurried along &lt;strong&gt;&lt;em&gt;for fear that&lt;/em&gt;&lt;/strong&gt; we (should) be late.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当主句与从句的主语相同时，可以用 &lt;strong&gt;for fear of doing 短语代替 for fear that 从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We spoke quietly &lt;strong&gt;&lt;em&gt;for fear that&lt;/em&gt;&lt;/strong&gt; we should wake the guards.&lt;/li&gt;
  &lt;li&gt;We spoke quietly &lt;strong&gt;&lt;em&gt;for fear of&lt;/em&gt;&lt;/strong&gt; waking the guards.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-2-4-in-case&quot;&gt;6-2-4 in case&lt;/h3&gt;

&lt;p&gt;in case 表示“以防，万一”。&lt;/p&gt;

&lt;p&gt;从句一般使用情态动词 should，且 should 可省略；从句表示虚拟语气。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They watched him closely &lt;strong&gt;&lt;em&gt;in case&lt;/em&gt;&lt;/strong&gt; he (should) escape.&lt;/li&gt;
  &lt;li&gt;I stopped suddenly &lt;strong&gt;&lt;em&gt;in case&lt;/em&gt;&lt;/strong&gt; he (should) think that I was showing off.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;in case 还可以表示“假如，如果”。此时引导的从句不再使用虚拟语气，一般也不使用情态动词&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In case she comes back, let me know immediately.&lt;/li&gt;
  &lt;li&gt;I keep a warm coat at work in case it suddenly turns cold.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;in case of 表示“假如，如果发生”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In case of fire, ring the alarm bell.&lt;/li&gt;
  &lt;li&gt;We have an auxiliary generator in case of power cuts.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;7-结果状语从句&quot;&gt;7-结果状语从句&lt;/h1&gt;
&lt;h2 id=&quot;7-1-介绍&quot;&gt;7-1-介绍&lt;/h2&gt;

&lt;p&gt;结果状语从句：在复合句中表示&lt;strong&gt;主句动作所导致结果&lt;/strong&gt;的从句，用于补充说明主句谓语动词发生的结果；通常位于主句的后面。&lt;/p&gt;

&lt;h2 id=&quot;7-2-连接词&quot;&gt;7-2-连接词&lt;/h2&gt;

&lt;p&gt;引导结果状语从句的连词主要有：so that, so…that, such…that 等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;so 用在形容词或副词之前，such 用在名词之前&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7-2-1-so-that&quot;&gt;7-2-1 so that&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;so that 既可以引导目的状语从句，表示“为了，以便”；也可以引导结果状语从句，表示“因此，以至于”&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;当引导目的状语从句时，从句一般包含情态动词&lt;/strong&gt;；当引导结果状语从句时，一般不包含&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;You make friends with people and then make unreasonable demands &lt;strong&gt;&lt;em&gt;so tha&lt;/em&gt;&lt;/strong&gt;t they reject you.（结果状语从句）&lt;/li&gt;
    &lt;li&gt;I’ll give you all the facts &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; you can judge for yourself.（目的状语从句）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7-2-2-sosuchthat&quot;&gt;7-2-2 so/such…that&lt;/h3&gt;

&lt;p&gt;so/such…that 表示“如此…以至于…”。so 是副词，修饰形容词或副词，such 是形容词，修饰名词。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;so + adj./adv. + that&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;He speaks &lt;strong&gt;&lt;em&gt;so fast tha&lt;/em&gt;&lt;/strong&gt;t no one can catch him.&lt;/li&gt;
      &lt;li&gt;The ball struck him &lt;strong&gt;&lt;em&gt;so hard tha&lt;/em&gt;&lt;/strong&gt;t he nearly fell into the water.&lt;/li&gt;
      &lt;li&gt;I was &lt;strong&gt;&lt;em&gt;so busy here that&lt;/em&gt;&lt;/strong&gt; I had no time to write a letter.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;so + adj./adv. + (a/an) + n +that&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;There is &lt;strong&gt;&lt;em&gt;so rapid an increase&lt;/em&gt;&lt;/strong&gt; in population that a food shortage is caused.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;such ＋ a(an) ＋ adj. ＋ 可数名词单数 ＋ that&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;He is &lt;strong&gt;&lt;em&gt;such a clever boy&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;that&lt;/em&gt;&lt;/strong&gt; everybody likes him.&lt;/li&gt;
      &lt;li&gt;He was &lt;strong&gt;&lt;em&gt;such an honest man that&lt;/em&gt;&lt;/strong&gt; he was praised by the teacher.&lt;/li&gt;
      &lt;li&gt;He’s such a good person that we mustn’t blame him.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;such ＋ adj. ＋ 复数可数名词 ＋ that&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;He told us &lt;strong&gt;&lt;em&gt;such horrible stories that&lt;/em&gt;&lt;/strong&gt; we all scared.&lt;/li&gt;
      &lt;li&gt;They are &lt;strong&gt;&lt;em&gt;such fine teachers that&lt;/em&gt;&lt;/strong&gt; we all hold them in great respect.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;such + adj. + 不可数名词 + that&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;He has made &lt;strong&gt;&lt;em&gt;such great progress that&lt;/em&gt;&lt;/strong&gt; the teachers are pleased with him.&lt;/li&gt;
      &lt;li&gt;It is &lt;strong&gt;&lt;em&gt;such nice weather that&lt;/em&gt;&lt;/strong&gt; I would like to go to the beach.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意：&lt;strong&gt;so 与表示数量的代词 many, few, much, little 等连用已经形成固定搭配&lt;/strong&gt;， 这种情况下不能换用 such 的对应结构表示。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Our country has &lt;strong&gt;&lt;em&gt;so much coal&lt;/em&gt;&lt;/strong&gt; that she can export large quantities.&lt;/li&gt;
  &lt;li&gt;There were &lt;strong&gt;&lt;em&gt;so many people&lt;/em&gt;&lt;/strong&gt; in the street watching the fire that firefighters could not get close to the building.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当结果状语从句的主语与主句的主语相同时，&lt;strong&gt;可省略从句主语，从句谓语变非谓语&lt;/strong&gt;。此时 so… 就要换一个形式来陈述。&lt;strong&gt;so 是中性程度副词，如果从句是肯定句，那么 so 就要换为 enough&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;enough 只能在所修饰词的后面&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;He is so old that he can go to school alone. = He is old enough to go to school alone.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;8-让步状语从句&quot;&gt;8-让步状语从句&lt;/h1&gt;
&lt;h2 id=&quot;8-1-介绍&quot;&gt;8-1-介绍&lt;/h2&gt;

&lt;p&gt;让步状语从句一般翻译为 “尽管…”，“即使…”。&lt;/p&gt;

&lt;p&gt;引导让步状语从句的连接词有：&lt;strong&gt;though, although, as, even though, whether … or …, no matter + 疑问词, 疑问词-ever, regardless of + 名词/名词短语/名词从句, despite, despite of&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要注意，although，though 不可以与 but 连用，但是可以和 yet, still 连用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;8-2-连接词&quot;&gt;8-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;8-2-1-although--though&quot;&gt;8-2-1 although &amp;amp; though&lt;/h3&gt;

&lt;p&gt;这两个连词都表示“虽然，尽管”，一般情况下可以互换使用。&lt;/p&gt;

&lt;p&gt;though 通常用于口语，although 常用于正式情况。&lt;strong&gt;&lt;em&gt;两者均不可以和 but 连用，但是可以和 yet, still, nevertheless 连用&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Although/Though he was exhausted, he(still) kept on working.&lt;/li&gt;
  &lt;li&gt;Although/Though he is known to only a few, his reputation among them is very great.&lt;/li&gt;
  &lt;li&gt;Although/Though they’re expensive, they last forever and never go out of style.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;although 引导的让步状语从句通常位于主句之前，though 引导的让步状语从句位于主句前或者主句后均可。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They’re very different, though they did seem to get on well when they met.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-2-2-as&quot;&gt;8-2-2 as&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;as 引导的让步状语从句必须用倒装&lt;/em&gt;&lt;/strong&gt;，而 though 引导的让步状语从句可用倒装，也可不用倒装。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;名词 + as/though + 主语 + 动词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;King as he was, he was unhappy.&lt;/li&gt;
      &lt;li&gt;Child as he is, he knows to help other.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;其中的动词常为&lt;strong&gt;&lt;em&gt;连系动词&lt;/em&gt;&lt;/strong&gt;，位于句首的名词为连系动词的表语。同时，位于句首的名词通常不用冠词。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Boy as/though he is, he likes to play with girls. = Though/Although he is a boy, he likes to play with girls.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;形容词 + as/though + 主语 + 动词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Patient as he was，he didn’t like waiting that long.&lt;/li&gt;
      &lt;li&gt;Beautiful though the necklace was，we thought it was over-priced.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;其中的动词也常为&lt;strong&gt;&lt;em&gt;连系动词&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;副词 + as/though + 主语 + 动词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Much as I like Paris, I couldn’t live there.&lt;/li&gt;
      &lt;li&gt;Fast as you read, you can’t finish the book in two days.&lt;/li&gt;
      &lt;li&gt;Heavily as it is raining, the football game has been decided not to be put off.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;有时候会将 much as 当作一个复合连词看，整体引导让步状语从句。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Much as I admire him as a writer，I do not like him as a man.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;动词原型 + as/though + 主语 + 动词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Object as you may, I’ll go.&lt;/li&gt;
      &lt;li&gt;Try as he might, he couldn’t solve the problem.&lt;/li&gt;
      &lt;li&gt;Lose money as I did, we got a lot of experience.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;主语后面的动词常为 could, may, might, did 等情态动词或者助动词&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果表示陈述事实，则用 do, did 等助动词；如果表示情态含义，则用情态动词&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;8-2-3-whether&quot;&gt;8-2-3 whether&lt;/h3&gt;

&lt;p&gt;由 whether 引导的让步状语从句旨在说明正反两方面的可能性都不会影响主句的意向或结果，所以&lt;strong&gt;&lt;em&gt;语气是比较强烈的&lt;/em&gt;&lt;/strong&gt;，从而也更加坚定了主句的内容。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You’ll have to attend the ceremony whether you’re free or busy.&lt;/li&gt;
  &lt;li&gt;Whether you believe it or not, it’s true.&lt;/li&gt;
  &lt;li&gt;Whether or not they win this battle, they won’t win the war.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-2-4-no-matter--疑问词--疑问词-ever&quot;&gt;8-2-4 no matter + 疑问词 = 疑问词-ever&lt;/h3&gt;

&lt;p&gt;这两个连接词均表示 “不管 … 都 …”，“…. 都 ….”，引导让步状语从句时两者可以互换。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;No matter what happened, he would not mind.&lt;/li&gt;
  &lt;li&gt;Whatever happened, he would not mind.&lt;/li&gt;
  &lt;li&gt;No matter who you are, you must keep the law.&lt;/li&gt;
  &lt;li&gt;Whoever you are, you must keep the law.&lt;/li&gt;
  &lt;li&gt;When anyone does something for you, no matter how small and no matter whether he’s a superior or servant, it’s proper to say “Thank you”.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;no matter + 疑问词只能引导状语从句，而疑问词-ever 还可以引导名词性从句&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Whatever (=No matter what) you say, I won’t believe you.(让步状语从句)&lt;/li&gt;
  &lt;li&gt;I’ll eat whatever (≠no matter what) you give me.(宾语从句)&lt;/li&gt;
  &lt;li&gt;Whoever comes will be welcome.(主语从句)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;while 有时也可以引导让步状语从句，通常位于句首&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;While I like the color, I don’t like the shape.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-2-5-even-though--even-if&quot;&gt;8-2-5 even though &amp;amp; even if&lt;/h3&gt;

&lt;p&gt;两者均可以引导让步状语从句，但是有细微差别。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;even if 引导的状语从句通常是假设性的，表示“即使”，“纵然”，“就算”，“哪怕”
    &lt;ul&gt;
      &lt;li&gt;Even if I have to walk all the way I’ll get there.&lt;/li&gt;
      &lt;li&gt;Even if it rains tomorrow, we won’t change our plan.&lt;/li&gt;
      &lt;li&gt;Even if you saw him pick up the money, you can’t be sure he stole it.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;even though 引导的从句内容往往是真实的，用于引出不利于主句的信息，表示“尽管”，“虽然”
    &lt;ul&gt;
      &lt;li&gt;He went out even though it was raining.&lt;/li&gt;
      &lt;li&gt;He’s the best teacher even though he has the least experience.&lt;/li&gt;
      &lt;li&gt;Even though I didn’t know anybody at the party, I had a nice time.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;此时 even though 与 though, although 可以互换。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Even though/Though/Although we all tried our best, we lost the game.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际运用中，even though 与 even if 可以不加区别地混用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Even if /Even though she laughs at him, he likes her.&lt;/li&gt;
  &lt;li&gt;We thoroughly understand each other, even if /even though we don’t always agree.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-介绍 状语从句指句子用作状语时, 起副词作用的句子。它可以修饰谓语、非谓语动词、定语、状语或整个句子。根据其作用可分为时间、地点、原因、条件、目的、结果、让步、方式和比较等从句。 状语从句一般由连词(从属连词)引导，也可以由词组引起。从句位于句首或句中时通常用逗号与主句隔开，位于句尾时可以不用逗号隔开。</summary></entry><entry><title type="html">编程珠玑: 编写正确的程序</title><link href="http://localhost:4000/programming-pearls-4.html" rel="alternate" type="text/html" title="编程珠玑: 编写正确的程序" /><published>2022-02-27T00:00:00+08:00</published><updated>2022-02-27T00:00:00+08:00</updated><id>http://localhost:4000/programming-pearls-4</id><content type="html" xml:base="http://localhost:4000/programming-pearls-4.html">&lt;h2 id=&quot;二分搜索&quot;&gt;二分搜索&lt;/h2&gt;

&lt;p&gt;二分搜索的目标是确定在排序数组 x[0…n-1] 中是否存在目标元素 t，如果存在则返回对应的索引 p，否则返回 -1。&lt;/p&gt;

&lt;p&gt;该算法实现思路为：通过&lt;strong&gt;持续跟踪数组中包含元素 t 的范围&lt;/strong&gt;（如果 t 存在数组中）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一开始，该范围是整个数组&lt;/li&gt;
  &lt;li&gt;通过将 t 与数组的中间项进行比较并抛弃一半的范围来缩小目标范围&lt;/li&gt;
  &lt;li&gt;持续步骤 2，直到在数组中找到 t 或者确定包含 t 的范围为空时为止&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在包含 n 个元素的数组中，二分搜索需要执行 $logn$ 次比较操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;线性搜索需要 $n/2$ 次比较&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;编写程序&quot;&gt;编写程序&lt;/h2&gt;

&lt;p&gt;二分搜索的思想为：&lt;strong&gt;如果 t 在 x[0…n-1] 中，那么 t 一定存在于 x 的某个特定范围内&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通过使用&lt;strong&gt;循环不变式&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mustbe(range)&lt;/code&gt; 来表示：如果 t 在数组中，那么其一定在 range 内。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;invariant:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mustbe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cumpute&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;middle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;probe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shrink&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;during&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shrinking&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;report&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;its&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;循环不变式是程序状态的断言（assertion），在循环迭代之前和之后，该断言都为真。&lt;/p&gt;

&lt;p&gt;range 用下标&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;（l, u）&lt;/code&gt;表示，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mustbe(l,u)&lt;/code&gt; 表示：如果 t 在数组中，则一定在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[l...u]&lt;/code&gt; 内。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;loop:&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;invariant:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mustbe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;t:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;t:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;t:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的伪代码中，如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[m] &amp;lt; t&lt;/code&gt;，那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[0] ≤ x[1] ... ≤ x[m] &amp;lt; t&lt;/code&gt;，所以 t 不会存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[0...m]&lt;/code&gt; 范围内。将该结论与已知条件 t 存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[l...u]&lt;/code&gt; 之内，可知 t 一定在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[m+1, u]&lt;/code&gt; 之内，即为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mustbe(m+1, u)&lt;/code&gt;。因此，通过将 l 设为 m+1 可以再次确立不变式 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mustbe(l, u)&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;理解程序&quot;&gt;理解程序&lt;/h2&gt;

&lt;p&gt;上述代码的正确性分为 3 个部分，每部分都与循环不变式相关：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;循环初次执行时，不变式为真。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;保持&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果某次迭代开始的时候 &amp;amp; 循环体执行的时候，不变式都为真，那么，循环体执行完毕的时候不变式仍为真。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;终止&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;循环能够终止，并且可以得到期望的结果（需要用到不变式所确立的事实）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 迭代&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// mustbe(l, u)&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 递归&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>kkzhang</name></author><category term="algrithom" /><summary type="html">二分搜索</summary></entry><entry><title type="html">Redis Cluster Specification</title><link href="http://localhost:4000/redis-cluster-specification.html" rel="alternate" type="text/html" title="Redis Cluster Specification" /><published>2022-02-19T00:00:00+08:00</published><updated>2022-02-19T00:00:00+08:00</updated><id>http://localhost:4000/redis-cluster-specification</id><content type="html" xml:base="http://localhost:4000/redis-cluster-specification.html">&lt;h1 id=&quot;1-main-properties-and-rationales-of-the-design&quot;&gt;1-Main properties and rationales of the design&lt;/h1&gt;

&lt;h2 id=&quot;1-1-redis-cluster-goals&quot;&gt;1-1 Redis Cluster goals&lt;/h2&gt;

&lt;p&gt;Redis Cluster 是 Redis 的分布式实现，按照优先级有以下目标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;高性能&lt;/strong&gt;（high performance）&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;线性扩展&lt;/strong&gt;（linear scalability）至 1000 个节点&lt;/li&gt;
  &lt;li&gt;没有代理；集群节点间通过&lt;strong&gt;异步复制数据&lt;/strong&gt;；不支持数据合并操作&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可接受的写入安全：在网络分区情况下，系统尽可能保存访问到多数派分区的 Client 的写操作。不过，存在一个小的时间窗口，在此期间的写入操作可能会丢失（&lt;em&gt;failover 前的写入可能会在 failover 过程中丢失&lt;/em&gt;）。如果 Client 的写入操作连接到少数派分区，则这个丢失时间窗口会更大。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;网络分区时，集群节点被划分成多数派分区（majority），少数派分区（minority）&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可用性：Redis Cluster 在&lt;strong&gt;大部分 master 节点可用，并且对少部分不可用的 master，每一个 master 至少有一个当前可用的 slave&lt;/strong&gt; 场景下能够保证集群的可用性。&lt;/p&gt;

    &lt;p&gt;另外，通过使用 &lt;strong&gt;replicas migration&lt;/strong&gt; 技术，当前没有 slave 的 master 会从当前拥有多个 slave 的 master 接受到一个新 slave 来确保可用性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-2-implemented-subset&quot;&gt;1-2 Implemented subset&lt;/h2&gt;

&lt;p&gt;Redis Cluster 实现了所有在非分布式 Redis 版本中的单 key 命令；但是对于使用多个 key 的复杂操作没有实现，比如 set 中的 unions &amp;amp; intersections 操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不支持多个 key 的复杂操作是为了避免 key-value 在不同的 Cluster 节点间移动，使得情况更加复杂&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;不过，Redis Cluster 实现了被称为 &lt;strong&gt;Hash Tags&lt;/strong&gt; 的概念：多个 key 可以通过相同的 hash tag 存储在相同的 hash slot 中，从而避免了 key 的迁移。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在手动 resharding 期间，多 key 操作可能变的不可用&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;除了支持的命令不同，Redis Cluster 只支持 database 0，并不像单机版 Redis 支持多个数据库。&lt;/p&gt;

&lt;h3 id=&quot;1-2-1-why-merge-operations-are-avoided&quot;&gt;1-2-1 Why merge operations are avoided&lt;/h3&gt;

&lt;p&gt;Redis Cluster 设计是避免在多个节点中存在相同 key-value 对的冲突版本，因为 Redis 中的值通常都是比较大的，数据类型也是语义复杂的，传输和合并这样的值将会影响性能。&lt;/p&gt;

&lt;h2 id=&quot;1-3-clients-and-servers-roles-in-the-redis-cluster-protocol&quot;&gt;1-3 Clients and Servers roles in the Redis Cluster protocol&lt;/h2&gt;

&lt;p&gt;Cluster 节点主要任务有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据维护&lt;/li&gt;
  &lt;li&gt;集群状态获取&lt;/li&gt;
  &lt;li&gt;将 key 映射到正确的 Cluster 节点&lt;/li&gt;
  &lt;li&gt;自动发现其他 Cluster 节点&lt;/li&gt;
  &lt;li&gt;检测异常 Cluster 节点&lt;/li&gt;
  &lt;li&gt;当某个 master 节点故障时，提升其副本为 master 节点，以保证 Cluster 正常运行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了实现上述功能，所有 Redis Cluster 节点间通过 &lt;strong&gt;Redis Cluster Bus&lt;/strong&gt; 互相连接：由 TCP bus 及二进制协议组成。节点间通过 &lt;strong&gt;Gossip 协议传递集群信息&lt;/strong&gt;，以此来实现新节点发现，节点探活及标定特定状态等功能。&lt;/p&gt;

&lt;p&gt;由于 Cluster 节点不能代理请求，因此 Client 在收到重定向异常（MOVED, ASK）时，需要将请求重定向到其他节点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Client 通过缓存 key → cluster node 的映射关系，减少重定向，提高执行效率&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-4-write-safety&quot;&gt;1-4 Write safety&lt;/h2&gt;

&lt;p&gt;Redis Cluster 通过&lt;strong&gt;节点间异步复制数据&lt;/strong&gt;，及 &lt;strong&gt;last failover wins&lt;/strong&gt; 避免合并功能 。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;last failover wins 指当 master 节点故障时，通过 failover 机制选取的新 master 节点将直接覆盖之前 master 节点的数据，并同步给其他 slaves（新 master 节点中的数据可能不是最新的，或者有所缺失）。通过 last failover wins 机制，最后选举出的新 master 副本数据会覆盖其他所有副本数据。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在网络分区期间，会存在一个写操作丢失的时间窗口。&lt;em&gt;对于发生在 master 节点多数派（majority）分区的写操作丢失窗口与少数派（minority）的丢失窗口是不同的&lt;/em&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于发生在多数派 master 的写操作，Redis Cluster 会尽量保存；但是以下两种场景除外：
 a. client 写操作请求到达 master 节点，当 master 执行完成并回复 client 成功之后，master 出现异常而不可访问；但是之前的写操作并未通过异步复制到其他 slaves 中。如果 master 不可访问的时间较长而导致其中的一个 slave 被选举成新的 master，那么之前的写操作将会丢失。
 b. 由于网络分区，某个 master 不可被访问。网络分区触发了一轮选举，导致其中的一个 slave 被选举成新的 master。网络分区恢复之后，old master 变成 new master 的 slave 之前，一个 client 通过过期的路由表对 old master 节点进行写入，此时的写入将会被全部丢失。&lt;/p&gt;

    &lt;p&gt;不过，对于第二种场景，在一些安全机制的条件下很难发生：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;少数派 master 与多数派 master 无法通信达到一定的时间后，将拒绝 client 的写操作请求&lt;/li&gt;
      &lt;li&gt;当网络分区恢复后，该 master 仍需要继续拒绝写入一段时间用来感知 Cluster 的配置变化，因此留给 client 的时间窗口很小&lt;/li&gt;
      &lt;li&gt;在分区恢复之后，其他节点会尽快尝试访问新加入的节点（携带最新的 Cluster 配置信息）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于发生在少数派 master 的写操作拥有更大的丢失窗口&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;如果少数派 master 节点通过 failover 转移到多数派 master 节点的分区，那么所有发送到少数派分区的写操作都将会被永久丢失&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;发生 failover 的前提是，其中的 master 节点至少在 NODE_TIMEOUT 时间内无法被多数派 master 节点访问&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分区故障时间小于 NODE_TIMEOUT，则不会出现写操作数据丢失&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分区故障时间大于 NODE_TIMEOUT，则对少数派 master 的写入操作将全部丢失&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;不过少数派 master 会在进入不可用状态之后拒绝写入请求&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-5-availability&quot;&gt;1-5 Availability&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Redis Cluster 能容忍集群中少数节点不可访问，但不适合要求大量网络分块的应用&lt;/strong&gt;（如多机房部署）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;集群在少数派分区侧不可用&lt;/li&gt;
  &lt;li&gt;对于多数派 master 分区，如果其他每个不可访问的 master 节点都至少有一个 slave 节点可达，那么在经过 NODE_TIMEOUT 重新选举之后，多数派分区仍然可用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;为了提高集群可用性，Redis Cluster 支持 Replicas Migration：&lt;/strong&gt;自动将转移副本节点到孤立的 master 节点（不再拥有 slave 的 master）；每次 failover 成功之后，都会重新配置 slave 副本分布以提高下一次故障期间的可用性。&lt;/p&gt;

&lt;h1 id=&quot;2-overview-of-redis-cluster-main-components&quot;&gt;2-Overview of Redis Cluster main components&lt;/h1&gt;

&lt;h2 id=&quot;2-1-keys-distribution-model&quot;&gt;2-1 Keys distribution model&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;key 的空间范围被划分为 16834 个 slot&lt;/strong&gt;，间接使得一个集群的最大上限为 16834 个 master 节点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般建议最大节点数少于 1000&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Cluster 中的每个 master 节点处理 16834 个 hash slot 的其中一部分子集。当 Cluster 处于稳定状态时，每个 hash slot 只会由一个节点提供服务。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;没有出现 slot 迁移的情况被认为是稳定状态&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;将 key 映射为对应的 hash slot 方法为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;HASH_SLOT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CRC16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16384&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-2-keys-hash-tags&quot;&gt;2-2 Keys hash tags&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Hash Tags 提供了一种将多个 key 分配到同一个 hash slot 的方式&lt;/strong&gt;。通过 Hash Tags 可以在 Redis Cluster 中实现对多个 key 的同时操作。&lt;/p&gt;

&lt;p&gt;Hash Tags 的规则如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;key 包含一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt; 字符&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;并且&lt;/em&gt; 如果在这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt;的右面有一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;}&lt;/code&gt;字符&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;并且&lt;/em&gt; 如果在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;}&lt;/code&gt;之间存在至少一个字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{ }&lt;/code&gt; 之间的字符将被用来计算 hash slot。如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{user1000}.following&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{user1000}.followers&lt;/code&gt;这两个 key 会被分配到相同的 hash slot 中，因为只有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user1000&lt;/code&gt;会被用来计算 hash slot 值。&lt;/p&gt;

&lt;h2 id=&quot;2-3-cluster-nodes-attributes&quot;&gt;2-3 Cluster nodes attributes&lt;/h2&gt;

&lt;p&gt;集群中的&lt;strong&gt;每个节点都有全局唯一 ID 标识&lt;/strong&gt;。启动时生成，并持久化在配置文件中，一般不会改变。&lt;/p&gt;

&lt;p&gt;每个节点还维护集群中其他节点的信息，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;node id&lt;/li&gt;
  &lt;li&gt;ip &amp;amp; port&lt;/li&gt;
  &lt;li&gt;标签&lt;/li&gt;
  &lt;li&gt;master node id（如果节点是 slave）&lt;/li&gt;
  &lt;li&gt;最后一次被挂起的 ping 的发送时间 &amp;amp; 最后一次收到 pong 的时间&lt;/li&gt;
  &lt;li&gt;该节点的当前 &lt;strong&gt;configuration epoch&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;该节点维护的 hash slots&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-4-the-cluster-bus&quot;&gt;2-4 The Cluster bus&lt;/h2&gt;

&lt;p&gt;每个集群节点使用额外的 TCP 端口用于与集群中的其他节点交互；集群节点间的交互只使用 Cluster bus 及 Cluster bus 协议：一种二进制协议。&lt;/p&gt;

&lt;h2 id=&quot;2-5-cluster-topology&quot;&gt;2-5 Cluster topology&lt;/h2&gt;

&lt;p&gt;Redis Cluster 是全网拓扑，&lt;strong&gt;每个节点都与其他节点维护 TCP 连接&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;N 个节点的集群中，每个节点有 N-1 个传出 TCP 连接，同时有 N-1 个传入 TCP 连接&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;集群节点间使用 &lt;strong&gt;Gossip 协议&lt;/strong&gt;和&lt;strong&gt;配置更新机制&lt;/strong&gt;来避免正常情况下节点间交互过多的消息。&lt;/p&gt;

&lt;h2 id=&quot;2-6-nodes-handshake&quot;&gt;2-6 Nodes handshake&lt;/h2&gt;

&lt;p&gt;对于 Cluster bus port 连接，节点总是接受并回复 ping 请求，即使该 ping 请求来自一个不可信任的节点。但是如果发送节点被认为不是集群的一部分，那么该节点的其他数据包都会被丢弃。&lt;/p&gt;

&lt;p&gt;通过两种方式可以判断一个节点是不是集群节点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;节点出现在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEET&lt;/code&gt; 消息中&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEET&lt;/code&gt; 消息会强制接收者接受一个节点作为集群的一部分&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;CLUSTER&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;节点出现在一个被信任的节点的 Gossip 消息中&lt;/strong&gt;：A 节点是被信任的集群节点，B 出现在 A 的Gossip 消息中，那么 C 收到 A 的消息后也会把 B 标记为集群节点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一旦我们将某个节点加入了连接图中，那么最终所有节点会自动形成一张全连接图（fully connected graph），即&lt;strong&gt;集群可以自动发现其他节点&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该机制使得集群更加健壮，可以防止不同的 Cluster 在 IP 地址变更或者其他网络相关事件导致意外混合&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h1 id=&quot;3-redirection-and-resharding&quot;&gt;3-Redirection and resharding&lt;/h1&gt;

&lt;p&gt;Redis Client 可以向集群中的任意节点发送查询请求，包括 slave 节点。&lt;/p&gt;

&lt;p&gt;收到请求的集群节点会分析该查询请求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果请求是可以接受的，则会判断 key 所属的 hash slot 及对应的节点&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;可以接受的请求是指：a. 请求中只包含一个 key；b. 多个 key 同属一个 hash slot&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;如果目标 hash slot 被当前节点管理，则直接处理请求&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;否则，当前节点回复一个 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 异常：&lt;/strong&gt;&lt;em&gt;异常包含了 key 所属的 hash slot 及管理该 hash slot 的节点（IP + Port）&lt;/em&gt;。&lt;/p&gt;

    &lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-MOVED&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3999&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;127.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6381&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Client 收到重定向的回复之后，需要向指定的 IP + Port 重新补发查询请求。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果在补发请求之前，集群配置再次发生了变化，导致刚才的节点不再管理对应的 hash slot，那么也会返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 异常，Client 仍需要再次补发请求&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 异常，Client 除了重新补发，还&lt;strong&gt;需要缓存 hash slot 与集群节点的映射关系&lt;/strong&gt;，以提高之后请求的效率。不过，该策略不是强制的，Client 还可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLUSTER NODES&lt;/code&gt; 命令&lt;strong&gt;全量刷新 hash slot 与集群节点的映射关系并缓存&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当 Cluster 处于稳定状态时，所有的 Client 最终都可以维护 hash slot → cluster nodes 的映射关系，减少重定向的概率，提升集群处理的效率。&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 重定向，Client 需要能够处理 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt; 重定向。&lt;/p&gt;

&lt;h2 id=&quot;3-2-cluster-live-reconfiguration&quot;&gt;3-2 Cluster live reconfiguration&lt;/h2&gt;

&lt;p&gt;为了支持 Cluster 动态重新配置，需要实现 &lt;strong&gt;hash slot 在集群节点间迁移能力&lt;/strong&gt;。slot 迁移的场景有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;添加节点：需要将一些已经存在 hash slot 集合迁移到新节点上&lt;/li&gt;
  &lt;li&gt;删除节点：将被删除节点上的所有 hash slot 集合转移到其他节点&lt;/li&gt;
  &lt;li&gt;集群 rebalance：将给定的 hash slot 集合在节点间移动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;hash slot 迁移的核心是分布在该 slot 上的 key 集合迁移&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下面是一些 slot 迁移的命令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER ADDSLOTS slot1 [slot2] … [slotN]&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER DELSLOTS slot1 [slot2] … [slotN]&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER SETSLOT slot NODE node&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER SETSLOT slot MIGRATING node&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER SETSLOT slot IMPORTING node&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADDSLOTS&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELSLOTS&lt;/code&gt;只是用来简单地在 Redis Cluster 节点上分配或移除 slot。&lt;strong&gt;在分配了 hash slots 之后，节点会通过 Gossip 协议在集群中传播这些信息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SETSLOT slot NODE node&lt;/code&gt; 用来给特定的节点分配 slot。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLUSTER SETSLOT slot MIGRATING node&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLUSTER SETSLOT slot IMPORTING node&lt;/code&gt; 命令用于将 hash slot 从一个节点迁移到另一个节点。迁移过程总涉及到两个特殊的状态：&lt;strong&gt;MIGRATING&lt;/strong&gt; &amp;amp; &lt;strong&gt;IMPORTING&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当 hash slot 处于 &lt;strong&gt;MIGRATING&lt;/strong&gt; 状态时，如果某个查询请求的 key 在该 slot 中，则当前节点会处理该查询请求；否则，节点就会通过 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 命令重定向到迁移的目标节点&lt;/li&gt;
  &lt;li&gt;当 hash slot 处于 &lt;strong&gt;IMPORTING&lt;/strong&gt; 状态时，如果某个查询请求后紧跟着 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASKING&lt;/code&gt;&lt;/strong&gt; 命令，则该请求就会被执行；否则，该请求就会通过 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt;&lt;/strong&gt; 命令重定向到管理该 hash slot 的真正节点&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-2-1-migration-process&quot;&gt;3-2-1 Migration process&lt;/h3&gt;

&lt;p&gt;假设 Redis Cluster 中存在 A，B 两个节点，我们期望将 hash slot 8 从 A 迁移到 B，则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向 B 发送命令 &lt;em&gt;CLUSTER SETSLOT 8 IMPORTING A&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;向 A 发送命令 &lt;em&gt;CLUSTER SETSLOT 8 MIGRATING B&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有其他节点在收到一个对属于 hash slot 8 的 key 的查询时，仍然会继续将 Client 重定向到 A，会导致：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有对已经存在的 key 查询将会被 A 处理&lt;/li&gt;
  &lt;li&gt;所有在 A 上不存在的 key 都会被 B 处理，因为 A 会将其重定向到 B（&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt;）&lt;/li&gt;
  &lt;li&gt;将&lt;strong&gt;不会在 A 上创建新的 key&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 key 的迁移过程中，从 Client 的视角来看，同一个 key 只会存在 A or B 中。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-3-ask-redirection&quot;&gt;3-3 ASK redirection&lt;/h2&gt;

&lt;p&gt;在 slot 迁移过程中，使用的是 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 命令进行重定向，为什么不使用 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt;&lt;/strong&gt; 命令进行重定向？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;**MOVED**&lt;/code&gt; 表明&lt;strong&gt;目标 hash slot 永久地被一个不同的节点所管理&lt;/strong&gt;，并且以后的请求也应该继续指向该节点；而 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 表明&lt;strong&gt;只是下次查询需要发送给另一个特定节点&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们期望 Client 总是&lt;strong&gt;先尝试访问 A，然后在有必要的时候再访问 B&lt;/strong&gt;。因为同一个 hash slot 中有很多 key，可能某次查询的 key 已经不在 A 上了，需要再次重定向到 B 查询；但是可能下次查询的 key 仍然在 A 上。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 重定向只发生在 hash slot 迁移过程中，对 Cluster 的影响可以接受&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASKING&lt;/code&gt; 命令会为 client 设置一个&lt;strong&gt;单次标签(one-time flag)&lt;/strong&gt;，以允许该 client 可以访问处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;**IMPORTING**&lt;/code&gt; 状态的 slot 一次。&lt;/p&gt;

&lt;p&gt;从 client 的视角来看，当收到 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 重定向命令之后：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;仅仅将这条查询重定向到指定的新节点，&lt;strong&gt;之后的命令还是继续发送给老的节点&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;重定向查询必须以一条&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASKING&lt;/code&gt;命令开始&lt;/li&gt;
  &lt;li&gt;暂时不要在本地将 hash slot 8 映射为节点 B&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当 hash slot 8 迁移完成之后，A 会返回一个 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt;&lt;/strong&gt; 重定向命令，client 需要在本地更新 hash slot 8 的映射节点为 B。&lt;/p&gt;

&lt;h2 id=&quot;3-4-clients-first-connection-and-handling-of-redirections&quot;&gt;3-4 Clients first connection and handling of redirections&lt;/h2&gt;

&lt;p&gt;Redis Cluster 的 Client 如果不将 hash slots → cluster nodes 的映射关系缓存在本地，那么每次查询都需要根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 重定向找到正确的节点，效率会很低。为了提高查询效率，Client 需要将 slots → nodes 的映射缓存在本地，但是该缓存并不总是最新的。&lt;/p&gt;

&lt;p&gt;在以下两个场景中 Client 需要获取全量的 hash slots → cluster nodes 的映射关系：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;启动阶段初始化 slots 配置信息&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;收到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 的重定向信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Client 在收到 MOVED 重定向时，通常会有多个 slots 发生了变动（比如 slave 晋升，该节点的 slots 会重新映射），此时 Client 全量更新 slots 会使问题处理起来比较简单&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-5-multiple-keys-operations&quot;&gt;3-5 Multiple keys operations&lt;/h2&gt;

&lt;p&gt;通过使用 hash tags 可以对多个 key 进行操作。&lt;/p&gt;

&lt;p&gt;不过，在 resharding 期间，多个 key 操作可能会不可用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果这些 key 在同一个节点上，则可以继续可用&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果这些 key 在不同的节点上，则不可用&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;请求的多 key 所属的 slot 在迁移过程中，这些 &lt;strong&gt;key 可能同时分布在源节点与目标节点&lt;/strong&gt;上&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-6-scaling-reads-using-replica-nodes&quot;&gt;3-6 Scaling reads using replica nodes&lt;/h2&gt;

&lt;p&gt;slave 节点默认不可读，&lt;strong&gt;所有对 slave 节点的读请求都会被重定向到 master 节点&lt;/strong&gt;（返回 MOVED 异常）。不过可以通过 READONLY 命令将 slave 节点设置为可读。&lt;/p&gt;

&lt;h1 id=&quot;4-fault-tolerance&quot;&gt;4-Fault Tolerance&lt;/h1&gt;

&lt;h2 id=&quot;4-1-heartbeat-and-gossip-messages&quot;&gt;4-1 Heartbeat and gossip messages&lt;/h2&gt;

&lt;p&gt;Redis Cluster 存在两种&lt;strong&gt;心跳包（heartbeat packets）&lt;/strong&gt;，分别称为 &lt;strong&gt;ping&lt;/strong&gt; 包 &amp;amp; &lt;strong&gt;pong&lt;/strong&gt; 包。这两种心跳包结构相同，并且都会携带重要的配置信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当节点收到 ping 包时，总会回复一个 pong 包&lt;/li&gt;
  &lt;li&gt;有时节点为了尽快将自身的配置信息发送出去，会直接向其他节点发送 pong 包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个节点会随机挑选一些节点并发送一些 ping 包（&lt;strong&gt;Gossip 协议&lt;/strong&gt;），每个节点在指定时间范围内发送的 ping 包与接收到的 pong 包是一个常数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;会主动对 &lt;em&gt;NODE_TIMEOUT/2 时间内没有发送过 ping 或者从其接收到 pong&lt;/em&gt; 的节点发送 ping 包&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;4-2-heartbeat-packet-content&quot;&gt;4-2 Heartbeat packet content&lt;/h2&gt;

&lt;p&gt;ping &amp;amp; pong 包的内容包含两部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;包头（header）&lt;/strong&gt;：该部分不仅可以用于 ping &amp;amp; pong 消息，也可以用于其他类型消息（如重新选举消息）&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;内容&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Node ID&lt;/td&gt;
          &lt;td&gt;节点创建时生成，并在 Redis Cluster 生命周期内保持不变&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;currentEpoch &amp;amp; configEpoch&lt;/td&gt;
          &lt;td&gt;由 Redis Cluster 用来加载分布式算法；如果发送者是 slave 节点，则 configEpoch 就是其 master 的 configEpoch&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;node flags&lt;/td&gt;
          &lt;td&gt;表明发送者是 slave 还是 master；同时包含一些其他信息&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;hash slots 的 bitmap&lt;/td&gt;
          &lt;td&gt;如果发送者是 slave，则表示其 master 的 hash slots 的 bitmap&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TCP Port&lt;/td&gt;
          &lt;td&gt;用于接受命令的普通端口（+10000 表示 Redis Cluster Bus 端口）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Cluster state&lt;/td&gt;
          &lt;td&gt;发送者视角下的集群状态（down or ok）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;master Node ID&lt;/td&gt;
          &lt;td&gt;master 节点的 Node ID（如果发送者是 slave）&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Gossip section&lt;/strong&gt;：仅存在 ping &amp;amp; pong 中；包含&lt;strong&gt;&lt;em&gt;发送者视角下集群中其他节点状态，用于故障检测 &amp;amp; 节点发现&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;内容&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Redis Cluster 中其他节点信息&lt;/td&gt;
          &lt;td&gt;包含 Node ID, IP, Port, Node flags(FAIL, PFAIL)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Gossip section 段中包含的节点数与集群大小成正比&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-3-failure-detection&quot;&gt;4-3 Failure detection&lt;/h2&gt;

&lt;p&gt;Redis Cluster 故障检测机制用来&lt;strong&gt;识别一个 master or slave 节点对集群中大部分 master 节点是否是可达的（reachable）&lt;/strong&gt;。如果一个 master 节点不可达，则会将其一个 slave 节点晋升为 master；&lt;strong&gt;&lt;em&gt;如果无法将 slave 晋升为 master，则集群会被置为 error 状态，并停止接受客户端的请求&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;选举过程需要 master 节点参与&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如何定义不可达？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个已经发送出去，但是没有接收到对方回复的 ping 被称为活跃 ping（active ping）。如果一个活跃 ping 挂起时间超过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT&lt;/code&gt;，则认为接收方不可达。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT&lt;/code&gt; 必须大于正常的网络往返时间。为了增加可靠性，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT/2&lt;/code&gt; 时间过后如果还没收到回复，会尝试联系其他节点，确保自身连接的活跃性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-3-1-pfail--fail&quot;&gt;4-3-1 PFAIL &amp;amp; FAIL&lt;/h3&gt;

&lt;p&gt;Redis Cluster 每个节点都会保存其他节点的一些 flags 信息，其中有两个 flag 用于&lt;strong&gt;故障检测：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL &amp;amp; PFAIL&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; flag (possible fail)&lt;/p&gt;

    &lt;p&gt;可能故障，是一个不需要确认的故障类型。&lt;/p&gt;

    &lt;p&gt;当节点发现某个节点失联超过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT&lt;/code&gt; 时，会在本地将其标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;检测节点与被检测节点都可以是 master 或者 slave&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag（fail）&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; 只是每个节点针对其他节点状态的本地信息，不能以此来判断是否进行选举。为了确认节点确实不可达了，需要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; 升级为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-2-pfail--fail&quot;&gt;4-3-2 PFAIL → FAIL&lt;/h3&gt;

&lt;p&gt;每个 Gossip 消息中都会包含当前节点已知的一部分其他节点的状态（是否 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt;），节点之间会交换自己已知信息；将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; 升级为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;的流程为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点 A 检测到 B 节点不可达，将其标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;节点 A 通过 Gossip 消息收集大部分 master 节点对 B 节点状态标记的 flag&lt;/li&gt;
  &lt;li&gt;多数 master 节点在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间范围内将 B 标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A 将 B 标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A &lt;strong&gt;发送一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 消息给所有可达节点&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FAIL 消息会强制所有接收到消息的节点将不可达节点 B 标记为 FAIL&lt;/strong&gt;，而不管自己当前是否已经将 B 标记为 PFAIL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag 是单向（one way）的：只能 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; → &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;。不过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag 可以在以下情况中被清除：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;节点重新可达，并且该节点是 slave&lt;/strong&gt;：因为 slave 节点不会发生故障转移（failover）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;节点重新可达，并且没有管理任何 hash slots 的 master 节点&lt;/strong&gt;：这种节点实际上没有参与集群管理，需要等待被配置后加入集群&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;节点重新可达，且为 master 节点，同时在较长时间内（N * NODE_TIMEOUT）没有检测到有 slave 节点晋升&lt;/strong&gt;：此时最好将其作为 master 节点重新加入集群&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL → FAIL&lt;/code&gt; 的转换过程使用了&lt;strong&gt;弱一致性&lt;/strong&gt;（weak agreement）:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;节点在一段时间内收集其他 master 节点的视图，即使多数 master 达成一致，也只能说明在不同的时间，不同的节点达成一致，无法确定在什么时刻获得了多数 master 的一致结果。不过，过期的结果会被抛弃掉（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; ），所以&lt;strong&gt;可以确定多数 master 节点一定是在某个时间窗口内达成一致&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 消息虽然可以强制其他节点接受该判断结果，但是无法保证消息被所有节点接收到：如出现了网络分区&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-3-conner-case&quot;&gt;4-3-3 Conner case&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Redis Cluster 所有节点最终会对一个给定的节点状态达成一致&lt;/strong&gt;。两个由于集群脑裂引起的场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果多数派 master 将一个节点标记为 FAIL，那么所有其他节点最终也会将该 master 标记为 FAIL：在指定的时间窗口内，集群中会有足够多的失败报告&lt;/li&gt;
  &lt;li&gt;如果少数派 master 节点将一个节点标记为 FAIL，并不会发生 failover，最终该 FAIL 状态会被清除：在 N*NODE_TIMEOUT 内没有晋升&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-4-moreover&quot;&gt;4-3-4 Moreover&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag 只是一种触发机制，用于触发执行 slave 晋升操作。slave 也可以在发现 master 不可达之后主动启动晋升操作，并尝试获得多数 master 节点的同意。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 机制虽然有些复杂，但是可以使得集群意识到自己处于一个 error 状态，从而拒绝写操作；而且可以减少由于 slave 自身问题触发错误的选举尝试。&lt;/p&gt;

&lt;h1 id=&quot;5-configuration-handling-propagation-and-failovers&quot;&gt;5-Configuration handling, propagation, and failovers&lt;/h1&gt;

&lt;h2 id=&quot;5-1-cluster-current-epoch&quot;&gt;5-1 Cluster current epoch&lt;/h2&gt;

&lt;p&gt;Redis Cluster 使用类似 Raft 算法中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;term&lt;/code&gt; 的概念，被称为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;相当于集群的逻辑时钟，为事件提供递增的版本号&lt;/strong&gt;。当多个节点的信息冲突时，可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 判断哪个信息是最新的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 是一个 64 位无符号整数，用于标识集群 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;；所有节点中最大的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 即为集群  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;节点创建时，所有 Redis Cluster 节点（master or slave）都将自己的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 设置为 0。当从其他节点收到消息时，如果发送方的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 大于当前节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;，则&lt;strong&gt;将自身的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 更新为发送方的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;&lt;/strong&gt;。这样，最终所有节点都会与拥有最大 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 的节点保持一致。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 被设计用于，&lt;em&gt;当集群状态变化时，某个节点请求其他节点的同意来执行一些操作&lt;/em&gt;（如 slave → master）；拥有较大 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 的节点总能获得相对较小节点的同意。&lt;/p&gt;

&lt;h2 id=&quot;5-2-configuration-epoch&quot;&gt;5-2 Configuration epoch&lt;/h2&gt;

&lt;p&gt;当 master 节点被创建时，其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 被置为 0。新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 将会在 slave 晋升为 master 之后被创建。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 由 master 节点创建，在 failover 时产生一个新的，递增唯一值&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在 Redis Cluster 处于稳定状态时，slave 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 为其与 master 节点交互时从 master 节点获取的（与 master 保持一致，不过可能会有所延迟）。&lt;/p&gt;

&lt;p&gt;master 与 slave 节点交互时都会携带自己的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt;，并且会广播给集群中其他节点。当某些节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 发生变化时，收到该消息的节点会将最新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 持久化到各自的本地配置文件中。&lt;/p&gt;

&lt;h2 id=&quot;5-3-replica-election-and-promotion&quot;&gt;5-3 Replica election and promotion&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;选举 &amp;amp; 晋升总是由 slave 节点发起与处理&lt;/strong&gt;，master 节点在选举过程中参与投票。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;选举的条件？
    &lt;ol&gt;
      &lt;li&gt;master 处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 状态&lt;/li&gt;
      &lt;li&gt;master 至少管理一个 hash slot&lt;/li&gt;
      &lt;li&gt;slave 与 master 的复制链接断开时间少于给定值：用于确保晋升的 slave 数据尽可能新&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;什么时候触发选举？
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;当 master 在至少一个 slave 视图中处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 状态时，且 slave 要求晋升为 master，就会触发选举流程&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;多个 slave 都可以发起选举流程，但是只有一个 slave 能赢得选举&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;选举流程？
    &lt;ol&gt;
      &lt;li&gt;slave 增加自己的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;slave 向集群所有 master 节点广播 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_REQUEST&lt;/code&gt; 包请求选票，并且在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间内等待所有 master 节点的回复&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;master 收到投票请求后，如果准备将选票投给对应的 slave，则回复 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_ACK&lt;/code&gt;，并且在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间内不能给其他 slave 进行投票&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;避免多个 slave 赢得选票&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;slave 抛弃那些 epoch 比自己发送选票请求时的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 小的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_ACK&lt;/code&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;避免计算上一次选举的选票&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;如果 slave 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间内赢得了大部分 master 节点的选票，则其赢得选举；否则将会在  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 4&lt;/code&gt; 时间后再次尝试&lt;/li&gt;
      &lt;li&gt;slave 赢得选举后会新增 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt;，该 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 会比其他 master 节点更大。随后会在 ping &amp;amp; pong 中广播该 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch.&lt;/code&gt;为了加速配置更新，新 master 会向其他节点直接发送 pong 包&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-4-masters-reply-to-replica-vote-request&quot;&gt;5-4 Masters reply to replica vote request&lt;/h2&gt;

&lt;p&gt;在选举过程中，master 需要为接收到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_REQUEST&lt;/code&gt; 请求进行投票，投票的条件为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;master 只会对每个 epoch 投票一次，并且拒绝比上次投票更小的 epoch 请求&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lastVoteEpoch&lt;/code&gt; 保存在 master 节点本地&lt;/li&gt;
  &lt;li&gt;请求的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 如果小于当前 master  的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt;，则会被忽略&lt;/li&gt;
  &lt;li&gt;请求的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 如果小于其所属 master 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt;，则也会被忽略。由于 slave 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 从其 master 获取，这种情况说明 slave 并不是比较新的&lt;/li&gt;
  &lt;li&gt;salve 所属的 master 被当前 master 标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-5-hash-slots-configuration-propagation&quot;&gt;5-5 Hash slots configuration propagation&lt;/h2&gt;

&lt;p&gt;Redis Cluster 提供一种机制，用于在集群中传播每个节点管理的 hash slot 配置信息。&lt;/p&gt;

&lt;p&gt;有两种传播 hash slot 配置信息的方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;心跳包：ping &amp;amp; pong 消息的发送方总会携带自己或者其 master 管理的 hash slot 信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息：心跳包的接收方如果发现发送方的消息过期，则会回复 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息，&lt;strong&gt;强制对方更新其过期信息&lt;/strong&gt;。（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息中包含了最新的配置信息）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当新的 Redis Cluster 节点创建时，其本地 hash slots 映射表初始化为 NULL，基本如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;16383&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;hash slots 配置的传播规则如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果在 A 节点的本地一个 hash slot 没有被分配（NULL），此时有 B 节点声明了该 slot，则修改 A 本地的 hash slot 映射关系将该 slot 绑定为 B&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 A 节点中一个 hash slot 已经被 C 分配，此时 B 的广播消息中的 configEpoch 比 C 节点的 configEpoch 大，则将该 hash slot 绑定为 B&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;最终所有节点一定会通过节点间的消息广播就 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 最大的节点获得 slot 的管理权达成一致；这一机制被称为 &lt;strong&gt;last failover wins(最后故障转移者胜)&lt;/strong&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于以上规则，当一个过期的节点收到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息时，会根据最新消息更新自己的配置。&lt;/p&gt;

&lt;p&gt;当一个 master 节点在分区后重新加入集群时，会将自己从属于新的 master 节点，并更新自身配置。&lt;/p&gt;

&lt;h2 id=&quot;5-6-replica-migration&quot;&gt;5-6 Replica migration&lt;/h2&gt;

&lt;p&gt;备份迁移是一种 slave 自动重配的过程，用来将备份节点迁移到当前已经没有可用 slave 的 master上，提高集群可用性。&lt;/p&gt;

&lt;p&gt;假设 A 只有一个 slave A，可能的迁移场景为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A发生故障，A1 被晋升。&lt;/li&gt;
  &lt;li&gt;C2 迁移为 A1 的 slave，否则 A1 将会没有任何 slave&lt;/li&gt;
  &lt;li&gt;一段时间后 A1 也发生了故障&lt;/li&gt;
  &lt;li&gt;C2 被晋升为新的 master 以替代 A1&lt;/li&gt;
  &lt;li&gt;此时，集群还能正常提供服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-appendix&quot;&gt;6-Appendix&lt;/h1&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://redis.io/topics/cluster-spec&quot;&gt;https://redis.io/topics/cluster-spec&lt;/a&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">1-Main properties and rationales of the design</summary></entry><entry><title type="html">Redis Cluster Tutorial</title><link href="http://localhost:4000/redis-cluster-tutorial.html" rel="alternate" type="text/html" title="Redis Cluster Tutorial" /><published>2022-02-13T00:00:00+08:00</published><updated>2022-02-13T00:00:00+08:00</updated><id>http://localhost:4000/redis-cluster-tutorial</id><content type="html" xml:base="http://localhost:4000/redis-cluster-tutorial.html">&lt;h2 id=&quot;1-introduction&quot;&gt;1-Introduction&lt;/h2&gt;

&lt;p&gt;Redis Cluster 支持&lt;strong&gt;数据自动在多个 Redis 节点间分片&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通过 Redis Cluster，能够实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;自动切分数据集到多个节点&lt;/strong&gt;（Sharding）&lt;/li&gt;
  &lt;li&gt;当部分节点故障或不可达的情况下，Redis Cluster 能够继续提供服务（High Availability）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Redis Cluster 提供&lt;strong&gt;&lt;em&gt;一定程度的高可用&lt;/em&gt;&lt;/strong&gt;，当某些节点失败或者不能访问的情况下能够继续提供服务。但是当大量节点失败的情况下集群也会停止服务（例如大多数主节点不可用）。&lt;/p&gt;

&lt;h2 id=&quot;2-tcp-ports&quot;&gt;2-TCP Ports&lt;/h2&gt;

&lt;p&gt;每个 Redis Cluster 节点需要打开两个 TCP 端口用于不同的连接。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;端口 &lt;strong&gt;6379&lt;/strong&gt;：用于提供&lt;strong&gt;客户端连接&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;该端口需要开放给所有与集群交互的客户端；同时，也要开放给集群中的其他节点用于 keys 迁移&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;端口 &lt;strong&gt;16379&lt;/strong&gt;：用于&lt;strong&gt;集群总线&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;该端口需要开放给集群中的其他节点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;客户端只能连接 6379，而不能连接 16739；而集群中的节点可以访问 6379 与 16739 两个端口&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;集群总线用于集群节点之间访问，使用&lt;em&gt;二进制协议&lt;/em&gt;，主要用于&lt;strong&gt;失败检测、配置升级、故障转移授权&lt;/strong&gt;等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;二进制协议更适合节点间使用小的带宽和处理时间来交换数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;3-data-sharding&quot;&gt;3-Data Sharding&lt;/h2&gt;

&lt;p&gt;Redis Cluster 的&lt;strong&gt;数据分片&lt;/strong&gt;不是使用一致性 Hash，而是使用一种 &lt;strong&gt;Hash Slot（哈希槽&lt;/strong&gt;）的形式。&lt;/p&gt;

&lt;p&gt;Redis Cluster 中共有 16384 个 Slot，如何决定每个 key 分配到哪个槽呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Slot_Index = &lt;strong&gt;CRC16(key) % 16384&lt;/strong&gt; 计算 Slot 索引&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cluster 中的每个节点负责一部分 Hash Slot，比如集群中有３个节点，则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A 存储的范围：0 ~ 5500&lt;/li&gt;
  &lt;li&gt;Ｂ存储的范围：5501 ~ 11000&lt;/li&gt;
  &lt;li&gt;Ｃ存储的范围：11001 ~ 16384&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种分配方式便于集群节点的新增与剔除。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新增一个节点Ｄ：需要把Ａ、Ｂ、Ｃ中的部分 Hash Slot 数据移到 Ｄ 节点&lt;/li&gt;
  &lt;li&gt;删除 Ａ 节点：需要把 Ａ 节点的 Hash Slot 的数据移到 Ｂ 和 Ｃ 节点；当 Ａ 节点的数据全部被移走后，Ａ 节点就可以完全从集群中删除&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Slot 在不同节点之间的迁移不需要暂停服务&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过 Hash Tag 的概念，Redis Cluster 可以通过一个命令（或事务, 或 lua 脚本）同时操作多个 key。&lt;/p&gt;

&lt;p&gt;Hash Tag 可以使得&lt;strong&gt;相同 Tag 的不同 key 被分配到同一个 Slot&lt;/strong&gt; 。如：key_1 = “this{foo}”, key_2 = “another{foo}”，这两个 key 的 tag 均为 foo，会被分配到同一个 Slot 中，所以可以在一个命令中操作它们。&lt;/p&gt;

&lt;h2 id=&quot;4-master-replica-model&quot;&gt;4-Master-Replica Model&lt;/h2&gt;

&lt;p&gt;为了提高 Cluster 的可用性，保证在部分节点故障或网络不通时 Cluster 依然能正常工作，Redis Cluster 使用了主从模型：&lt;strong&gt;&lt;em&gt;每个 Hash Slot 有 1（主节点）到 N 个副本（ N-1 个从节点&lt;/em&gt;&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;在上面的例子中，A, B, C 设为主节点，A1, B1, C1 分别为其从节点。如果 B 不可用，则会将 B1 提升为主节点，从而保证集群能够继续提供服务；但是如果 B1 同时也不可用了，则集群就不能继续工作了。&lt;/p&gt;

&lt;h2 id=&quot;5-consistency-guarantees&quot;&gt;5-Consistency Guarantees&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Redis Cluster 不能保证强一致性&lt;/strong&gt;：一些已经向 Client 确认写成功的操作，会在某些不确定的情况下丢失。&lt;/p&gt;

&lt;p&gt;无法保证强一致性的原因有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;主从节点之间使用了异步的方式来同步数据&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;网络分区期间可能导致的写操作数据丢失&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当 Client 向主节点 B 节点提交一个写操作后，主节点 B 将数据保存在本地并回复给 Client 操作成功 ，之后 B 异步地将刚才写操作的变更复制到从节点  B1, B2, B3。&lt;/p&gt;

&lt;p&gt;由于是异步复制，所以在 B 响应 Client 之后，并且同步给从节点之前，主节点 Ｂ 故障了，其中一个没有收到该写操作的从节点会晋升成主节点，该写操作就这样永远丢失了。&lt;/p&gt;

&lt;p&gt;为了提高一致性，可以考虑使用同步复制，不过会使得性能降低。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;在性能和一致性之间，需要一个权衡&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Redis Cluster 支持同步复制，通过 WAIT 命令实现，可以让数据丢失的概率降低。但是&lt;strong&gt;&lt;em&gt;即使使用了同步复制，Redis Cluster 仍不是强一致性的&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;考虑一种网络分区的情况：集群中存在主节点 A, B, C，从节点 A1, B1, C1，客户端 Z1，其中 Z1 与 B 可以网络互通，A, A1, B1, C, C1 之间网络互通，但是与 Z1, B 网络不通（一共两个网络分区）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Z1 可以继续向 B 发起写操作，Ｂ 也接受 Z1 的写操作&lt;/li&gt;
  &lt;li&gt;当网络恢复时，如果这个时间间隔足够短，集群仍然能继续正常工作&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果时间比较长，以至于 &lt;strong&gt;&lt;em&gt;B1 在大多数的这边被重新选为主节点&lt;/em&gt;&lt;/strong&gt;，那么刚才 Z1 发给 Ｂ 的写操作都将丢失&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Z1 给 Ｂ 发送写操作是有一个限制的，如果时间长度达到了大多数节点那边可以选出一个新的主节点时，少数这边的所有主节点都不接受写操作&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如何评断网络分区的时间是长还是短？&lt;/p&gt;

&lt;p&gt;Redis Cluster 中存在一个&lt;strong&gt;节点超时配置&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当达到了这个节点超时的时间之后，主节点被认为已经宕机，可以用它的一个从节点来代替&lt;/li&gt;
  &lt;li&gt;同样，在节点超时时，如果主节点依然不能联系到其他主节点，它将&lt;em&gt;进入错误状态，不再接受写操作&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-appendix&quot;&gt;6-Appendix&lt;/h2&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;https://redis.io/topics/cluster-tutorial#:~:text=Redis%20Cluster%20provides%20a%20way,are%20not%20able%20to%20communicate&quot;&gt;redis-io&lt;/a&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">1-Introduction</summary></entry><entry><title type="html">同位语从句</title><link href="http://localhost:4000/appositive-clause.html" rel="alternate" type="text/html" title="同位语从句" /><published>2022-02-13T00:00:00+08:00</published><updated>2022-02-13T00:00:00+08:00</updated><id>http://localhost:4000/appositive-clause</id><content type="html" xml:base="http://localhost:4000/appositive-clause.html">&lt;h2 id=&quot;1-同位语&quot;&gt;1-同位语&lt;/h2&gt;

&lt;p&gt;一个名词（或其它形式）&lt;strong&gt;&lt;em&gt;对另一个名词或代词进行解释或补充说明&lt;/em&gt;&lt;/strong&gt;，这个名词（或其它形式）就是同位语。&lt;/p&gt;

&lt;p&gt;同位语与被它限定的词的格式要一致，并常常紧挨在一起。同位语除表示其同位成分的全部意义外，还可以表示部分意义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mr. Smith, our new teacher, is very kind to us.&lt;/li&gt;
  &lt;li&gt;He told me that his brother John was a world-famous doctor.(John 是 brother 的同位语)&lt;/li&gt;
  &lt;li&gt;Yesterday I talked to my English teacher, Mr. James.&lt;/li&gt;
  &lt;li&gt;We Chinese people are brave and hard-working.(Chinese people 是 we 的同位语)&lt;/li&gt;
  &lt;li&gt;He is interested in sports, especially ball games.(ball games 是 sports 的同位语)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-同位语从句&quot;&gt;2-同位语从句&lt;/h2&gt;

&lt;p&gt;同位语从句指的是在复合句中充当同位语的从句，属于名词性从句的范畴。&lt;/p&gt;

&lt;p&gt;同位语从句用来&lt;em&gt;对其前面的抽象名词进行解释说明&lt;/em&gt;，被解释说明的词和同位语在逻辑上是&lt;strong&gt;主表关系&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2-1-先行词&quot;&gt;2-1 先行词&lt;/h3&gt;

&lt;p&gt;可以连接同位语从句的名词有：&lt;strong&gt;news，idea，fact，promise，question，doubt，thought，hope，message，suggestion，words(消息)，possibility, decision&lt;/strong&gt; 等(一般的”抽象”名词)。&lt;/p&gt;

&lt;h3 id=&quot;2-2-引导词&quot;&gt;2-2 引导词&lt;/h3&gt;

&lt;p&gt;引导同位语从句的词语通常有连词 that, whethe, 连接代词和连接副词等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;that 连接从句时，&lt;strong&gt;从句为一个句意完整的陈述句&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;that 不能省略，没有具体的含义，&lt;strong&gt;&lt;em&gt;不充当句子成分，只起连接作用&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The idea &lt;em&gt;that you can do this work well without thinking&lt;/em&gt; is quite wrong.(that 引导的从句作 idea 的同位语)&lt;/li&gt;
      &lt;li&gt;We heard the news &lt;em&gt;that our team had won&lt;/em&gt;.(news 的同位语)&lt;/li&gt;
      &lt;li&gt;They were worried over the fact &lt;em&gt;that you were sick&lt;/em&gt;.(fact 的同位语)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;在某些名词(如 &lt;strong&gt;demand, wish, suggestion, resolution&lt;/strong&gt;等) 后面的同位语从句要&lt;strong&gt;用虚拟语气&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;There was a suggestion &lt;em&gt;that Brown should be dropped from the team&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;引导同位语从句的连词 that 通常不省略，但在&lt;em&gt;非正式文体中也可以省去&lt;/em&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He grabbed his suitcase and gave the impression &lt;em&gt;he was boarding the Tokyo plane&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;whether 引导同位语从句&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;if 不能引导同位语从句&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;There is some doubt &lt;em&gt;whether he will come&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;Answer my question &lt;em&gt;whether you are coming&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;The question &lt;em&gt;whether it is right or wrong&lt;/em&gt; depends on the result.&lt;/li&gt;
      &lt;li&gt;We are not investigating the question &lt;em&gt;whether he is trustworthy&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接代词 what, who, whom, whose 引导同位语从句
    &lt;ul&gt;
      &lt;li&gt;I have no idea &lt;em&gt;what size shoes she wears&lt;/em&gt;.(what 作 size 的定语)&lt;/li&gt;
      &lt;li&gt;The question &lt;em&gt;who will take his place&lt;/em&gt; is still not clear.(who 作同位语从句的主语)&lt;/li&gt;
      &lt;li&gt;Have you any idea &lt;em&gt;what time it starts&lt;/em&gt;?&lt;/li&gt;
      &lt;li&gt;I have no idea &lt;em&gt;who can really understand my complicated mind&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接副词 where, when, why, how 引导同位语从句
    &lt;ul&gt;
      &lt;li&gt;I have no idea &lt;em&gt;when he will come back&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;It is a question &lt;em&gt;how he does it&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;He had no idea &lt;em&gt;why she left&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;You have no idea &lt;em&gt;how worried I was&lt;/em&gt;!&lt;/li&gt;
      &lt;li&gt;We haven’t yet settled the question &lt;em&gt;where we are going to spend our summer vacation&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-同位语</summary></entry><entry><title type="html">定语从句</title><link href="http://localhost:4000/attributive-clause.html" rel="alternate" type="text/html" title="定语从句" /><published>2022-02-11T00:00:00+08:00</published><updated>2022-02-11T00:00:00+08:00</updated><id>http://localhost:4000/attributive-clause</id><content type="html" xml:base="http://localhost:4000/attributive-clause.html">&lt;h2 id=&quot;1-基本概念&quot;&gt;1-基本概念&lt;/h2&gt;

&lt;h3 id=&quot;1-1-定义&quot;&gt;1-1 定义&lt;/h3&gt;

&lt;p&gt;一个简单句跟在&lt;em&gt;名词或代词（先行词）后进行修饰限定&lt;/em&gt;，就叫做定语从句；定语从句在主句中充当定语成分。&lt;/p&gt;

&lt;p&gt;被定语从句修饰的词叫&lt;strong&gt;先行词&lt;/strong&gt;；定语从句通常只能放在被修饰的先行词之后。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;单词做定语放在被修饰词之前&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;1-2-引导词&quot;&gt;1-2 引导词&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;引导定语从句的词有：
    &lt;ul&gt;
      &lt;li&gt;关系代词：&lt;strong&gt;that, who, whom, which, as&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;关系副词：&lt;strong&gt;when, where, why&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;引导词位于定语从句之前，先行词之后（as 除外）。&lt;/li&gt;
  &lt;li&gt;引导词的作用有：
    &lt;ul&gt;
      &lt;li&gt;连接先行词和定语从句&lt;/li&gt;
      &lt;li&gt;在定语从句中充当一定的成分（&lt;strong&gt;&lt;em&gt;关系代词充当主语或宾语，关系副词充当状语&lt;/em&gt;&lt;/strong&gt;）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-关系代词的用法&quot;&gt;2-关系代词的用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;who/that&lt;/strong&gt; 指人，是主格；&lt;strong&gt;在定语从句中代替先行词，又作定语从句的主语，不能省略&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Do you know the gentleman who/that is sitting there？&lt;/li&gt;
      &lt;li&gt;The student who/that answered the question was John.&lt;/li&gt;
      &lt;li&gt;Nothing is difficult to the man who/that will try.&lt;/li&gt;
      &lt;li&gt;The windows was broken by the boy who/that lives opposite.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;whom/who/that&lt;/strong&gt; 指人，是宾格；&lt;strong&gt;在定语从句中代替先行词，又作定语从句的宾语(动宾或介宾)&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;当作&lt;strong&gt;动宾&lt;/strong&gt;（动词后接宾语）时，关系代词可省略
        &lt;ul&gt;
          &lt;li&gt;Do you know the gentleman (whom/who/that) we met just now？&lt;/li&gt;
          &lt;li&gt;The author (whom/who/that) you criticized.&lt;/li&gt;
          &lt;li&gt;Then I telephoned the doctor (whom/who/that) Charles had recommended.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;当作&lt;strong&gt;介宾&lt;/strong&gt;（介词后接宾语）时：&lt;em&gt;介词不提前，关系代词可省略；介词提前，关系代词不可省&lt;/em&gt;，即 “介词+whom” (指人时介词后的关系代词只能用whom)
        &lt;ul&gt;
          &lt;li&gt;The man (whom/who/that) I spoke with is my teacher.&lt;/li&gt;
          &lt;li&gt;The man with whom I spoke is my teacher.&lt;/li&gt;
          &lt;li&gt;The man with whom I traveled couldn’t speak English&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;固定的动词短语（动词+介词），如 look for, take care of 等不能把动词与介词拆开，即介词不能提至引导词前。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;She is the right girl (who/whom/that) we are looking for.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;whose&lt;/strong&gt; 是所有格 “…的” 形式；&lt;strong&gt;whose + n. 一起在定语从句中充当主语、宾语(&lt;/strong&gt;动宾或介宾)，即先行词的什么东西。&lt;/p&gt;

    &lt;p&gt;whose 用来指人或物（只用作定语) ，且 whose 不能省略。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;em&gt;whose + n. = the + n. + of which/whom&lt;/em&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;I didn’t find the desk whose leg was broken. (主语)&lt;/li&gt;
      &lt;li&gt;He is the student whose pencil I broke yesterday. (动宾)&lt;/li&gt;
      &lt;li&gt;The boss in whose company I work is very kind. (介宾)&lt;/li&gt;
      &lt;li&gt;They rushed over to help the man whose car had broken down. (主语)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;which/that&lt;/strong&gt; 指物，&lt;strong&gt;代替先行词，且在定语从句中作主语或宾语(动宾或介宾)&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;作主语
        &lt;ul&gt;
          &lt;li&gt;The house which/that was destroyed in the earthquake is weak.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;作宾语&lt;/p&gt;

        &lt;p&gt;which/that 作宾语时，同样分为动宾与介宾两种情况：1. 作动宾时，which/that 可以省略；2. 作介宾时，介词不提前时，关系代词 which/that 可以省略；介词提前时，关系代词 which/that 不可以省略。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;The pen (which/that) you found yesterday is mine.&lt;/li&gt;
          &lt;li&gt;The games (that/which) the young men competed in were difficult.&lt;/li&gt;
          &lt;li&gt;The games in which the young men competed were difficult.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;介词 + which 指物；介词 + whom 指人&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;as&lt;/strong&gt; 指人或物，在定语从句中可作主语，宾语，表语或状语，不能省略&lt;/p&gt;

    &lt;p&gt;主要用于 “&lt;strong&gt;the same …as…；such …as…；so …as…；as … as…；as follows&lt;/strong&gt; ” 固定结构中。在这种形式的结构中，要用 as 代替 who(m), which, 或 that 引导定语从句。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Such people as knew Hill thought he was honest.&lt;/li&gt;
      &lt;li&gt;Such people as Hill knew thought he was honest.&lt;/li&gt;
      &lt;li&gt;My hometown is no longer the same as it was.&lt;/li&gt;
      &lt;li&gt;Here is so big a stone as no one can lift.&lt;/li&gt;
      &lt;li&gt;The child knows as much as grow-ups (know).&lt;/li&gt;
      &lt;li&gt;I’d like to have the same books as are used in your school.&lt;/li&gt;
      &lt;li&gt;He is not such a person as I expected.&lt;/li&gt;
      &lt;li&gt;He will marry as pretty a girl as he can find.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-关系副词的用法&quot;&gt;3-关系副词的用法&lt;/h2&gt;

&lt;p&gt;关系副词，兼有副词与连接词两种作用，在&lt;strong&gt;不及物动词的连接中要求用关系副词&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;关系副词在句中作状语，关系副词=介词+关系代词，定语从句中常用的关系副词有三个：&lt;strong&gt;when，where，why&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;when = during/on/in which  where = in/at/on which  why = for which&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;when&lt;/strong&gt; 主要用于修饰表时间的名词，同时它在定语从句中用作&lt;strong&gt;时间状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;There comes a time when you have to make a choice.&lt;/li&gt;
      &lt;li&gt;Gone are the days when they could do what they liked.&lt;/li&gt;
      &lt;li&gt;We’ll put off the picnic until next week, when the weather may be better.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;先行词为时间名词时不一定用关系副词 when 来引导定语从句；需要进一步判断先行词在定语从句中成分。如果在定语从句中作时间状语，则用 when；如果在定语从句中作主语或者宾语时，要用 that, which 等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Don’t forget the time (that, which) I’ve told you.（先行词 time 作 told 的宾语）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;where&lt;/strong&gt; 主要用于修饰表地点的名词，同时它在定语从句中用作&lt;strong&gt;地点状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;This is the village where he was born.&lt;/li&gt;
      &lt;li&gt;That’s the hotel where we were staying last summer.&lt;/li&gt;
      &lt;li&gt;Barbary was working in Aubury, where she went daily in a bus.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;同样，先行词为地点的名词时，不一定要用 where 引导，需要进一步判断先行词在定语从句中的成分。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He works in a factory that/which makes TV sets.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;why&lt;/strong&gt; 主要用于修饰表原因的名词(主要是the reason)，同时它在定语从句中用作&lt;strong&gt;原因状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;We don’t know the reason why he didn’t show up.&lt;/li&gt;
      &lt;li&gt;She didn’t tell me the reason why she refused the offer.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;why 与 where/when 的用法有点不同：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;why 可以省略或者替换成 that&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;That’s one of the reasons (why, that) I asked you to come.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;why 只能引导限制性定语从句，where/when 可以引导非限制性定语从句
        &lt;ul&gt;
          &lt;li&gt;The main reason, why he lost his job, was that he drank. (wrong)&lt;/li&gt;
          &lt;li&gt;The main reason why he lost his job was that he drank. (right)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-限制性与非限制性定语从句的区别&quot;&gt;4-限制性与非限制性定语从句的区别&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在句中作用不同
    &lt;ul&gt;
      &lt;li&gt;限制性定语从句&lt;strong&gt;对&lt;/strong&gt;被修饰的&lt;strong&gt;先行词有限定制约作用&lt;/strong&gt;，使该词的含义更具体,更明确。&lt;strong&gt;限制性定语从句不能被省略&lt;/strong&gt;，否则句意就不完整。&lt;/li&gt;
      &lt;li&gt;非限制性定语从句&lt;strong&gt;与先行词关系不是十分密切&lt;/strong&gt;，只是对其作一些附加说明，不起限定制约作用。如果将非限制性定语从句省去，主句的意义仍然完整。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表现形式不同&lt;/p&gt;

    &lt;p&gt;限制性定语从句因与先行词关系密切，所以&lt;strong&gt;不可以用逗号将其与主句隔开&lt;/strong&gt;；非限制性定语从句与先行词关系不是十分密切，所以&lt;strong&gt;可用逗号将其与主句隔开。&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Do you remember the girl who taught us English?&lt;/li&gt;
      &lt;li&gt;Clock is a kind of instrument which can tell people time.&lt;/li&gt;
      &lt;li&gt;This is the place where he used to live.&lt;/li&gt;
      &lt;li&gt;Mr. Zhang, who came to see me yesterday, is an old friend of mine.&lt;/li&gt;
      &lt;li&gt;We walked down the village street, where they were having market day.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;前三个例句中，定语从句与先行词关系密切，为限制性定语从句，不可用逗号隔开；后面两个例句中，定语从句与先行词关系不密切，为非限制性定语从句。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先行词内容有所不同&lt;/p&gt;

    &lt;p&gt;大多数限制性和非限制性定语从句的先行词往往为某一个词或短语，而特殊情况下&lt;strong&gt;&lt;em&gt;非限制性定语从句的先行词也可为整个主句,此时非限制性定语从句常由 which 引导&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;A middle-aged woman killed her husband&lt;/em&gt;, &lt;strong&gt;which&lt;/strong&gt; frightened me very much.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;A five-year-old boy can speak two foreign languages&lt;/em&gt;, &lt;strong&gt;which&lt;/strong&gt; surprises all the people present.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用的关系词有所不同
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;that 不可以引导非限制性定语从句&lt;/p&gt;

        &lt;p&gt;所有关系代词和关系副词都可以引导限制性定语从句，大部分关系代词与关系副词都可以引导非限制性定语从句，但是 that 除外。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;He gave his mother a color TV set for her birthday, that pleased her a lot.（wrong）&lt;/li&gt;
          &lt;li&gt;He gave his mother a color TV set for her birthday, &lt;strong&gt;&lt;em&gt;which&lt;/em&gt;&lt;/strong&gt; pleased her a lot.（wright）&lt;/li&gt;
          &lt;li&gt;He didn’t pass the exam, that disappointed me.（wrong）&lt;/li&gt;
          &lt;li&gt;He didn’t pass the exam, &lt;strong&gt;&lt;em&gt;which&lt;/em&gt;&lt;/strong&gt; disappointed me.（wright）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关系词替代情况不同&lt;/p&gt;

        &lt;p&gt;关系代词 whom 在限制性定语从句中作宾语时可用 who 代替 whom ,但 whom 在非限制性定语从句中作宾语时不可用 who 来代替。&lt;/p&gt;

        &lt;p&gt;在限制性定语从句中,先行词指人时可用 that 代替 who/whom ,但在非限制性定语从句中先行词指人时, 不可用 that 代替 who/whom。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关系代词省略情况不同&lt;/p&gt;

        &lt;p&gt;关系代词在&lt;strong&gt;&lt;em&gt;限制性定语从句中作宾语时可以省去&lt;/em&gt;&lt;/strong&gt;,非限制性定语从句的所有关系词均不可省。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;This is the book (&lt;em&gt;which/that&lt;/em&gt;) he lost yesterday.&lt;/li&gt;
          &lt;li&gt;The book, &lt;em&gt;which&lt;/em&gt; he lost yesterday, has been found.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-wich-与-that&quot;&gt;5-wich 与 that&lt;/h2&gt;

&lt;h3 id=&quot;5-1-定语从句中只用-that-不用-which&quot;&gt;5-1 定语从句中只用 that, 不用 which&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;先行词是 &lt;strong&gt;everything, anything, nothing&lt;/strong&gt; (something 除外), &lt;strong&gt;all, none, few, little, some&lt;/strong&gt; 等不定代词时，或当先行词被 &lt;strong&gt;every, any, all, some, no, little, few, much 等词修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Have you set down everything that Mr. Li said?&lt;/li&gt;
      &lt;li&gt;There seems to be nothing that is impossible to him in the world.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;当先行词指人时，偶尔也可用关系代词 who。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Any man that/who has a sense of responsibility won’t do such a thing.&lt;/li&gt;
      &lt;li&gt;All the guests that/who were invited to her wedding were important people.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被序数词修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;The first American movie that I watched was the Titanic.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被形容词最高级修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;This is the best museum that I have visited all my life.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被 the very, the only, the first/last 等修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;She is the only person that understands me.&lt;/li&gt;
      &lt;li&gt;After the big fire, the old car is the only thing that he owns.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;前面有 who, which 等疑问代词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Who is the man that is standing in front of the crowd?&lt;/li&gt;
      &lt;li&gt;Which is the room that Mr. Wang lives in?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词为人与动物或人与物
    &lt;ul&gt;
      &lt;li&gt;Look at the man and his donkey that are walking alone the street.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词是 reason, way 等词时，关系代词常用 that 代替 in which, for which, why，也常可省略
    &lt;ul&gt;
      &lt;li&gt;She admired the way (that) they solved the questions.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5-2-定语从句中只用-which-不用-that&quot;&gt;5-2 定语从句中只用 which, 不用 that&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在非限定性定语从句中，在任何情况下都不能用 that
    &lt;ul&gt;
      &lt;li&gt;This brunch of carnation, which is wound by silk ribbon, is the first gift to my mom.&lt;/li&gt;
      &lt;li&gt;These books, which you can get at any corner of the town, will give you all the information.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;关系代词前面有介词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Those days in which you could travel without a passport has gone.&lt;/li&gt;
      &lt;li&gt;That is the motel at which we stayed several years ago.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词本身为 that (指代作用)
    &lt;ul&gt;
      &lt;li&gt;what about that which had appeared in recent activities.&lt;/li&gt;
      &lt;li&gt;The knowledge are from various fields and that which display the waves of human being.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-基本概念</summary></entry><entry><title type="html">表语从句</title><link href="http://localhost:4000/predicative-clause.html" rel="alternate" type="text/html" title="表语从句" /><published>2022-02-09T00:00:00+08:00</published><updated>2022-02-09T00:00:00+08:00</updated><id>http://localhost:4000/predicative-clause</id><content type="html" xml:base="http://localhost:4000/predicative-clause.html">&lt;h2 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h2&gt;

&lt;p&gt;表语从句放在连系动词之后，充当复合句中的表语。&lt;/p&gt;

&lt;p&gt;表语从句( Predicative Clause )就是指一个&lt;strong&gt;句子作为表语，说明主语是什么或者怎么样&lt;/strong&gt;，由名词、形容词或相当于名词或形容词的词或短语充当，和&lt;strong&gt;连系动词一起构成谓语&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;2-构成&quot;&gt;2-构成&lt;/h2&gt;

&lt;p&gt;主语+连系动词+句子作表语(表语从句)&lt;/p&gt;

&lt;h2 id=&quot;3-引导表语从句的关联词&quot;&gt;3-引导表语从句的关联词&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;引导表语从句的&lt;strong&gt;连系动词&lt;/strong&gt;有：&lt;strong&gt;be，look，seem，sound，appea&lt;/strong&gt;r 等
    &lt;ul&gt;
      &lt;li&gt;China is no longer what she used to be.&lt;/li&gt;
      &lt;li&gt;The question remains whether they will be able to help us.&lt;/li&gt;
      &lt;li&gt;At that time，it seemed as if I couldn’t think of the right word.&lt;/li&gt;
      &lt;li&gt;It seems to me that we should answer for this. (在我看来…)&lt;/li&gt;
      &lt;li&gt;It appears to her that he wants to teach us all he has. (在她看来…)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;从属连词 whether，as，as if / though&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;He looked just as he had looked ten years before.&lt;/li&gt;
      &lt;li&gt;It sounds as if someone is knocking at the door.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;从属连词 that&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;The trouble is that I have lost his address.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;because，why&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;That’s because he didn’t understand me.（强调原因；那是因为…）&lt;/li&gt;
      &lt;li&gt;That’s why he got angry with me.（强调结果；那是为什么…）&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;what 引导的主语从句&lt;strong&gt;表示结果&lt;/strong&gt;或&lt;strong&gt;名词 reason 作主语&lt;/strong&gt;时，后面的表语从句表示原因时要用 that 引导，不宜用 because.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The reason why I was sad was &lt;strong&gt;that&lt;/strong&gt; he didn’t understand me.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;连接代词/连接副词&lt;/strong&gt;引导表语从句&lt;/p&gt;

    &lt;p&gt;连接代词有 : &lt;strong&gt;who，whom，whose，what，which，whoever，whatever，whichever&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The problem is who we can get to replace her.&lt;/li&gt;
      &lt;li&gt;That was what she did this morning on reaching the attic.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;连接副词有：&lt;strong&gt;where，when，how，why&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The question is how he did it.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用虚拟语气的表语从句&lt;/p&gt;

    &lt;p&gt;在&lt;strong&gt;表示建议、劝告、命令含义的名词后的表语从句，谓语动词需用 “should+动词原形” 表示&lt;/strong&gt;(should 可省略)。&lt;/p&gt;

    &lt;p&gt;常见的词有：&lt;strong&gt;advice，suggestion，order，proposal，plan，idea&lt;/strong&gt; 等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;My suggestion is that we (should) start early tomorrow.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-总结&quot;&gt;4-总结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;连系动词 be，appear，seem，look等之后可以跟表语从句&lt;/li&gt;
  &lt;li&gt;引导表语从句的引导词分为：
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;wh-疑问词&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;My question is who left.&lt;/li&gt;
          &lt;li&gt;What I wonder is when he left.&lt;/li&gt;
          &lt;li&gt;That’s what he wants.&lt;/li&gt;
          &lt;li&gt;This is where they once lived.&lt;/li&gt;
          &lt;li&gt;That is why he didn’t come here.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;whether&lt;/strong&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;if 不能引导表语从句&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;ul&gt;
          &lt;li&gt;My question is whether he left (or not).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;that&lt;/strong&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;that 有时可省略&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;ul&gt;
          &lt;li&gt;The fact is that he left.&lt;/li&gt;
          &lt;li&gt;The truth is（that）I didn’t go there.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;because，as，as if，as though&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;It’s just because he doesn’t know her.&lt;/li&gt;
          &lt;li&gt;Things are not always as they seem to be.&lt;/li&gt;
          &lt;li&gt;He looks as if he’s tired.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-介绍</summary></entry><entry><title type="html">宾语从句</title><link href="http://localhost:4000/object-clause.html" rel="alternate" type="text/html" title="宾语从句" /><published>2022-02-08T00:00:00+08:00</published><updated>2022-02-08T00:00:00+08:00</updated><id>http://localhost:4000/object-clause</id><content type="html" xml:base="http://localhost:4000/object-clause.html">&lt;h2 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h2&gt;

&lt;p&gt;定义：&lt;strong&gt;置于动词、介词等词性后面，在句子中起宾语作用的从句叫做宾语从句。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;宾语从句分为三类：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;动词的宾语从句&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;介词的宾语从句&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;形容词的宾语从句&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;宾语从句语法需要关注三点：时态，语序，连词。&lt;/strong&gt;宾语从句的语序必须是陈述语序，谓语动词、介词、动词不定式，v.-ing形式后面都能带宾语从句，有些形容词(afraid，sure，glad等)之后也可以带宾语从句。&lt;/p&gt;

&lt;h2 id=&quot;2-连接词&quot;&gt;2-连接词&lt;/h2&gt;

&lt;p&gt;在复合句中作主句的宾语，连接词有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;连词：that (that 常可省略), whether, if&lt;/li&gt;
  &lt;li&gt;代词：who, whose, what, which&lt;/li&gt;
  &lt;li&gt;副词：when ,where, how, why 等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-1-that-引导的宾语从句&quot;&gt;2-1 that 引导的宾语从句&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;在非正式场合that可以省略&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;可跟 that 从句做宾语的动词有：&lt;strong&gt;say, think, insist, wish, hope, demand, imagine, wonder, know, suppose, see, believe, agree, admit, deny, expect, explain, order, command, feel, dream, suggest, hear, mean, notice, prefer, request, require, propose, declare, report&lt;/strong&gt; 等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The boy believes that he will travel through space to other planets.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，&lt;strong&gt;当主句谓语动词是 think, believe, suppose, expect 等词，而宾语从句的意思是否定时，常把否定转移至主句表示。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I don’t think it is right for him to treat you like that.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在以下情况中 that 不能省略&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当句中的动词后接&lt;em&gt;多于两个由 that 引导的宾语从句&lt;/em&gt;时，第一个 that 可省，但后面的 that 不可省。
    &lt;ul&gt;
      &lt;li&gt;He said (that) you were too young to understand the matter and that he was asked not to tell you.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当&lt;em&gt;主句的谓语动词与 that 宾语从句之间有插入语&lt;/em&gt;时，that 一般不可省。
    &lt;ul&gt;
      &lt;li&gt;Just then I noticed, for the first time, that our master was wearing his fine green coat and his black silk cap.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当 &lt;em&gt;that 从句是双宾语中的直接宾语&lt;/em&gt;时，that 不可省。
    &lt;ul&gt;
      &lt;li&gt;I can’t tell him that his mother died.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;许多带复合宾语的句子，&lt;em&gt;that 引导的宾语从句经常移到句子后部，而用 it 作形式宾语&lt;/em&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I find it necessary that we should do the homework on time.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-2-whetherif-引导的宾语从句&quot;&gt;2-2 whether/if 引导的宾语从句&lt;/h3&gt;

&lt;p&gt;由 whether/if 引导的宾语从句，实际上是&lt;em&gt;一般疑问句演变而来的，&lt;/em&gt;意思是“是否”，此时&lt;strong&gt;宾语从句要用陈述句语序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一般说来，在宾语从句中 whether 与 if 可以互换使用，但在特殊情况下 if 与 whether 是不能互换的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I wonder whether(if) they will come to our party.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下场景不能互换：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;只能用 whether，不能用 if 引导的宾语从句&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;在带 to 的不定式前
        &lt;ul&gt;
          &lt;li&gt;We decided whether to walk there.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在介词的后面
        &lt;ul&gt;
          &lt;li&gt;I’m thinking of whether we should go to see the film.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在 discuss, decided 等动词后面的宾语从句
        &lt;ul&gt;
          &lt;li&gt;We discussed whether we had a sports meeting next week.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;直接与 or not 连用时
        &lt;ul&gt;
          &lt;li&gt;I can’t say whether or not they can come on time.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;只能用 if 不能用 whether 引导的宾语从句&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;if 引导条件状语从句，意为“如果”
        &lt;ul&gt;
          &lt;li&gt;The students will go on a picnic if it is sunny.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;if 引导否定概念的宾语从句时
        &lt;ul&gt;
          &lt;li&gt;He asked if I didn’t come to school yesterday.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;引导状语从句 even if(即使)和 as if(好象)时
        &lt;ul&gt;
          &lt;li&gt;He talks as if he has known all about it.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-连接代词和连接副词引导的宾语从句&quot;&gt;2-3 连接代词和连接副词引导的宾语从句&lt;/h3&gt;

&lt;p&gt;这样的宾语从句实际上是由&lt;em&gt;特殊疑问句变化而来的&lt;/em&gt;，&lt;strong&gt;宾语从句要用陈述句语序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;用于这种结构的动词常常是：&lt;strong&gt;see, say, tell, ask, answer, know, decide, show, find out, imagine, suggest, doubt, wonder, discover, understand, inform, advise&lt;/strong&gt; 等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;连接代词有：who, whom, whose, which, what，在&lt;strong&gt;句中担任主语、宾语、定语或者表语&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;Can you tell me whom you are waiting for?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接副词有：when,where,why,how，在&lt;strong&gt;句中担任状语的成分&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;None of us knows where these new parts can be bought.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-语序&quot;&gt;3-语序&lt;/h2&gt;

&lt;p&gt;无论主句是陈述句还是疑问句，&lt;strong&gt;宾语从句都必须使用陈述语序&lt;/strong&gt;，即“主句+连接词+宾语从句(主语+谓语+……)”句式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Could you tell me who knows the answer?&lt;/li&gt;
  &lt;li&gt;The small children don’t know what is in their stockings.&lt;/li&gt;
  &lt;li&gt;He asked whose handwriting was the best in our class.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-时态&quot;&gt;4-时态&lt;/h2&gt;

&lt;p&gt;含宾语从句的复合句，主句、从句谓语动词的时态呼应，包括以下几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;主句的谓语动词是一般现在时，从句的谓语动词可根据需要，选用相应的&lt;strong&gt;任何时态&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;I don’t know when he will come back.&lt;/li&gt;
      &lt;li&gt;He tells me that his sister came back yesterday.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;主句的谓语动词是过去时，宾语从句的谓语动词只可根据需要，选用过去时态即&lt;strong&gt;一般过去时、过去进行时、过去将来时或过去完成时的某一种形式&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;The children didn’t know who he was.&lt;/li&gt;
      &lt;li&gt;He asked his father how it happened.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果宾语从句所表示的是&lt;em&gt;客观事实、普遍真理、自然现象或习惯性动作&lt;/em&gt;等，不管主句用什么时态，&lt;em&gt;从句时态都用一般现在时&lt;/em&gt;。
    &lt;ul&gt;
      &lt;li&gt;The teacher said that the earth goes round the sun.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-总结&quot;&gt;5-总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;宾语从句可以作及物动词、介词及形容词的宾语。&lt;/li&gt;
  &lt;li&gt;宾语从句的语序一律用陈述句语序。&lt;/li&gt;
  &lt;li&gt;连接词 that 引导宾语从句在句中无词义，不充当句子成份，多数情况下可以省略。&lt;/li&gt;
  &lt;li&gt;whether 和 if 都可引导宾语从句，但 whether 后可紧跟 or not；whether 从句可作介词的宾语。&lt;/li&gt;
  &lt;li&gt;如果从句太长，可以用形式宾语it。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-介绍</summary></entry></feed>