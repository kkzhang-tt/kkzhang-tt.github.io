<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-27T16:59:10+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Find a needle in haystack</title><subtitle>Code.
</subtitle><author><name>kkzhang</name></author><entry><title type="html">Redis Cluster Specification</title><link href="http://localhost:4000/redis-cluster-specification.html" rel="alternate" type="text/html" title="Redis Cluster Specification" /><published>2022-02-19T00:00:00+08:00</published><updated>2022-02-19T00:00:00+08:00</updated><id>http://localhost:4000/redis-cluster-specification</id><content type="html" xml:base="http://localhost:4000/redis-cluster-specification.html">&lt;h1 id=&quot;1-main-properties-and-rationales-of-the-design&quot;&gt;1-Main properties and rationales of the design&lt;/h1&gt;

&lt;h2 id=&quot;1-1-redis-cluster-goals&quot;&gt;1-1 Redis Cluster goals&lt;/h2&gt;

&lt;p&gt;Redis Cluster 是 Redis 的分布式实现，按照优先级有以下目标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;高性能&lt;/strong&gt;（high performance）&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;线性扩展&lt;/strong&gt;（linear scalability）至 1000 个节点&lt;/li&gt;
  &lt;li&gt;没有代理；集群节点间通过&lt;strong&gt;异步复制数据&lt;/strong&gt;；不支持数据合并操作&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可接受的写入安全：在网络分区情况下，系统尽可能保存访问到多数派分区的 Client 的写操作。不过，存在一个小的时间窗口，在此期间的写入操作可能会丢失（&lt;em&gt;failover 前的写入可能会在 failover 过程中丢失&lt;/em&gt;）。如果 Client 的写入操作连接到少数派分区，则这个丢失时间窗口会更大。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;网络分区时，集群节点被划分成多数派分区（majority），少数派分区（minority）&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可用性：Redis Cluster 在&lt;strong&gt;大部分 master 节点可用，并且对少部分不可用的 master，每一个 master 至少有一个当前可用的 slave&lt;/strong&gt; 场景下能够保证集群的可用性。&lt;/p&gt;

    &lt;p&gt;另外，通过使用 &lt;strong&gt;replicas migration&lt;/strong&gt; 技术，当前没有 slave 的 master 会从当前拥有多个 slave 的 master 接受到一个新 slave 来确保可用性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-2-implemented-subset&quot;&gt;1-2 Implemented subset&lt;/h2&gt;

&lt;p&gt;Redis Cluster 实现了所有在非分布式 Redis 版本中的单 key 命令；但是对于使用多个 key 的复杂操作没有实现，比如 set 中的 unions &amp;amp; intersections 操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不支持多个 key 的复杂操作是为了避免 key-value 在不同的 Cluster 节点间移动，使得情况更加复杂&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;不过，Redis Cluster 实现了被称为 &lt;strong&gt;Hash Tags&lt;/strong&gt; 的概念：多个 key 可以通过相同的 hash tag 存储在相同的 hash slot 中，从而避免了 key 的迁移。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在手动 resharding 期间，多 key 操作可能变的不可用&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;除了支持的命令不同，Redis Cluster 只支持 database 0，并不像单机版 Redis 支持多个数据库。&lt;/p&gt;

&lt;h3 id=&quot;1-2-1-why-merge-operations-are-avoided&quot;&gt;1-2-1 Why merge operations are avoided&lt;/h3&gt;

&lt;p&gt;Redis Cluster 设计是避免在多个节点中存在相同 key-value 对的冲突版本，因为 Redis 中的值通常都是比较大的，数据类型也是语义复杂的，传输和合并这样的值将会影响性能。&lt;/p&gt;

&lt;h2 id=&quot;1-3-clients-and-servers-roles-in-the-redis-cluster-protocol&quot;&gt;1-3 Clients and Servers roles in the Redis Cluster protocol&lt;/h2&gt;

&lt;p&gt;Cluster 节点主要任务有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据维护&lt;/li&gt;
  &lt;li&gt;集群状态获取&lt;/li&gt;
  &lt;li&gt;将 key 映射到正确的 Cluster 节点&lt;/li&gt;
  &lt;li&gt;自动发现其他 Cluster 节点&lt;/li&gt;
  &lt;li&gt;检测异常 Cluster 节点&lt;/li&gt;
  &lt;li&gt;当某个 master 节点故障时，提升其副本为 master 节点，以保证 Cluster 正常运行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了实现上述功能，所有 Redis Cluster 节点间通过 &lt;strong&gt;Redis Cluster Bus&lt;/strong&gt; 互相连接：由 TCP bus 及二进制协议组成。节点间通过 &lt;strong&gt;Gossip 协议传递集群信息&lt;/strong&gt;，以此来实现新节点发现，节点探活及标定特定状态等功能。&lt;/p&gt;

&lt;p&gt;由于 Cluster 节点不能代理请求，因此 Client 在收到重定向异常（MOVED, ASK）时，需要将请求重定向到其他节点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Client 通过缓存 key → cluster node 的映射关系，减少重定向，提高执行效率&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-4-write-safety&quot;&gt;1-4 Write safety&lt;/h2&gt;

&lt;p&gt;Redis Cluster 通过&lt;strong&gt;节点间异步复制数据&lt;/strong&gt;，及 &lt;strong&gt;last failover wins&lt;/strong&gt; 避免合并功能 。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;last failover wins 指当 master 节点故障时，通过 failover 机制选取的新 master 节点将直接覆盖之前 master 节点的数据，并同步给其他 slaves（新 master 节点中的数据可能不是最新的，或者有所缺失）。通过 last failover wins 机制，最后选举出的新 master 副本数据会覆盖其他所有副本数据。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在网络分区期间，会存在一个写操作丢失的时间窗口。&lt;em&gt;对于发生在 master 节点多数派（majority）分区的写操作丢失窗口与少数派（minority）的丢失窗口是不同的&lt;/em&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于发生在多数派 master 的写操作，Redis Cluster 会尽量保存；但是以下两种场景除外：
 a. client 写操作请求到达 master 节点，当 master 执行完成并回复 client 成功之后，master 出现异常而不可访问；但是之前的写操作并未通过异步复制到其他 slaves 中。如果 master 不可访问的时间较长而导致其中的一个 slave 被选举成新的 master，那么之前的写操作将会丢失。
 b. 由于网络分区，某个 master 不可被访问。网络分区触发了一轮选举，导致其中的一个 slave 被选举成新的 master。网络分区恢复之后，old master 变成 new master 的 slave 之前，一个 client 通过过期的路由表对 old master 节点进行写入，此时的写入将会被全部丢失。&lt;/p&gt;

    &lt;p&gt;不过，对于第二种场景，在一些安全机制的条件下很难发生：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;少数派 master 与多数派 master 无法通信达到一定的时间后，将拒绝 client 的写操作请求&lt;/li&gt;
      &lt;li&gt;当网络分区恢复后，该 master 仍需要继续拒绝写入一段时间用来感知 Cluster 的配置变化，因此留给 client 的时间窗口很小&lt;/li&gt;
      &lt;li&gt;在分区恢复之后，其他节点会尽快尝试访问新加入的节点（携带最新的 Cluster 配置信息）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于发生在少数派 master 的写操作拥有更大的丢失窗口&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;如果少数派 master 节点通过 failover 转移到多数派 master 节点的分区，那么所有发送到少数派分区的写操作都将会被永久丢失&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;发生 failover 的前提是，其中的 master 节点至少在 NODE_TIMEOUT 时间内无法被多数派 master 节点访问&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分区故障时间小于 NODE_TIMEOUT，则不会出现写操作数据丢失&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分区故障时间大于 NODE_TIMEOUT，则对少数派 master 的写入操作将全部丢失&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;不过少数派 master 会在进入不可用状态之后拒绝写入请求&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-5-availability&quot;&gt;1-5 Availability&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Redis Cluster 能容忍集群中少数节点不可访问，但不适合要求大量网络分块的应用&lt;/strong&gt;（如多机房部署）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;集群在少数派分区侧不可用&lt;/li&gt;
  &lt;li&gt;对于多数派 master 分区，如果其他每个不可访问的 master 节点都至少有一个 slave 节点可达，那么在经过 NODE_TIMEOUT 重新选举之后，多数派分区仍然可用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;为了提高集群可用性，Redis Cluster 支持 Replicas Migration：&lt;/strong&gt;自动将转移副本节点到孤立的 master 节点（不再拥有 slave 的 master）；每次 failover 成功之后，都会重新配置 slave 副本分布以提高下一次故障期间的可用性。&lt;/p&gt;

&lt;h1 id=&quot;2-overview-of-redis-cluster-main-components&quot;&gt;2-Overview of Redis Cluster main components&lt;/h1&gt;

&lt;h2 id=&quot;2-1-keys-distribution-model&quot;&gt;2-1 Keys distribution model&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;key 的空间范围被划分为 16834 个 slot&lt;/strong&gt;，间接使得一个集群的最大上限为 16834 个 master 节点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般建议最大节点数少于 1000&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Cluster 中的每个 master 节点处理 16834 个 hash slot 的其中一部分子集。当 Cluster 处于稳定状态时，每个 hash slot 只会由一个节点提供服务。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;没有出现 slot 迁移的情况被认为是稳定状态&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;将 key 映射为对应的 hash slot 方法为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;HASH_SLOT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CRC16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16384&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-2-keys-hash-tags&quot;&gt;2-2 Keys hash tags&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Hash Tags 提供了一种将多个 key 分配到同一个 hash slot 的方式&lt;/strong&gt;。通过 Hash Tags 可以在 Redis Cluster 中实现对多个 key 的同时操作。&lt;/p&gt;

&lt;p&gt;Hash Tags 的规则如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;key 包含一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt; 字符&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;并且&lt;/em&gt; 如果在这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt;的右面有一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;}&lt;/code&gt;字符&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;并且&lt;/em&gt; 如果在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;}&lt;/code&gt;之间存在至少一个字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{ }&lt;/code&gt; 之间的字符将被用来计算 hash slot。如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{user1000}.following&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{user1000}.followers&lt;/code&gt;这两个 key 会被分配到相同的 hash slot 中，因为只有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user1000&lt;/code&gt;会被用来计算 hash slot 值。&lt;/p&gt;

&lt;h2 id=&quot;2-3-cluster-nodes-attributes&quot;&gt;2-3 Cluster nodes attributes&lt;/h2&gt;

&lt;p&gt;集群中的&lt;strong&gt;每个节点都有全局唯一 ID 标识&lt;/strong&gt;。启动时生成，并持久化在配置文件中，一般不会改变。&lt;/p&gt;

&lt;p&gt;每个节点还维护集群中其他节点的信息，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;node id&lt;/li&gt;
  &lt;li&gt;ip &amp;amp; port&lt;/li&gt;
  &lt;li&gt;标签&lt;/li&gt;
  &lt;li&gt;master node id（如果节点是 slave）&lt;/li&gt;
  &lt;li&gt;最后一次被挂起的 ping 的发送时间 &amp;amp; 最后一次收到 pong 的时间&lt;/li&gt;
  &lt;li&gt;该节点的当前 &lt;strong&gt;configuration epoch&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;该节点维护的 hash slots&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-4-the-cluster-bus&quot;&gt;2-4 The Cluster bus&lt;/h2&gt;

&lt;p&gt;每个集群节点使用额外的 TCP 端口用于与集群中的其他节点交互；集群节点间的交互只使用 Cluster bus 及 Cluster bus 协议：一种二进制协议。&lt;/p&gt;

&lt;h2 id=&quot;2-5-cluster-topology&quot;&gt;2-5 Cluster topology&lt;/h2&gt;

&lt;p&gt;Redis Cluster 是全网拓扑，&lt;strong&gt;每个节点都与其他节点维护 TCP 连接&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;N 个节点的集群中，每个节点有 N-1 个传出 TCP 连接，同时有 N-1 个传入 TCP 连接&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;集群节点间使用 &lt;strong&gt;Gossip 协议&lt;/strong&gt;和&lt;strong&gt;配置更新机制&lt;/strong&gt;来避免正常情况下节点间交互过多的消息。&lt;/p&gt;

&lt;h2 id=&quot;2-6-nodes-handshake&quot;&gt;2-6 Nodes handshake&lt;/h2&gt;

&lt;p&gt;对于 Cluster bus port 连接，节点总是接受并回复 ping 请求，即使该 ping 请求来自一个不可信任的节点。但是如果发送节点被认为不是集群的一部分，那么该节点的其他数据包都会被丢弃。&lt;/p&gt;

&lt;p&gt;通过两种方式可以判断一个节点是不是集群节点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;节点出现在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEET&lt;/code&gt; 消息中&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEET&lt;/code&gt; 消息会强制接收者接受一个节点作为集群的一部分&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;CLUSTER&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;节点出现在一个被信任的节点的 Gossip 消息中&lt;/strong&gt;：A 节点是被信任的集群节点，B 出现在 A 的Gossip 消息中，那么 C 收到 A 的消息后也会把 B 标记为集群节点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一旦我们将某个节点加入了连接图中，那么最终所有节点会自动形成一张全连接图（fully connected graph），即&lt;strong&gt;集群可以自动发现其他节点&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该机制使得集群更加健壮，可以防止不同的 Cluster 在 IP 地址变更或者其他网络相关事件导致意外混合&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h1 id=&quot;3-redirection-and-resharding&quot;&gt;3-Redirection and resharding&lt;/h1&gt;

&lt;p&gt;Redis Client 可以向集群中的任意节点发送查询请求，包括 slave 节点。&lt;/p&gt;

&lt;p&gt;收到请求的集群节点会分析该查询请求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果请求是可以接受的，则会判断 key 所属的 hash slot 及对应的节点&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;可以接受的请求是指：a. 请求中只包含一个 key；b. 多个 key 同属一个 hash slot&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;如果目标 hash slot 被当前节点管理，则直接处理请求&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;否则，当前节点回复一个 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 异常：&lt;/strong&gt;&lt;em&gt;异常包含了 key 所属的 hash slot 及管理该 hash slot 的节点（IP + Port）&lt;/em&gt;。&lt;/p&gt;

    &lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-MOVED&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3999&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;127.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6381&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Client 收到重定向的回复之后，需要向指定的 IP + Port 重新补发查询请求。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果在补发请求之前，集群配置再次发生了变化，导致刚才的节点不再管理对应的 hash slot，那么也会返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 异常，Client 仍需要再次补发请求&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 异常，Client 除了重新补发，还&lt;strong&gt;需要缓存 hash slot 与集群节点的映射关系&lt;/strong&gt;，以提高之后请求的效率。不过，该策略不是强制的，Client 还可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLUSTER NODES&lt;/code&gt; 命令&lt;strong&gt;全量刷新 hash slot 与集群节点的映射关系并缓存&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当 Cluster 处于稳定状态时，所有的 Client 最终都可以维护 hash slot → cluster nodes 的映射关系，减少重定向的概率，提升集群处理的效率。&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 重定向，Client 需要能够处理 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt; 重定向。&lt;/p&gt;

&lt;h2 id=&quot;3-2-cluster-live-reconfiguration&quot;&gt;3-2 Cluster live reconfiguration&lt;/h2&gt;

&lt;p&gt;为了支持 Cluster 动态重新配置，需要实现 &lt;strong&gt;hash slot 在集群节点间迁移能力&lt;/strong&gt;。slot 迁移的场景有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;添加节点：需要将一些已经存在 hash slot 集合迁移到新节点上&lt;/li&gt;
  &lt;li&gt;删除节点：将被删除节点上的所有 hash slot 集合转移到其他节点&lt;/li&gt;
  &lt;li&gt;集群 rebalance：将给定的 hash slot 集合在节点间移动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;hash slot 迁移的核心是分布在该 slot 上的 key 集合迁移&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下面是一些 slot 迁移的命令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER ADDSLOTS slot1 [slot2] … [slotN]&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER DELSLOTS slot1 [slot2] … [slotN]&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER SETSLOT slot NODE node&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER SETSLOT slot MIGRATING node&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;CLUSTER SETSLOT slot IMPORTING node&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADDSLOTS&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELSLOTS&lt;/code&gt;只是用来简单地在 Redis Cluster 节点上分配或移除 slot。&lt;strong&gt;在分配了 hash slots 之后，节点会通过 Gossip 协议在集群中传播这些信息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SETSLOT slot NODE node&lt;/code&gt; 用来给特定的节点分配 slot。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLUSTER SETSLOT slot MIGRATING node&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLUSTER SETSLOT slot IMPORTING node&lt;/code&gt; 命令用于将 hash slot 从一个节点迁移到另一个节点。迁移过程总涉及到两个特殊的状态：&lt;strong&gt;MIGRATING&lt;/strong&gt; &amp;amp; &lt;strong&gt;IMPORTING&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当 hash slot 处于 &lt;strong&gt;MIGRATING&lt;/strong&gt; 状态时，如果某个查询请求的 key 在该 slot 中，则当前节点会处理该查询请求；否则，节点就会通过 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 命令重定向到迁移的目标节点&lt;/li&gt;
  &lt;li&gt;当 hash slot 处于 &lt;strong&gt;IMPORTING&lt;/strong&gt; 状态时，如果某个查询请求后紧跟着 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASKING&lt;/code&gt;&lt;/strong&gt; 命令，则该请求就会被执行；否则，该请求就会通过 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt;&lt;/strong&gt; 命令重定向到管理该 hash slot 的真正节点&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-2-1-migration-process&quot;&gt;3-2-1 Migration process&lt;/h3&gt;

&lt;p&gt;假设 Redis Cluster 中存在 A，B 两个节点，我们期望将 hash slot 8 从 A 迁移到 B，则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向 B 发送命令 &lt;em&gt;CLUSTER SETSLOT 8 IMPORTING A&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;向 A 发送命令 &lt;em&gt;CLUSTER SETSLOT 8 MIGRATING B&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有其他节点在收到一个对属于 hash slot 8 的 key 的查询时，仍然会继续将 Client 重定向到 A，会导致：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有对已经存在的 key 查询将会被 A 处理&lt;/li&gt;
  &lt;li&gt;所有在 A 上不存在的 key 都会被 B 处理，因为 A 会将其重定向到 B（&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt;）&lt;/li&gt;
  &lt;li&gt;将&lt;strong&gt;不会在 A 上创建新的 key&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 key 的迁移过程中，从 Client 的视角来看，同一个 key 只会存在 A or B 中。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-3-ask-redirection&quot;&gt;3-3 ASK redirection&lt;/h2&gt;

&lt;p&gt;在 slot 迁移过程中，使用的是 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 命令进行重定向，为什么不使用 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt;&lt;/strong&gt; 命令进行重定向？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;**MOVED**&lt;/code&gt; 表明&lt;strong&gt;目标 hash slot 永久地被一个不同的节点所管理&lt;/strong&gt;，并且以后的请求也应该继续指向该节点；而 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 表明&lt;strong&gt;只是下次查询需要发送给另一个特定节点&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们期望 Client 总是&lt;strong&gt;先尝试访问 A，然后在有必要的时候再访问 B&lt;/strong&gt;。因为同一个 hash slot 中有很多 key，可能某次查询的 key 已经不在 A 上了，需要再次重定向到 B 查询；但是可能下次查询的 key 仍然在 A 上。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 重定向只发生在 hash slot 迁移过程中，对 Cluster 的影响可以接受&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASKING&lt;/code&gt; 命令会为 client 设置一个&lt;strong&gt;单次标签(one-time flag)&lt;/strong&gt;，以允许该 client 可以访问处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;**IMPORTING**&lt;/code&gt; 状态的 slot 一次。&lt;/p&gt;

&lt;p&gt;从 client 的视角来看，当收到 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASK&lt;/code&gt;&lt;/strong&gt; 重定向命令之后：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;仅仅将这条查询重定向到指定的新节点，&lt;strong&gt;之后的命令还是继续发送给老的节点&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;重定向查询必须以一条&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASKING&lt;/code&gt;命令开始&lt;/li&gt;
  &lt;li&gt;暂时不要在本地将 hash slot 8 映射为节点 B&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当 hash slot 8 迁移完成之后，A 会返回一个 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt;&lt;/strong&gt; 重定向命令，client 需要在本地更新 hash slot 8 的映射节点为 B。&lt;/p&gt;

&lt;h2 id=&quot;3-4-clients-first-connection-and-handling-of-redirections&quot;&gt;3-4 Clients first connection and handling of redirections&lt;/h2&gt;

&lt;p&gt;Redis Cluster 的 Client 如果不将 hash slots → cluster nodes 的映射关系缓存在本地，那么每次查询都需要根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 重定向找到正确的节点，效率会很低。为了提高查询效率，Client 需要将 slots → nodes 的映射缓存在本地，但是该缓存并不总是最新的。&lt;/p&gt;

&lt;p&gt;在以下两个场景中 Client 需要获取全量的 hash slots → cluster nodes 的映射关系：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;启动阶段初始化 slots 配置信息&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;收到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOVED&lt;/code&gt; 的重定向信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Client 在收到 MOVED 重定向时，通常会有多个 slots 发生了变动（比如 slave 晋升，该节点的 slots 会重新映射），此时 Client 全量更新 slots 会使问题处理起来比较简单&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-5-multiple-keys-operations&quot;&gt;3-5 Multiple keys operations&lt;/h2&gt;

&lt;p&gt;通过使用 hash tags 可以对多个 key 进行操作。&lt;/p&gt;

&lt;p&gt;不过，在 resharding 期间，多个 key 操作可能会不可用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果这些 key 在同一个节点上，则可以继续可用&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果这些 key 在不同的节点上，则不可用&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;请求的多 key 所属的 slot 在迁移过程中，这些 &lt;strong&gt;key 可能同时分布在源节点与目标节点&lt;/strong&gt;上&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-6-scaling-reads-using-replica-nodes&quot;&gt;3-6 Scaling reads using replica nodes&lt;/h2&gt;

&lt;p&gt;slave 节点默认不可读，&lt;strong&gt;所有对 slave 节点的读请求都会被重定向到 master 节点&lt;/strong&gt;（返回 MOVED 异常）。不过可以通过 READONLY 命令将 slave 节点设置为可读。&lt;/p&gt;

&lt;h1 id=&quot;4-fault-tolerance&quot;&gt;4-Fault Tolerance&lt;/h1&gt;

&lt;h2 id=&quot;4-1-heartbeat-and-gossip-messages&quot;&gt;4-1 Heartbeat and gossip messages&lt;/h2&gt;

&lt;p&gt;Redis Cluster 存在两种&lt;strong&gt;心跳包（heartbeat packets）&lt;/strong&gt;，分别称为 &lt;strong&gt;ping&lt;/strong&gt; 包 &amp;amp; &lt;strong&gt;pong&lt;/strong&gt; 包。这两种心跳包结构相同，并且都会携带重要的配置信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当节点收到 ping 包时，总会回复一个 pong 包&lt;/li&gt;
  &lt;li&gt;有时节点为了尽快将自身的配置信息发送出去，会直接向其他节点发送 pong 包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个节点会随机挑选一些节点并发送一些 ping 包（&lt;strong&gt;Gossip 协议&lt;/strong&gt;），每个节点在指定时间范围内发送的 ping 包与接收到的 pong 包是一个常数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;会主动对 &lt;em&gt;NODE_TIMEOUT/2 时间内没有发送过 ping 或者从其接收到 pong&lt;/em&gt; 的节点发送 ping 包&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;4-2-heartbeat-packet-content&quot;&gt;4-2 Heartbeat packet content&lt;/h2&gt;

&lt;p&gt;ping &amp;amp; pong 包的内容包含两部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;包头（header）&lt;/strong&gt;：该部分不仅可以用于 ping &amp;amp; pong 消息，也可以用于其他类型消息（如重新选举消息）&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;内容&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Node ID&lt;/td&gt;
          &lt;td&gt;节点创建时生成，并在 Redis Cluster 生命周期内保持不变&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;currentEpoch &amp;amp; configEpoch&lt;/td&gt;
          &lt;td&gt;由 Redis Cluster 用来加载分布式算法；如果发送者是 slave 节点，则 configEpoch 就是其 master 的 configEpoch&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;node flags&lt;/td&gt;
          &lt;td&gt;表明发送者是 slave 还是 master；同时包含一些其他信息&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;hash slots 的 bitmap&lt;/td&gt;
          &lt;td&gt;如果发送者是 slave，则表示其 master 的 hash slots 的 bitmap&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TCP Port&lt;/td&gt;
          &lt;td&gt;用于接受命令的普通端口（+10000 表示 Redis Cluster Bus 端口）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Cluster state&lt;/td&gt;
          &lt;td&gt;发送者视角下的集群状态（down or ok）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;master Node ID&lt;/td&gt;
          &lt;td&gt;master 节点的 Node ID（如果发送者是 slave）&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Gossip section&lt;/strong&gt;：仅存在 ping &amp;amp; pong 中；包含&lt;strong&gt;&lt;em&gt;发送者视角下集群中其他节点状态，用于故障检测 &amp;amp; 节点发现&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;内容&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Redis Cluster 中其他节点信息&lt;/td&gt;
          &lt;td&gt;包含 Node ID, IP, Port, Node flags(FAIL, PFAIL)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Gossip section 段中包含的节点数与集群大小成正比&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-3-failure-detection&quot;&gt;4-3 Failure detection&lt;/h2&gt;

&lt;p&gt;Redis Cluster 故障检测机制用来&lt;strong&gt;识别一个 master or slave 节点对集群中大部分 master 节点是否是可达的（reachable）&lt;/strong&gt;。如果一个 master 节点不可达，则会将其一个 slave 节点晋升为 master；&lt;strong&gt;&lt;em&gt;如果无法将 slave 晋升为 master，则集群会被置为 error 状态，并停止接受客户端的请求&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;选举过程需要 master 节点参与&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如何定义不可达？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个已经发送出去，但是没有接收到对方回复的 ping 被称为活跃 ping（active ping）。如果一个活跃 ping 挂起时间超过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT&lt;/code&gt;，则认为接收方不可达。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT&lt;/code&gt; 必须大于正常的网络往返时间。为了增加可靠性，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT/2&lt;/code&gt; 时间过后如果还没收到回复，会尝试联系其他节点，确保自身连接的活跃性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-3-1-pfail--fail&quot;&gt;4-3-1 PFAIL &amp;amp; FAIL&lt;/h3&gt;

&lt;p&gt;Redis Cluster 每个节点都会保存其他节点的一些 flags 信息，其中有两个 flag 用于&lt;strong&gt;故障检测：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL &amp;amp; PFAIL&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; flag (possible fail)&lt;/p&gt;

    &lt;p&gt;可能故障，是一个不需要确认的故障类型。&lt;/p&gt;

    &lt;p&gt;当节点发现某个节点失联超过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT&lt;/code&gt; 时，会在本地将其标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;检测节点与被检测节点都可以是 master 或者 slave&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag（fail）&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; 只是每个节点针对其他节点状态的本地信息，不能以此来判断是否进行选举。为了确认节点确实不可达了，需要将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; 升级为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-2-pfail--fail&quot;&gt;4-3-2 PFAIL → FAIL&lt;/h3&gt;

&lt;p&gt;每个 Gossip 消息中都会包含当前节点已知的一部分其他节点的状态（是否 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt;），节点之间会交换自己已知信息；将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; 升级为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;的流程为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点 A 检测到 B 节点不可达，将其标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;节点 A 通过 Gossip 消息收集大部分 master 节点对 B 节点状态标记的 flag&lt;/li&gt;
  &lt;li&gt;多数 master 节点在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间范围内将 B 标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A 将 B 标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A &lt;strong&gt;发送一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 消息给所有可达节点&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FAIL 消息会强制所有接收到消息的节点将不可达节点 B 标记为 FAIL&lt;/strong&gt;，而不管自己当前是否已经将 B 标记为 PFAIL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag 是单向（one way）的：只能 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL&lt;/code&gt; → &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;。不过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag 可以在以下情况中被清除：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;节点重新可达，并且该节点是 slave&lt;/strong&gt;：因为 slave 节点不会发生故障转移（failover）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;节点重新可达，并且没有管理任何 hash slots 的 master 节点&lt;/strong&gt;：这种节点实际上没有参与集群管理，需要等待被配置后加入集群&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;节点重新可达，且为 master 节点，同时在较长时间内（N * NODE_TIMEOUT）没有检测到有 slave 节点晋升&lt;/strong&gt;：此时最好将其作为 master 节点重新加入集群&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFAIL → FAIL&lt;/code&gt; 的转换过程使用了&lt;strong&gt;弱一致性&lt;/strong&gt;（weak agreement）:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;节点在一段时间内收集其他 master 节点的视图，即使多数 master 达成一致，也只能说明在不同的时间，不同的节点达成一致，无法确定在什么时刻获得了多数 master 的一致结果。不过，过期的结果会被抛弃掉（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; ），所以&lt;strong&gt;可以确定多数 master 节点一定是在某个时间窗口内达成一致&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 消息虽然可以强制其他节点接受该判断结果，但是无法保证消息被所有节点接收到：如出现了网络分区&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-3-conner-case&quot;&gt;4-3-3 Conner case&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Redis Cluster 所有节点最终会对一个给定的节点状态达成一致&lt;/strong&gt;。两个由于集群脑裂引起的场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果多数派 master 将一个节点标记为 FAIL，那么所有其他节点最终也会将该 master 标记为 FAIL：在指定的时间窗口内，集群中会有足够多的失败报告&lt;/li&gt;
  &lt;li&gt;如果少数派 master 节点将一个节点标记为 FAIL，并不会发生 failover，最终该 FAIL 状态会被清除：在 N*NODE_TIMEOUT 内没有晋升&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-4-moreover&quot;&gt;4-3-4 Moreover&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; flag 只是一种触发机制，用于触发执行 slave 晋升操作。slave 也可以在发现 master 不可达之后主动启动晋升操作，并尝试获得多数 master 节点的同意。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 机制虽然有些复杂，但是可以使得集群意识到自己处于一个 error 状态，从而拒绝写操作；而且可以减少由于 slave 自身问题触发错误的选举尝试。&lt;/p&gt;

&lt;h1 id=&quot;5-configuration-handling-propagation-and-failovers&quot;&gt;5-Configuration handling, propagation, and failovers&lt;/h1&gt;

&lt;h2 id=&quot;5-1-cluster-current-epoch&quot;&gt;5-1 Cluster current epoch&lt;/h2&gt;

&lt;p&gt;Redis Cluster 使用类似 Raft 算法中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;term&lt;/code&gt; 的概念，被称为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;相当于集群的逻辑时钟，为事件提供递增的版本号&lt;/strong&gt;。当多个节点的信息冲突时，可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 判断哪个信息是最新的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 是一个 64 位无符号整数，用于标识集群 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;；所有节点中最大的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 即为集群  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;节点创建时，所有 Redis Cluster 节点（master or slave）都将自己的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 设置为 0。当从其他节点收到消息时，如果发送方的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 大于当前节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;，则&lt;strong&gt;将自身的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 更新为发送方的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt;&lt;/strong&gt;。这样，最终所有节点都会与拥有最大 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 的节点保持一致。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 被设计用于，&lt;em&gt;当集群状态变化时，某个节点请求其他节点的同意来执行一些操作&lt;/em&gt;（如 slave → master）；拥有较大 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoch&lt;/code&gt; 的节点总能获得相对较小节点的同意。&lt;/p&gt;

&lt;h2 id=&quot;5-2-configuration-epoch&quot;&gt;5-2 Configuration epoch&lt;/h2&gt;

&lt;p&gt;当 master 节点被创建时，其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 被置为 0。新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 将会在 slave 晋升为 master 之后被创建。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 由 master 节点创建，在 failover 时产生一个新的，递增唯一值&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在 Redis Cluster 处于稳定状态时，slave 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 为其与 master 节点交互时从 master 节点获取的（与 master 保持一致，不过可能会有所延迟）。&lt;/p&gt;

&lt;p&gt;master 与 slave 节点交互时都会携带自己的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt;，并且会广播给集群中其他节点。当某些节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 发生变化时，收到该消息的节点会将最新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 持久化到各自的本地配置文件中。&lt;/p&gt;

&lt;h2 id=&quot;5-3-replica-election-and-promotion&quot;&gt;5-3 Replica election and promotion&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;选举 &amp;amp; 晋升总是由 slave 节点发起与处理&lt;/strong&gt;，master 节点在选举过程中参与投票。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;选举的条件？
    &lt;ol&gt;
      &lt;li&gt;master 处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 状态&lt;/li&gt;
      &lt;li&gt;master 至少管理一个 hash slot&lt;/li&gt;
      &lt;li&gt;slave 与 master 的复制链接断开时间少于给定值：用于确保晋升的 slave 数据尽可能新&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;什么时候触发选举？
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;当 master 在至少一个 slave 视图中处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; 状态时，且 slave 要求晋升为 master，就会触发选举流程&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;多个 slave 都可以发起选举流程，但是只有一个 slave 能赢得选举&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;选举流程？
    &lt;ol&gt;
      &lt;li&gt;slave 增加自己的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;slave 向集群所有 master 节点广播 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_REQUEST&lt;/code&gt; 包请求选票，并且在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间内等待所有 master 节点的回复&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;master 收到投票请求后，如果准备将选票投给对应的 slave，则回复 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_ACK&lt;/code&gt;，并且在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间内不能给其他 slave 进行投票&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;避免多个 slave 赢得选票&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;slave 抛弃那些 epoch 比自己发送选票请求时的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 小的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_ACK&lt;/code&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;避免计算上一次选举的选票&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;如果 slave 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 2&lt;/code&gt; 时间内赢得了大部分 master 节点的选票，则其赢得选举；否则将会在  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_TIMEOUT * 4&lt;/code&gt; 时间后再次尝试&lt;/li&gt;
      &lt;li&gt;slave 赢得选举后会新增 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt;，该 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 会比其他 master 节点更大。随后会在 ping &amp;amp; pong 中广播该 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch.&lt;/code&gt;为了加速配置更新，新 master 会向其他节点直接发送 pong 包&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-4-masters-reply-to-replica-vote-request&quot;&gt;5-4 Masters reply to replica vote request&lt;/h2&gt;

&lt;p&gt;在选举过程中，master 需要为接收到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER_AUTH_REQUEST&lt;/code&gt; 请求进行投票，投票的条件为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;master 只会对每个 epoch 投票一次，并且拒绝比上次投票更小的 epoch 请求&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lastVoteEpoch&lt;/code&gt; 保存在 master 节点本地&lt;/li&gt;
  &lt;li&gt;请求的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt; 如果小于当前 master  的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentEpoch&lt;/code&gt;，则会被忽略&lt;/li&gt;
  &lt;li&gt;请求的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 如果小于其所属 master 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt;，则也会被忽略。由于 slave 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 从其 master 获取，这种情况说明 slave 并不是比较新的&lt;/li&gt;
  &lt;li&gt;salve 所属的 master 被当前 master 标记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAIL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-5-hash-slots-configuration-propagation&quot;&gt;5-5 Hash slots configuration propagation&lt;/h2&gt;

&lt;p&gt;Redis Cluster 提供一种机制，用于在集群中传播每个节点管理的 hash slot 配置信息。&lt;/p&gt;

&lt;p&gt;有两种传播 hash slot 配置信息的方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;心跳包：ping &amp;amp; pong 消息的发送方总会携带自己或者其 master 管理的 hash slot 信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息：心跳包的接收方如果发现发送方的消息过期，则会回复 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息，&lt;strong&gt;强制对方更新其过期信息&lt;/strong&gt;。（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息中包含了最新的配置信息）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当新的 Redis Cluster 节点创建时，其本地 hash slots 映射表初始化为 NULL，基本如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;16383&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;hash slots 配置的传播规则如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果在 A 节点的本地一个 hash slot 没有被分配（NULL），此时有 B 节点声明了该 slot，则修改 A 本地的 hash slot 映射关系将该 slot 绑定为 B&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果 A 节点中一个 hash slot 已经被 C 分配，此时 B 的广播消息中的 configEpoch 比 C 节点的 configEpoch 大，则将该 hash slot 绑定为 B&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;最终所有节点一定会通过节点间的消息广播就 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configEpoch&lt;/code&gt; 最大的节点获得 slot 的管理权达成一致；这一机制被称为 &lt;strong&gt;last failover wins(最后故障转移者胜)&lt;/strong&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于以上规则，当一个过期的节点收到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 消息时，会根据最新消息更新自己的配置。&lt;/p&gt;

&lt;p&gt;当一个 master 节点在分区后重新加入集群时，会将自己从属于新的 master 节点，并更新自身配置。&lt;/p&gt;

&lt;h2 id=&quot;5-6-replica-migration&quot;&gt;5-6 Replica migration&lt;/h2&gt;

&lt;p&gt;备份迁移是一种 slave 自动重配的过程，用来将备份节点迁移到当前已经没有可用 slave 的 master上，提高集群可用性。&lt;/p&gt;

&lt;p&gt;假设 A 只有一个 slave A，可能的迁移场景为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A发生故障，A1 被晋升。&lt;/li&gt;
  &lt;li&gt;C2 迁移为 A1 的 slave，否则 A1 将会没有任何 slave&lt;/li&gt;
  &lt;li&gt;一段时间后 A1 也发生了故障&lt;/li&gt;
  &lt;li&gt;C2 被晋升为新的 master 以替代 A1&lt;/li&gt;
  &lt;li&gt;此时，集群还能正常提供服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-appendix&quot;&gt;6-Appendix&lt;/h1&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://redis.io/topics/cluster-spec&quot;&gt;https://redis.io/topics/cluster-spec&lt;/a&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">1-Main properties and rationales of the design</summary></entry><entry><title type="html">同位语从句</title><link href="http://localhost:4000/appositive-clause.html" rel="alternate" type="text/html" title="同位语从句" /><published>2022-02-13T00:00:00+08:00</published><updated>2022-02-13T00:00:00+08:00</updated><id>http://localhost:4000/appositive-clause</id><content type="html" xml:base="http://localhost:4000/appositive-clause.html">&lt;h2 id=&quot;1-同位语&quot;&gt;1-同位语&lt;/h2&gt;

&lt;p&gt;一个名词（或其它形式）&lt;strong&gt;&lt;em&gt;对另一个名词或代词进行解释或补充说明&lt;/em&gt;&lt;/strong&gt;，这个名词（或其它形式）就是同位语。&lt;/p&gt;

&lt;p&gt;同位语与被它限定的词的格式要一致，并常常紧挨在一起。同位语除表示其同位成分的全部意义外，还可以表示部分意义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mr. Smith, our new teacher, is very kind to us.&lt;/li&gt;
  &lt;li&gt;He told me that his brother John was a world-famous doctor.(John 是 brother 的同位语)&lt;/li&gt;
  &lt;li&gt;Yesterday I talked to my English teacher, Mr. James.&lt;/li&gt;
  &lt;li&gt;We Chinese people are brave and hard-working.(Chinese people 是 we 的同位语)&lt;/li&gt;
  &lt;li&gt;He is interested in sports, especially ball games.(ball games 是 sports 的同位语)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-同位语从句&quot;&gt;2-同位语从句&lt;/h2&gt;

&lt;p&gt;同位语从句指的是在复合句中充当同位语的从句，属于名词性从句的范畴。&lt;/p&gt;

&lt;p&gt;同位语从句用来&lt;em&gt;对其前面的抽象名词进行解释说明&lt;/em&gt;，被解释说明的词和同位语在逻辑上是&lt;strong&gt;主表关系&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2-1-先行词&quot;&gt;2-1 先行词&lt;/h3&gt;

&lt;p&gt;可以连接同位语从句的名词有：&lt;strong&gt;news，idea，fact，promise，question，doubt，thought，hope，message，suggestion，words(消息)，possibility, decision&lt;/strong&gt; 等(一般的”抽象”名词)。&lt;/p&gt;

&lt;h3 id=&quot;2-2-引导词&quot;&gt;2-2 引导词&lt;/h3&gt;

&lt;p&gt;引导同位语从句的词语通常有连词 that, whethe, 连接代词和连接副词等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;that 连接从句时，&lt;strong&gt;从句为一个句意完整的陈述句&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;that 不能省略，没有具体的含义，&lt;strong&gt;&lt;em&gt;不充当句子成分，只起连接作用&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The idea &lt;em&gt;that you can do this work well without thinking&lt;/em&gt; is quite wrong.(that 引导的从句作 idea 的同位语)&lt;/li&gt;
      &lt;li&gt;We heard the news &lt;em&gt;that our team had won&lt;/em&gt;.(news 的同位语)&lt;/li&gt;
      &lt;li&gt;They were worried over the fact &lt;em&gt;that you were sick&lt;/em&gt;.(fact 的同位语)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;在某些名词(如 &lt;strong&gt;demand, wish, suggestion, resolution&lt;/strong&gt;等) 后面的同位语从句要&lt;strong&gt;用虚拟语气&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;There was a suggestion &lt;em&gt;that Brown should be dropped from the team&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;引导同位语从句的连词 that 通常不省略，但在&lt;em&gt;非正式文体中也可以省去&lt;/em&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He grabbed his suitcase and gave the impression &lt;em&gt;he was boarding the Tokyo plane&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;whether 引导同位语从句&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;if 不能引导同位语从句&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;There is some doubt &lt;em&gt;whether he will come&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;Answer my question &lt;em&gt;whether you are coming&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;The question &lt;em&gt;whether it is right or wrong&lt;/em&gt; depends on the result.&lt;/li&gt;
      &lt;li&gt;We are not investigating the question &lt;em&gt;whether he is trustworthy&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接代词 what, who, whom, whose 引导同位语从句
    &lt;ul&gt;
      &lt;li&gt;I have no idea &lt;em&gt;what size shoes she wears&lt;/em&gt;.(what 作 size 的定语)&lt;/li&gt;
      &lt;li&gt;The question &lt;em&gt;who will take his place&lt;/em&gt; is still not clear.(who 作同位语从句的主语)&lt;/li&gt;
      &lt;li&gt;Have you any idea &lt;em&gt;what time it starts&lt;/em&gt;?&lt;/li&gt;
      &lt;li&gt;I have no idea &lt;em&gt;who can really understand my complicated mind&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接副词 where, when, why, how 引导同位语从句
    &lt;ul&gt;
      &lt;li&gt;I have no idea &lt;em&gt;when he will come back&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;It is a question &lt;em&gt;how he does it&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;He had no idea &lt;em&gt;why she left&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;You have no idea &lt;em&gt;how worried I was&lt;/em&gt;!&lt;/li&gt;
      &lt;li&gt;We haven’t yet settled the question &lt;em&gt;where we are going to spend our summer vacation&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-同位语</summary></entry><entry><title type="html">Redis Cluster Tutorial</title><link href="http://localhost:4000/redis-cluster-tutorial.html" rel="alternate" type="text/html" title="Redis Cluster Tutorial" /><published>2022-02-13T00:00:00+08:00</published><updated>2022-02-13T00:00:00+08:00</updated><id>http://localhost:4000/redis-cluster-tutorial</id><content type="html" xml:base="http://localhost:4000/redis-cluster-tutorial.html">&lt;h2 id=&quot;1-introduction&quot;&gt;1-Introduction&lt;/h2&gt;

&lt;p&gt;Redis Cluster 支持&lt;strong&gt;数据自动在多个 Redis 节点间分片&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通过 Redis Cluster，能够实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;自动切分数据集到多个节点&lt;/strong&gt;（Sharding）&lt;/li&gt;
  &lt;li&gt;当部分节点故障或不可达的情况下，Redis Cluster 能够继续提供服务（High Availability）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Redis Cluster 提供&lt;strong&gt;&lt;em&gt;一定程度的高可用&lt;/em&gt;&lt;/strong&gt;，当某些节点失败或者不能访问的情况下能够继续提供服务。但是当大量节点失败的情况下集群也会停止服务（例如大多数主节点不可用）。&lt;/p&gt;

&lt;h2 id=&quot;2-tcp-ports&quot;&gt;2-TCP Ports&lt;/h2&gt;

&lt;p&gt;每个 Redis Cluster 节点需要打开两个 TCP 端口用于不同的连接。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;端口 &lt;strong&gt;6379&lt;/strong&gt;：用于提供&lt;strong&gt;客户端连接&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;该端口需要开放给所有与集群交互的客户端；同时，也要开放给集群中的其他节点用于 keys 迁移&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;端口 &lt;strong&gt;16379&lt;/strong&gt;：用于&lt;strong&gt;集群总线&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;该端口需要开放给集群中的其他节点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;客户端只能连接 6379，而不能连接 16739；而集群中的节点可以访问 6379 与 16739 两个端口&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;集群总线用于集群节点之间访问，使用&lt;em&gt;二进制协议&lt;/em&gt;，主要用于&lt;strong&gt;失败检测、配置升级、故障转移授权&lt;/strong&gt;等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;二进制协议更适合节点间使用小的带宽和处理时间来交换数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;3-data-sharding&quot;&gt;3-Data Sharding&lt;/h2&gt;

&lt;p&gt;Redis Cluster 的&lt;strong&gt;数据分片&lt;/strong&gt;不是使用一致性 Hash，而是使用一种 &lt;strong&gt;Hash Slot（哈希槽&lt;/strong&gt;）的形式。&lt;/p&gt;

&lt;p&gt;Redis Cluster 中共有 16384 个 Slot，如何决定每个 key 分配到哪个槽呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Slot_Index = &lt;strong&gt;CRC16(key) % 16384&lt;/strong&gt; 计算 Slot 索引&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cluster 中的每个节点负责一部分 Hash Slot，比如集群中有３个节点，则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A 存储的范围：0 ~ 5500&lt;/li&gt;
  &lt;li&gt;Ｂ存储的范围：5501 ~ 11000&lt;/li&gt;
  &lt;li&gt;Ｃ存储的范围：11001 ~ 16384&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种分配方式便于集群节点的新增与剔除。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新增一个节点Ｄ：需要把Ａ、Ｂ、Ｃ中的部分 Hash Slot 数据移到 Ｄ 节点&lt;/li&gt;
  &lt;li&gt;删除 Ａ 节点：需要把 Ａ 节点的 Hash Slot 的数据移到 Ｂ 和 Ｃ 节点；当 Ａ 节点的数据全部被移走后，Ａ 节点就可以完全从集群中删除&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Slot 在不同节点之间的迁移不需要暂停服务&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过 Hash Tag 的概念，Redis Cluster 可以通过一个命令（或事务, 或 lua 脚本）同时操作多个 key。&lt;/p&gt;

&lt;p&gt;Hash Tag 可以使得&lt;strong&gt;相同 Tag 的不同 key 被分配到同一个 Slot&lt;/strong&gt; 。如：key_1 = “this{foo}”, key_2 = “another{foo}”，这两个 key 的 tag 均为 foo，会被分配到同一个 Slot 中，所以可以在一个命令中操作它们。&lt;/p&gt;

&lt;h2 id=&quot;4-master-replica-model&quot;&gt;4-Master-Replica Model&lt;/h2&gt;

&lt;p&gt;为了提高 Cluster 的可用性，保证在部分节点故障或网络不通时 Cluster 依然能正常工作，Redis Cluster 使用了主从模型：&lt;strong&gt;&lt;em&gt;每个 Hash Slot 有 1（主节点）到 N 个副本（ N-1 个从节点&lt;/em&gt;&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;在上面的例子中，A, B, C 设为主节点，A1, B1, C1 分别为其从节点。如果 B 不可用，则会将 B1 提升为主节点，从而保证集群能够继续提供服务；但是如果 B1 同时也不可用了，则集群就不能继续工作了。&lt;/p&gt;

&lt;h2 id=&quot;5-consistency-guarantees&quot;&gt;5-Consistency Guarantees&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Redis Cluster 不能保证强一致性&lt;/strong&gt;：一些已经向 Client 确认写成功的操作，会在某些不确定的情况下丢失。&lt;/p&gt;

&lt;p&gt;无法保证强一致性的原因有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;主从节点之间使用了异步的方式来同步数据&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;网络分区期间可能导致的写操作数据丢失&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当 Client 向主节点 B 节点提交一个写操作后，主节点 B 将数据保存在本地并回复给 Client 操作成功 ，之后 B 异步地将刚才写操作的变更复制到从节点  B1, B2, B3。&lt;/p&gt;

&lt;p&gt;由于是异步复制，所以在 B 响应 Client 之后，并且同步给从节点之前，主节点 Ｂ 故障了，其中一个没有收到该写操作的从节点会晋升成主节点，该写操作就这样永远丢失了。&lt;/p&gt;

&lt;p&gt;为了提高一致性，可以考虑使用同步复制，不过会使得性能降低。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;在性能和一致性之间，需要一个权衡&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Redis Cluster 支持同步复制，通过 WAIT 命令实现，可以让数据丢失的概率降低。但是&lt;strong&gt;&lt;em&gt;即使使用了同步复制，Redis Cluster 仍不是强一致性的&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;考虑一种网络分区的情况：集群中存在主节点 A, B, C，从节点 A1, B1, C1，客户端 Z1，其中 Z1 与 B 可以网络互通，A, A1, B1, C, C1 之间网络互通，但是与 Z1, B 网络不通（一共两个网络分区）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Z1 可以继续向 B 发起写操作，Ｂ 也接受 Z1 的写操作&lt;/li&gt;
  &lt;li&gt;当网络恢复时，如果这个时间间隔足够短，集群仍然能继续正常工作&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果时间比较长，以至于 &lt;strong&gt;&lt;em&gt;B1 在大多数的这边被重新选为主节点&lt;/em&gt;&lt;/strong&gt;，那么刚才 Z1 发给 Ｂ 的写操作都将丢失&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Z1 给 Ｂ 发送写操作是有一个限制的，如果时间长度达到了大多数节点那边可以选出一个新的主节点时，少数这边的所有主节点都不接受写操作&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如何评断网络分区的时间是长还是短？&lt;/p&gt;

&lt;p&gt;Redis Cluster 中存在一个&lt;strong&gt;节点超时配置&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当达到了这个节点超时的时间之后，主节点被认为已经宕机，可以用它的一个从节点来代替&lt;/li&gt;
  &lt;li&gt;同样，在节点超时时，如果主节点依然不能联系到其他主节点，它将&lt;em&gt;进入错误状态，不再接受写操作&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-appendix&quot;&gt;6-Appendix&lt;/h2&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;https://redis.io/topics/cluster-tutorial#:~:text=Redis%20Cluster%20provides%20a%20way,are%20not%20able%20to%20communicate&quot;&gt;redis-io&lt;/a&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">1-Introduction</summary></entry><entry><title type="html">定语从句</title><link href="http://localhost:4000/attributive-clause.html" rel="alternate" type="text/html" title="定语从句" /><published>2022-02-11T00:00:00+08:00</published><updated>2022-02-11T00:00:00+08:00</updated><id>http://localhost:4000/attributive-clause</id><content type="html" xml:base="http://localhost:4000/attributive-clause.html">&lt;h2 id=&quot;1-基本概念&quot;&gt;1-基本概念&lt;/h2&gt;

&lt;h3 id=&quot;1-1-定义&quot;&gt;1-1 定义&lt;/h3&gt;

&lt;p&gt;一个简单句跟在&lt;em&gt;名词或代词（先行词）后进行修饰限定&lt;/em&gt;，就叫做定语从句；定语从句在主句中充当定语成分。&lt;/p&gt;

&lt;p&gt;被定语从句修饰的词叫&lt;strong&gt;先行词&lt;/strong&gt;；定语从句通常只能放在被修饰的先行词之后。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;单词做定语放在被修饰词之前&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;1-2-引导词&quot;&gt;1-2 引导词&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;引导定语从句的词有：
    &lt;ul&gt;
      &lt;li&gt;关系代词：&lt;strong&gt;that, who, whom, which, as&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;关系副词：&lt;strong&gt;when, where, why&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;引导词位于定语从句之前，先行词之后（as 除外）。&lt;/li&gt;
  &lt;li&gt;引导词的作用有：
    &lt;ul&gt;
      &lt;li&gt;连接先行词和定语从句&lt;/li&gt;
      &lt;li&gt;在定语从句中充当一定的成分（&lt;strong&gt;&lt;em&gt;关系代词充当主语或宾语，关系副词充当状语&lt;/em&gt;&lt;/strong&gt;）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-关系代词的用法&quot;&gt;2-关系代词的用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;who/that&lt;/strong&gt; 指人，是主格；&lt;strong&gt;在定语从句中代替先行词，又作定语从句的主语，不能省略&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Do you know the gentleman who/that is sitting there？&lt;/li&gt;
      &lt;li&gt;The student who/that answered the question was John.&lt;/li&gt;
      &lt;li&gt;Nothing is difficult to the man who/that will try.&lt;/li&gt;
      &lt;li&gt;The windows was broken by the boy who/that lives opposite.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;whom/who/that&lt;/strong&gt; 指人，是宾格；&lt;strong&gt;在定语从句中代替先行词，又作定语从句的宾语(动宾或介宾)&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;当作&lt;strong&gt;动宾&lt;/strong&gt;（动词后接宾语）时，关系代词可省略
        &lt;ul&gt;
          &lt;li&gt;Do you know the gentleman (whom/who/that) we met just now？&lt;/li&gt;
          &lt;li&gt;The author (whom/who/that) you criticized.&lt;/li&gt;
          &lt;li&gt;Then I telephoned the doctor (whom/who/that) Charles had recommended.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;当作&lt;strong&gt;介宾&lt;/strong&gt;（介词后接宾语）时：&lt;em&gt;介词不提前，关系代词可省略；介词提前，关系代词不可省&lt;/em&gt;，即 “介词+whom” (指人时介词后的关系代词只能用whom)
        &lt;ul&gt;
          &lt;li&gt;The man (whom/who/that) I spoke with is my teacher.&lt;/li&gt;
          &lt;li&gt;The man with whom I spoke is my teacher.&lt;/li&gt;
          &lt;li&gt;The man with whom I traveled couldn’t speak English&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;固定的动词短语（动词+介词），如 look for, take care of 等不能把动词与介词拆开，即介词不能提至引导词前。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;She is the right girl (who/whom/that) we are looking for.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;whose&lt;/strong&gt; 是所有格 “…的” 形式；&lt;strong&gt;whose + n. 一起在定语从句中充当主语、宾语(&lt;/strong&gt;动宾或介宾)，即先行词的什么东西。&lt;/p&gt;

    &lt;p&gt;whose 用来指人或物（只用作定语) ，且 whose 不能省略。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;em&gt;whose + n. = the + n. + of which/whom&lt;/em&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;I didn’t find the desk whose leg was broken. (主语)&lt;/li&gt;
      &lt;li&gt;He is the student whose pencil I broke yesterday. (动宾)&lt;/li&gt;
      &lt;li&gt;The boss in whose company I work is very kind. (介宾)&lt;/li&gt;
      &lt;li&gt;They rushed over to help the man whose car had broken down. (主语)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;which/that&lt;/strong&gt; 指物，&lt;strong&gt;代替先行词，且在定语从句中作主语或宾语(动宾或介宾)&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;作主语
        &lt;ul&gt;
          &lt;li&gt;The house which/that was destroyed in the earthquake is weak.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;作宾语&lt;/p&gt;

        &lt;p&gt;which/that 作宾语时，同样分为动宾与介宾两种情况：1. 作动宾时，which/that 可以省略；2. 作介宾时，介词不提前时，关系代词 which/that 可以省略；介词提前时，关系代词 which/that 不可以省略。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;The pen (which/that) you found yesterday is mine.&lt;/li&gt;
          &lt;li&gt;The games (that/which) the young men competed in were difficult.&lt;/li&gt;
          &lt;li&gt;The games in which the young men competed were difficult.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;介词 + which 指物；介词 + whom 指人&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;as&lt;/strong&gt; 指人或物，在定语从句中可作主语，宾语，表语或状语，不能省略&lt;/p&gt;

    &lt;p&gt;主要用于 “&lt;strong&gt;the same …as…；such …as…；so …as…；as … as…；as follows&lt;/strong&gt; ” 固定结构中。在这种形式的结构中，要用 as 代替 who(m), which, 或 that 引导定语从句。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Such people as knew Hill thought he was honest.&lt;/li&gt;
      &lt;li&gt;Such people as Hill knew thought he was honest.&lt;/li&gt;
      &lt;li&gt;My hometown is no longer the same as it was.&lt;/li&gt;
      &lt;li&gt;Here is so big a stone as no one can lift.&lt;/li&gt;
      &lt;li&gt;The child knows as much as grow-ups (know).&lt;/li&gt;
      &lt;li&gt;I’d like to have the same books as are used in your school.&lt;/li&gt;
      &lt;li&gt;He is not such a person as I expected.&lt;/li&gt;
      &lt;li&gt;He will marry as pretty a girl as he can find.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-关系副词的用法&quot;&gt;3-关系副词的用法&lt;/h2&gt;

&lt;p&gt;关系副词，兼有副词与连接词两种作用，在&lt;strong&gt;不及物动词的连接中要求用关系副词&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;关系副词在句中作状语，关系副词=介词+关系代词，定语从句中常用的关系副词有三个：&lt;strong&gt;when，where，why&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;when = during/on/in which  where = in/at/on which  why = for which&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;when&lt;/strong&gt; 主要用于修饰表时间的名词，同时它在定语从句中用作&lt;strong&gt;时间状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;There comes a time when you have to make a choice.&lt;/li&gt;
      &lt;li&gt;Gone are the days when they could do what they liked.&lt;/li&gt;
      &lt;li&gt;We’ll put off the picnic until next week, when the weather may be better.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;先行词为时间名词时不一定用关系副词 when 来引导定语从句；需要进一步判断先行词在定语从句中成分。如果在定语从句中作时间状语，则用 when；如果在定语从句中作主语或者宾语时，要用 that, which 等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Don’t forget the time (that, which) I’ve told you.（先行词 time 作 told 的宾语）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;where&lt;/strong&gt; 主要用于修饰表地点的名词，同时它在定语从句中用作&lt;strong&gt;地点状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;This is the village where he was born.&lt;/li&gt;
      &lt;li&gt;That’s the hotel where we were staying last summer.&lt;/li&gt;
      &lt;li&gt;Barbary was working in Aubury, where she went daily in a bus.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;同样，先行词为地点的名词时，不一定要用 where 引导，需要进一步判断先行词在定语从句中的成分。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He works in a factory that/which makes TV sets.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;why&lt;/strong&gt; 主要用于修饰表原因的名词(主要是the reason)，同时它在定语从句中用作&lt;strong&gt;原因状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;We don’t know the reason why he didn’t show up.&lt;/li&gt;
      &lt;li&gt;She didn’t tell me the reason why she refused the offer.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;why 与 where/when 的用法有点不同：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;why 可以省略或者替换成 that&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;That’s one of the reasons (why, that) I asked you to come.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;why 只能引导限制性定语从句，where/when 可以引导非限制性定语从句
        &lt;ul&gt;
          &lt;li&gt;The main reason, why he lost his job, was that he drank. (wrong)&lt;/li&gt;
          &lt;li&gt;The main reason why he lost his job was that he drank. (right)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-限制性与非限制性定语从句的区别&quot;&gt;4-限制性与非限制性定语从句的区别&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在句中作用不同
    &lt;ul&gt;
      &lt;li&gt;限制性定语从句&lt;strong&gt;对&lt;/strong&gt;被修饰的&lt;strong&gt;先行词有限定制约作用&lt;/strong&gt;，使该词的含义更具体,更明确。&lt;strong&gt;限制性定语从句不能被省略&lt;/strong&gt;，否则句意就不完整。&lt;/li&gt;
      &lt;li&gt;非限制性定语从句&lt;strong&gt;与先行词关系不是十分密切&lt;/strong&gt;，只是对其作一些附加说明，不起限定制约作用。如果将非限制性定语从句省去，主句的意义仍然完整。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表现形式不同&lt;/p&gt;

    &lt;p&gt;限制性定语从句因与先行词关系密切，所以&lt;strong&gt;不可以用逗号将其与主句隔开&lt;/strong&gt;；非限制性定语从句与先行词关系不是十分密切，所以&lt;strong&gt;可用逗号将其与主句隔开。&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Do you remember the girl who taught us English?&lt;/li&gt;
      &lt;li&gt;Clock is a kind of instrument which can tell people time.&lt;/li&gt;
      &lt;li&gt;This is the place where he used to live.&lt;/li&gt;
      &lt;li&gt;Mr. Zhang, who came to see me yesterday, is an old friend of mine.&lt;/li&gt;
      &lt;li&gt;We walked down the village street, where they were having market day.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;前三个例句中，定语从句与先行词关系密切，为限制性定语从句，不可用逗号隔开；后面两个例句中，定语从句与先行词关系不密切，为非限制性定语从句。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先行词内容有所不同&lt;/p&gt;

    &lt;p&gt;大多数限制性和非限制性定语从句的先行词往往为某一个词或短语，而特殊情况下&lt;strong&gt;&lt;em&gt;非限制性定语从句的先行词也可为整个主句,此时非限制性定语从句常由 which 引导&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;A middle-aged woman killed her husband&lt;/em&gt;, &lt;strong&gt;which&lt;/strong&gt; frightened me very much.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;A five-year-old boy can speak two foreign languages&lt;/em&gt;, &lt;strong&gt;which&lt;/strong&gt; surprises all the people present.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用的关系词有所不同
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;that 不可以引导非限制性定语从句&lt;/p&gt;

        &lt;p&gt;所有关系代词和关系副词都可以引导限制性定语从句，大部分关系代词与关系副词都可以引导非限制性定语从句，但是 that 除外。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;He gave his mother a color TV set for her birthday, that pleased her a lot.（wrong）&lt;/li&gt;
          &lt;li&gt;He gave his mother a color TV set for her birthday, &lt;strong&gt;&lt;em&gt;which&lt;/em&gt;&lt;/strong&gt; pleased her a lot.（wright）&lt;/li&gt;
          &lt;li&gt;He didn’t pass the exam, that disappointed me.（wrong）&lt;/li&gt;
          &lt;li&gt;He didn’t pass the exam, &lt;strong&gt;&lt;em&gt;which&lt;/em&gt;&lt;/strong&gt; disappointed me.（wright）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关系词替代情况不同&lt;/p&gt;

        &lt;p&gt;关系代词 whom 在限制性定语从句中作宾语时可用 who 代替 whom ,但 whom 在非限制性定语从句中作宾语时不可用 who 来代替。&lt;/p&gt;

        &lt;p&gt;在限制性定语从句中,先行词指人时可用 that 代替 who/whom ,但在非限制性定语从句中先行词指人时, 不可用 that 代替 who/whom。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关系代词省略情况不同&lt;/p&gt;

        &lt;p&gt;关系代词在&lt;strong&gt;&lt;em&gt;限制性定语从句中作宾语时可以省去&lt;/em&gt;&lt;/strong&gt;,非限制性定语从句的所有关系词均不可省。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;This is the book (&lt;em&gt;which/that&lt;/em&gt;) he lost yesterday.&lt;/li&gt;
          &lt;li&gt;The book, &lt;em&gt;which&lt;/em&gt; he lost yesterday, has been found.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-wich-与-that&quot;&gt;5-wich 与 that&lt;/h2&gt;

&lt;h3 id=&quot;5-1-定语从句中只用-that-不用-which&quot;&gt;5-1 定语从句中只用 that, 不用 which&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;先行词是 &lt;strong&gt;everything, anything, nothing&lt;/strong&gt; (something 除外), &lt;strong&gt;all, none, few, little, some&lt;/strong&gt; 等不定代词时，或当先行词被 &lt;strong&gt;every, any, all, some, no, little, few, much 等词修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Have you set down everything that Mr. Li said?&lt;/li&gt;
      &lt;li&gt;There seems to be nothing that is impossible to him in the world.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;当先行词指人时，偶尔也可用关系代词 who。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Any man that/who has a sense of responsibility won’t do such a thing.&lt;/li&gt;
      &lt;li&gt;All the guests that/who were invited to her wedding were important people.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被序数词修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;The first American movie that I watched was the Titanic.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被形容词最高级修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;This is the best museum that I have visited all my life.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被 the very, the only, the first/last 等修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;She is the only person that understands me.&lt;/li&gt;
      &lt;li&gt;After the big fire, the old car is the only thing that he owns.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;前面有 who, which 等疑问代词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Who is the man that is standing in front of the crowd?&lt;/li&gt;
      &lt;li&gt;Which is the room that Mr. Wang lives in?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词为人与动物或人与物
    &lt;ul&gt;
      &lt;li&gt;Look at the man and his donkey that are walking alone the street.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词是 reason, way 等词时，关系代词常用 that 代替 in which, for which, why，也常可省略
    &lt;ul&gt;
      &lt;li&gt;She admired the way (that) they solved the questions.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5-2-定语从句中只用-which-不用-that&quot;&gt;5-2 定语从句中只用 which, 不用 that&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在非限定性定语从句中，在任何情况下都不能用 that
    &lt;ul&gt;
      &lt;li&gt;This brunch of carnation, which is wound by silk ribbon, is the first gift to my mom.&lt;/li&gt;
      &lt;li&gt;These books, which you can get at any corner of the town, will give you all the information.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;关系代词前面有介词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Those days in which you could travel without a passport has gone.&lt;/li&gt;
      &lt;li&gt;That is the motel at which we stayed several years ago.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词本身为 that (指代作用)
    &lt;ul&gt;
      &lt;li&gt;what about that which had appeared in recent activities.&lt;/li&gt;
      &lt;li&gt;The knowledge are from various fields and that which display the waves of human being.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-基本概念</summary></entry><entry><title type="html">表语从句</title><link href="http://localhost:4000/predicative-clause.html" rel="alternate" type="text/html" title="表语从句" /><published>2022-02-09T00:00:00+08:00</published><updated>2022-02-09T00:00:00+08:00</updated><id>http://localhost:4000/predicative-clause</id><content type="html" xml:base="http://localhost:4000/predicative-clause.html">&lt;h2 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h2&gt;

&lt;p&gt;表语从句放在连系动词之后，充当复合句中的表语。&lt;/p&gt;

&lt;p&gt;表语从句( Predicative Clause )就是指一个&lt;strong&gt;句子作为表语，说明主语是什么或者怎么样&lt;/strong&gt;，由名词、形容词或相当于名词或形容词的词或短语充当，和&lt;strong&gt;连系动词一起构成谓语&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;2-构成&quot;&gt;2-构成&lt;/h2&gt;

&lt;p&gt;主语+连系动词+句子作表语(表语从句)&lt;/p&gt;

&lt;h2 id=&quot;3-引导表语从句的关联词&quot;&gt;3-引导表语从句的关联词&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;引导表语从句的&lt;strong&gt;连系动词&lt;/strong&gt;有：&lt;strong&gt;be，look，seem，sound，appea&lt;/strong&gt;r 等
    &lt;ul&gt;
      &lt;li&gt;China is no longer what she used to be.&lt;/li&gt;
      &lt;li&gt;The question remains whether they will be able to help us.&lt;/li&gt;
      &lt;li&gt;At that time，it seemed as if I couldn’t think of the right word.&lt;/li&gt;
      &lt;li&gt;It seems to me that we should answer for this. (在我看来…)&lt;/li&gt;
      &lt;li&gt;It appears to her that he wants to teach us all he has. (在她看来…)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;从属连词 whether，as，as if / though&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;He looked just as he had looked ten years before.&lt;/li&gt;
      &lt;li&gt;It sounds as if someone is knocking at the door.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;从属连词 that&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;The trouble is that I have lost his address.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;because，why&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;That’s because he didn’t understand me.（强调原因；那是因为…）&lt;/li&gt;
      &lt;li&gt;That’s why he got angry with me.（强调结果；那是为什么…）&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;what 引导的主语从句&lt;strong&gt;表示结果&lt;/strong&gt;或&lt;strong&gt;名词 reason 作主语&lt;/strong&gt;时，后面的表语从句表示原因时要用 that 引导，不宜用 because.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The reason why I was sad was &lt;strong&gt;that&lt;/strong&gt; he didn’t understand me.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;连接代词/连接副词&lt;/strong&gt;引导表语从句&lt;/p&gt;

    &lt;p&gt;连接代词有 : &lt;strong&gt;who，whom，whose，what，which，whoever，whatever，whichever&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The problem is who we can get to replace her.&lt;/li&gt;
      &lt;li&gt;That was what she did this morning on reaching the attic.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;连接副词有：&lt;strong&gt;where，when，how，why&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The question is how he did it.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用虚拟语气的表语从句&lt;/p&gt;

    &lt;p&gt;在&lt;strong&gt;表示建议、劝告、命令含义的名词后的表语从句，谓语动词需用 “should+动词原形” 表示&lt;/strong&gt;(should 可省略)。&lt;/p&gt;

    &lt;p&gt;常见的词有：&lt;strong&gt;advice，suggestion，order，proposal，plan，idea&lt;/strong&gt; 等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;My suggestion is that we (should) start early tomorrow.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-总结&quot;&gt;4-总结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;连系动词 be，appear，seem，look等之后可以跟表语从句&lt;/li&gt;
  &lt;li&gt;引导表语从句的引导词分为：
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;wh-疑问词&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;My question is who left.&lt;/li&gt;
          &lt;li&gt;What I wonder is when he left.&lt;/li&gt;
          &lt;li&gt;That’s what he wants.&lt;/li&gt;
          &lt;li&gt;This is where they once lived.&lt;/li&gt;
          &lt;li&gt;That is why he didn’t come here.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;whether&lt;/strong&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;if 不能引导表语从句&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;ul&gt;
          &lt;li&gt;My question is whether he left (or not).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;that&lt;/strong&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;that 有时可省略&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;ul&gt;
          &lt;li&gt;The fact is that he left.&lt;/li&gt;
          &lt;li&gt;The truth is（that）I didn’t go there.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;because，as，as if，as though&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;It’s just because he doesn’t know her.&lt;/li&gt;
          &lt;li&gt;Things are not always as they seem to be.&lt;/li&gt;
          &lt;li&gt;He looks as if he’s tired.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-介绍</summary></entry><entry><title type="html">宾语从句</title><link href="http://localhost:4000/object-clause.html" rel="alternate" type="text/html" title="宾语从句" /><published>2022-02-08T00:00:00+08:00</published><updated>2022-02-08T00:00:00+08:00</updated><id>http://localhost:4000/object-clause</id><content type="html" xml:base="http://localhost:4000/object-clause.html">&lt;h2 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h2&gt;

&lt;p&gt;定义：&lt;strong&gt;置于动词、介词等词性后面，在句子中起宾语作用的从句叫做宾语从句。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;宾语从句分为三类：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;动词的宾语从句&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;介词的宾语从句&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;形容词的宾语从句&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;宾语从句语法需要关注三点：时态，语序，连词。&lt;/strong&gt;宾语从句的语序必须是陈述语序，谓语动词、介词、动词不定式，v.-ing形式后面都能带宾语从句，有些形容词(afraid，sure，glad等)之后也可以带宾语从句。&lt;/p&gt;

&lt;h2 id=&quot;2-连接词&quot;&gt;2-连接词&lt;/h2&gt;

&lt;p&gt;在复合句中作主句的宾语，连接词有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;连词：that (that 常可省略), whether, if&lt;/li&gt;
  &lt;li&gt;代词：who, whose, what, which&lt;/li&gt;
  &lt;li&gt;副词：when ,where, how, why 等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-1-that-引导的宾语从句&quot;&gt;2-1 that 引导的宾语从句&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;在非正式场合that可以省略&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;可跟 that 从句做宾语的动词有：&lt;strong&gt;say, think, insist, wish, hope, demand, imagine, wonder, know, suppose, see, believe, agree, admit, deny, expect, explain, order, command, feel, dream, suggest, hear, mean, notice, prefer, request, require, propose, declare, report&lt;/strong&gt; 等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The boy believes that he will travel through space to other planets.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，&lt;strong&gt;当主句谓语动词是 think, believe, suppose, expect 等词，而宾语从句的意思是否定时，常把否定转移至主句表示。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I don’t think it is right for him to treat you like that.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在以下情况中 that 不能省略&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当句中的动词后接&lt;em&gt;多于两个由 that 引导的宾语从句&lt;/em&gt;时，第一个 that 可省，但后面的 that 不可省。
    &lt;ul&gt;
      &lt;li&gt;He said (that) you were too young to understand the matter and that he was asked not to tell you.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当&lt;em&gt;主句的谓语动词与 that 宾语从句之间有插入语&lt;/em&gt;时，that 一般不可省。
    &lt;ul&gt;
      &lt;li&gt;Just then I noticed, for the first time, that our master was wearing his fine green coat and his black silk cap.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当 &lt;em&gt;that 从句是双宾语中的直接宾语&lt;/em&gt;时，that 不可省。
    &lt;ul&gt;
      &lt;li&gt;I can’t tell him that his mother died.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;许多带复合宾语的句子，&lt;em&gt;that 引导的宾语从句经常移到句子后部，而用 it 作形式宾语&lt;/em&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I find it necessary that we should do the homework on time.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-2-whetherif-引导的宾语从句&quot;&gt;2-2 whether/if 引导的宾语从句&lt;/h3&gt;

&lt;p&gt;由 whether/if 引导的宾语从句，实际上是&lt;em&gt;一般疑问句演变而来的，&lt;/em&gt;意思是“是否”，此时&lt;strong&gt;宾语从句要用陈述句语序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一般说来，在宾语从句中 whether 与 if 可以互换使用，但在特殊情况下 if 与 whether 是不能互换的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I wonder whether(if) they will come to our party.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下场景不能互换：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;只能用 whether，不能用 if 引导的宾语从句&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;在带 to 的不定式前
        &lt;ul&gt;
          &lt;li&gt;We decided whether to walk there.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在介词的后面
        &lt;ul&gt;
          &lt;li&gt;I’m thinking of whether we should go to see the film.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在 discuss, decided 等动词后面的宾语从句
        &lt;ul&gt;
          &lt;li&gt;We discussed whether we had a sports meeting next week.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;直接与 or not 连用时
        &lt;ul&gt;
          &lt;li&gt;I can’t say whether or not they can come on time.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;只能用 if 不能用 whether 引导的宾语从句&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;if 引导条件状语从句，意为“如果”
        &lt;ul&gt;
          &lt;li&gt;The students will go on a picnic if it is sunny.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;if 引导否定概念的宾语从句时
        &lt;ul&gt;
          &lt;li&gt;He asked if I didn’t come to school yesterday.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;引导状语从句 even if(即使)和 as if(好象)时
        &lt;ul&gt;
          &lt;li&gt;He talks as if he has known all about it.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-连接代词和连接副词引导的宾语从句&quot;&gt;2-3 连接代词和连接副词引导的宾语从句&lt;/h3&gt;

&lt;p&gt;这样的宾语从句实际上是由&lt;em&gt;特殊疑问句变化而来的&lt;/em&gt;，&lt;strong&gt;宾语从句要用陈述句语序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;用于这种结构的动词常常是：&lt;strong&gt;see, say, tell, ask, answer, know, decide, show, find out, imagine, suggest, doubt, wonder, discover, understand, inform, advise&lt;/strong&gt; 等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;连接代词有：who, whom, whose, which, what，在&lt;strong&gt;句中担任主语、宾语、定语或者表语&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;Can you tell me whom you are waiting for?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接副词有：when,where,why,how，在&lt;strong&gt;句中担任状语的成分&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;None of us knows where these new parts can be bought.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-语序&quot;&gt;3-语序&lt;/h2&gt;

&lt;p&gt;无论主句是陈述句还是疑问句，&lt;strong&gt;宾语从句都必须使用陈述语序&lt;/strong&gt;，即“主句+连接词+宾语从句(主语+谓语+……)”句式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Could you tell me who knows the answer?&lt;/li&gt;
  &lt;li&gt;The small children don’t know what is in their stockings.&lt;/li&gt;
  &lt;li&gt;He asked whose handwriting was the best in our class.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-时态&quot;&gt;4-时态&lt;/h2&gt;

&lt;p&gt;含宾语从句的复合句，主句、从句谓语动词的时态呼应，包括以下几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;主句的谓语动词是一般现在时，从句的谓语动词可根据需要，选用相应的&lt;strong&gt;任何时态&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;I don’t know when he will come back.&lt;/li&gt;
      &lt;li&gt;He tells me that his sister came back yesterday.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;主句的谓语动词是过去时，宾语从句的谓语动词只可根据需要，选用过去时态即&lt;strong&gt;一般过去时、过去进行时、过去将来时或过去完成时的某一种形式&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;The children didn’t know who he was.&lt;/li&gt;
      &lt;li&gt;He asked his father how it happened.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果宾语从句所表示的是&lt;em&gt;客观事实、普遍真理、自然现象或习惯性动作&lt;/em&gt;等，不管主句用什么时态，&lt;em&gt;从句时态都用一般现在时&lt;/em&gt;。
    &lt;ul&gt;
      &lt;li&gt;The teacher said that the earth goes round the sun.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-总结&quot;&gt;5-总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;宾语从句可以作及物动词、介词及形容词的宾语。&lt;/li&gt;
  &lt;li&gt;宾语从句的语序一律用陈述句语序。&lt;/li&gt;
  &lt;li&gt;连接词 that 引导宾语从句在句中无词义，不充当句子成份，多数情况下可以省略。&lt;/li&gt;
  &lt;li&gt;whether 和 if 都可引导宾语从句，但 whether 后可紧跟 or not；whether 从句可作介词的宾语。&lt;/li&gt;
  &lt;li&gt;如果从句太长，可以用形式宾语it。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-介绍</summary></entry><entry><title type="html">such &amp;amp; so</title><link href="http://localhost:4000/such-and-so.html" rel="alternate" type="text/html" title="such &amp;amp; so" /><published>2022-01-20T00:00:00+08:00</published><updated>2022-01-20T00:00:00+08:00</updated><id>http://localhost:4000/such-and-so</id><content type="html" xml:base="http://localhost:4000/such-and-so.html">&lt;p&gt;such 和 so 都可以&lt;strong&gt;表示程度&lt;/strong&gt;，含有“如此、这/那样、这/那么”的意思，但它们在用法上有一定区别。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;such 为形容词，一般&lt;strong&gt;修饰名词&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;so 为副词，一般&lt;strong&gt;修饰形容词或副词&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;such-用法&quot;&gt;such 用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;such + a/an + 可数名词单数
    &lt;ul&gt;
      &lt;li&gt;All of us have never seen &lt;strong&gt;&lt;em&gt;such an animal before&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
      &lt;li&gt;He said he would rather be poor than get money &lt;strong&gt;&lt;em&gt;in such a way&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + a/an + 形容词 + 可数名词单数
    &lt;ul&gt;
      &lt;li&gt;She is &lt;strong&gt;&lt;em&gt;such a good teacher&lt;/em&gt;&lt;/strong&gt; just as we expect.&lt;/li&gt;
      &lt;li&gt;I really thank you for giving &lt;strong&gt;&lt;em&gt;such an exciting party&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 可数名词复数
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Such things&lt;/em&gt;&lt;/strong&gt; often happen in our daily life.&lt;/li&gt;
      &lt;li&gt;I don’t think &lt;strong&gt;&lt;em&gt;such people&lt;/em&gt;&lt;/strong&gt; are dangerous.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 形容词 + 可数名词复数
    &lt;ul&gt;
      &lt;li&gt;He told us &lt;strong&gt;&lt;em&gt;such funny stories&lt;/em&gt;&lt;/strong&gt; that we all couldn’t help laughing.&lt;/li&gt;
      &lt;li&gt;He’s amazed to see &lt;strong&gt;&lt;em&gt;such beautiful fishes&lt;/em&gt;&lt;/strong&gt; under the sea.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 不可数名词
    &lt;ul&gt;
      &lt;li&gt;When he knew &lt;strong&gt;&lt;em&gt;such news&lt;/em&gt;&lt;/strong&gt;, he began to cry.&lt;/li&gt;
      &lt;li&gt;It’s dangerous to go swimming in &lt;strong&gt;&lt;em&gt;such weather&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 形容词 + 不可数名词
    &lt;ul&gt;
      &lt;li&gt;We are glad to see that he has made &lt;strong&gt;&lt;em&gt;such rapid progress&lt;/em&gt;&lt;/strong&gt; in English this term.&lt;/li&gt;
      &lt;li&gt;I’ll remember &lt;strong&gt;&lt;em&gt;such delicious food&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;so-用法&quot;&gt;so 用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;so + 形容词/副词
    &lt;ul&gt;
      &lt;li&gt;It’s &lt;strong&gt;&lt;em&gt;so cold&lt;/em&gt;&lt;/strong&gt; outside. We’d better wear warm clothes.&lt;/li&gt;
      &lt;li&gt;He spoke &lt;strong&gt;&lt;em&gt;so fast&lt;/em&gt;&lt;/strong&gt; that I couldn’t follow.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;so + 形容词 + a/an + 可数名词单数
    &lt;ul&gt;
      &lt;li&gt;He’s &lt;strong&gt;&lt;em&gt;so kind a man&lt;/em&gt;&lt;/strong&gt; that everybody here likes him.&lt;/li&gt;
      &lt;li&gt;It’s &lt;strong&gt;&lt;em&gt;so easy an exercise&lt;/em&gt;&lt;/strong&gt; that every one of us can do it.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;这种句式可以和 such + a/an + 形容词 + 可数名词单数换用：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I’ve never seen so amusing a film. = I’ve never seen such an amusing film.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;so + many/much/few/little + 可数名词复数/不可数名词
    &lt;ul&gt;
      &lt;li&gt;There are &lt;strong&gt;&lt;em&gt;so many visitors&lt;/em&gt;&lt;/strong&gt; in our school today.&lt;/li&gt;
      &lt;li&gt;I have eaten &lt;strong&gt;&lt;em&gt;so much food&lt;/em&gt;&lt;/strong&gt;. I don’t want to eat any more.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;so many 已成固定搭配，a lot of 虽相当于 many，但 a lot of 为名词性的，只能用 such 搭配。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I feel very happy that I have such a lot of friends.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">such 和 so 都可以表示程度，含有“如此、这/那样、这/那么”的意思，但它们在用法上有一定区别。</summary></entry><entry><title type="html">过去完成时</title><link href="http://localhost:4000/perfect-past-tense.html" rel="alternate" type="text/html" title="过去完成时" /><published>2022-01-20T00:00:00+08:00</published><updated>2022-01-20T00:00:00+08:00</updated><id>http://localhost:4000/perfect-past-tense</id><content type="html" xml:base="http://localhost:4000/perfect-past-tense.html">&lt;h2 id=&quot;含义与结构&quot;&gt;含义与结构&lt;/h2&gt;

&lt;p&gt;过去完成时表示&lt;strong&gt;&lt;em&gt;过去某一时间或动作&lt;/em&gt;&lt;/strong&gt;以前已经发生或完成了的动作，对过去的某一点造成的某种影响或是结果，用来指&lt;strong&gt;在另一个过去动作之前就已经完成了的事件&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;动作发生的时间是”过去的过去”，侧重事情的结果。&lt;/p&gt;

&lt;p&gt;基本结构为：&lt;strong&gt;主语+had+动词过去分词&lt;/strong&gt;（done）&lt;/p&gt;

&lt;h2 id=&quot;用法&quot;&gt;用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;表示在&lt;strong&gt;过去某一时刻或动作以前完成了的动作&lt;/strong&gt;，表示“过去的过去”；可以用 &lt;strong&gt;by, before&lt;/strong&gt; 等介词短语或一个时间状语从句来表示，也可以用一个表示过去的动作来表示，还可能通过上下文来表示。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;By&lt;/strong&gt; the time I got outside, the bus had already left.&lt;/li&gt;
      &lt;li&gt;She had studied English for six years &lt;strong&gt;before&lt;/strong&gt; she went to college.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示由过去的某一时刻开始，一直&lt;strong&gt;延续到过去另一时间&lt;/strong&gt;的动作或状态，常和 &lt;strong&gt;for, since&lt;/strong&gt; 构成的时间状语连用。
    &lt;ul&gt;
      &lt;li&gt;He had lived in the house &lt;strong&gt;for&lt;/strong&gt; five years.&lt;/li&gt;
      &lt;li&gt;He said he had worked in that factory &lt;strong&gt;since&lt;/strong&gt; 1949.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;叙述过去发生的事情，在已叙述了过去发生的事情后，反过来&lt;strong&gt;追述或补述以前发生的动作&lt;/strong&gt;时，常使用过去完成时。
    &lt;ul&gt;
      &lt;li&gt;Mr. Smith died yesterday. He had been a good friend of mine.&lt;/li&gt;
      &lt;li&gt;I didn’t know a thing about the verbs, for I had not studied my lesson.（因为我没有好好学习，作为补充）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在含有定语从句的&lt;strong&gt;主从复合句&lt;/strong&gt;中，如果&lt;strong&gt;叙述的是过去的事&lt;/strong&gt;，&lt;strong&gt;先发生的动作常用过去完成时&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;I returned the book that I had borrowed.&lt;/li&gt;
      &lt;li&gt;She found the key that she had lost.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;过去完成时常常&lt;strong&gt;用在 told, said, knew, heard, thought 等动词后的宾语从句&lt;/strong&gt;（或间接引语）中，这时从句中的动作发生在主句表示的过去的动作之前。
    &lt;ul&gt;
      &lt;li&gt;He said that he had known her well.&lt;/li&gt;
      &lt;li&gt;I thought I had sent the letter a week before.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;含有时间状语从句，对于过去不同时间发生的两个动作，&lt;strong&gt;发生在前的动作，用过去完成时；发生在后的动作，用一般过去时&lt;/strong&gt;。如 &lt;strong&gt;when, before, after, as soon as, till/until 引导的从句。&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;When&lt;/strong&gt; I woke up, it had already stopped raining.&lt;/li&gt;
      &lt;li&gt;She didn’t go to bed &lt;strong&gt;until&lt;/strong&gt; she had finished her work.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;需要注意的是，如果&lt;strong&gt;两个动作紧接着发生&lt;/strong&gt;，则常常不用过去完成时，特别是在包含 &lt;strong&gt;before&lt;/strong&gt; 和&lt;strong&gt;after&lt;/strong&gt; 的复合句中，因为这时&lt;em&gt;从句的动作和主句的动作发生的先后顺序已经非常明确&lt;/em&gt;，可以用一般过去时代替过去完成时。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;After he arrived in England, Marx worked hard to improve his English.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动词 &lt;strong&gt;think, want, hope, mean, plan, intend 等用过去完成时来表示过去未曾实现&lt;/strong&gt;的想法，希望，打算或意图等。
    &lt;ul&gt;
      &lt;li&gt;They &lt;strong&gt;had wanted&lt;/strong&gt; to help but could not get there in time.&lt;/li&gt;
      &lt;li&gt;We &lt;strong&gt;had hoped&lt;/strong&gt; to be able to come and see you.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;过去完成时还可用在 &lt;strong&gt;hardly…when…, no sooner…than…, It was the first (second, etc) time (that)…&lt;/strong&gt; 等固定句型中。
    &lt;ul&gt;
      &lt;li&gt;Hardly had he begun to speak when the audience interrupted him.（一 … 就 …，倒装句）&lt;/li&gt;
      &lt;li&gt;No sooner had he arrived than he went away again.（一 … 就 …，倒装句）&lt;/li&gt;
      &lt;li&gt;It was the third time that he had been out of work that year.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">含义与结构</summary></entry><entry><title type="html">Dynamo: Amazon’s Highly Available Key-value Store</title><link href="http://localhost:4000/dynamo.html" rel="alternate" type="text/html" title="Dynamo: Amazon’s Highly Available Key-value Store" /><published>2022-01-18T00:00:00+08:00</published><updated>2022-01-18T00:00:00+08:00</updated><id>http://localhost:4000/dynamo</id><content type="html" xml:base="http://localhost:4000/dynamo.html">&lt;h1 id=&quot;1-abstract&quot;&gt;1-Abstract&lt;/h1&gt;

&lt;p&gt;Dynamo 是 Amazon 提出的&lt;strong&gt;高可用键值存储&lt;/strong&gt;系统。为了保证系统的高可用，&lt;em&gt;牺牲了一些特定场景下的一致性&lt;/em&gt;。Dynamo 使用了&lt;strong&gt;对象版本化（object versioning）&lt;/strong&gt;与&lt;strong&gt;应用协助解决冲突（application-assisted conflict resolution）&lt;/strong&gt;的机制。&lt;/p&gt;

&lt;h1 id=&quot;2-introduction&quot;&gt;2-Introduction&lt;/h1&gt;

&lt;p&gt;Amazon 的基础设施由数百万台设备组成，任何时刻都会有比例小但是数量不少的设备发生故障。因此，可以将故障看作是正常的，可预期的行为，&lt;em&gt;软件系统不应该因为硬件设备故障影响自身的可用性与性能&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;Dynamo 的目标是实现一个&lt;strong&gt;永远可用（always available）&lt;/strong&gt;的系统：即使服务器故障或者网络异常，用户也能往自己的购物车里添加商品。基于以下技术保证了高可用性与高扩展性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据通过&lt;strong&gt;一致性 Hash 进行分区与复制&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;通过&lt;strong&gt;对象版本化&lt;/strong&gt;实现一致性（最终一致性）&lt;/li&gt;
  &lt;li&gt;数据副本之间的一致性通过“&lt;strong&gt;类似仲裁的技术&lt;/strong&gt;”与“&lt;strong&gt;去中心化的副本同步协议&lt;/strong&gt;”保证&lt;/li&gt;
  &lt;li&gt;以 gossip 协议为基础的分布式&lt;strong&gt;故障检测与成员检测&lt;/strong&gt;协议&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dynamo 系统通过组合不同的技术实现一个高度可用（high-available）的系统，并证明了最终一致性存储系统可以用于生产环境，满足应用的高可用要求。&lt;/p&gt;

&lt;h1 id=&quot;3-background&quot;&gt;3-Background&lt;/h1&gt;

&lt;p&gt;Amazon 电商平台由几百个服务组成，有些服务是无状态的（如聚合其他服务响应的服务），有些服务是有状态的（如基于存储在数据仓库中的状态，执行业务逻辑并产生响应的服务）。传统上，服务状态使用关系型数据库存储；但是，对很多&lt;strong&gt;持久状态的存储&lt;/strong&gt;需求来说，关系型数据库有一些局限性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;该类型的服务大部分情况下只需要&lt;strong&gt;使用主键检索&lt;/strong&gt;，并不需要关系型数据库提供的复杂查询和管理功能&lt;/li&gt;
  &lt;li&gt;关系型数据库的复制功能受限，而且通常通过&lt;strong&gt;牺牲可用性来换取一致性&lt;/strong&gt;；水平扩展（scale-out）不足&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对关系型数据库的不足，Dynamo 能够做到高度可用，有定义清晰的一致性窗口（clearly defined consistency window），易用的水平扩展方案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dynamo 支持独立部署，不同的业务使用不同的 Dynamo 系统&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-1-system-assumptions-and-requirements&quot;&gt;3-1-&lt;strong&gt;System Assumptions and Requirements&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;对接入 Dynamo 的服务有以下假设：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查询模型（&lt;em&gt;Query Model&lt;/em&gt;）
    &lt;ol&gt;
      &lt;li&gt;通过&lt;em&gt;唯一 key&lt;/em&gt; 进行数据读写操作&lt;/li&gt;
      &lt;li&gt;任何读写操作都&lt;em&gt;不会跨多个数据单元&lt;/em&gt;（data item）&lt;/li&gt;
      &lt;li&gt;没有关系型 schema 需求&lt;/li&gt;
      &lt;li&gt;需要存储的&lt;em&gt;文件较小&lt;/em&gt;（&amp;lt; 1MB）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ACID 特性（&lt;em&gt;ACID Properties&lt;/em&gt;）
    &lt;ol&gt;
      &lt;li&gt;在数据库领域中，ACID 是保证事务可靠执行的保证；但是这些特性会牺牲系统的可用性。Dynamo 实现目标是：&lt;em&gt;允许通过牺牲一些一致性（C）提高可用性&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;Dynamo &lt;em&gt;不提供任何隔离保证&lt;/em&gt;，只允许单个key 的更新操作&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;效率（&lt;em&gt;Efficiency&lt;/em&gt;）
    &lt;ol&gt;
      &lt;li&gt;系统需要满足严格的 SLA（通过 TP999 衡量）；并允许业务自定义配置 Dynamo 以满足吞吐量 &amp;amp; 延迟的需求&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-2-design-considerations&quot;&gt;3-2-&lt;strong&gt;Design Considerations&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;为了达到强一致性，一般数据库会采用同步复制算法&lt;/em&gt;。这类算法在某些故障场景下牺牲了可用性，如当数据出现冲突，则暂时禁止对该数据的访问，直到冲突解决。&lt;/p&gt;

&lt;p&gt;分布式系统是无法同时满足 C（强一致性），A（高可用性），P（网络故障容忍）三个特性；因此，在不同的业务场景下需要选择不同的特性：是强一致性还是高可用性。&lt;/p&gt;

&lt;p&gt;在服务器与网络故障比较高的场景下，可以通过&lt;strong&gt;乐观复制&lt;/strong&gt;（optimistic replication）提高可用性：在后台通过异步同步将数据变更复制到其他节点，能够容忍并发更新与操作异常。不过这种方式虽然能够提高可用性，但是会导致数据冲突，需要检测并修复冲突。那么：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;什么时候解决冲突&lt;/li&gt;
  &lt;li&gt;由谁解决冲突&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dynamo 被设计为&lt;strong&gt;最终一致性数据仓库（eventually consistent data store）&lt;/strong&gt;，所有的数据变更最后都会同步到所有副本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;什么时候解决冲突&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;解决冲突的时机有两个：读时 &amp;amp; 写时。&lt;/p&gt;

    &lt;p&gt;传统数据库在写时解决冲突，可以使得读操作比较简单。这种方式在&lt;em&gt;系统不能访问大部分（或者全部）副本时，就会拒绝写&lt;/em&gt;。&lt;/p&gt;

    &lt;p&gt;Dynamo 期望保证&lt;strong&gt;永远可写&lt;/strong&gt;（always writeable），所以在&lt;em&gt;数据读取时解决冲突&lt;/em&gt;，以保证写操作不会被拒绝。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;谁解决冲突&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;冲突解决方也有两个：业务服务 &amp;amp; 数据库。&lt;/p&gt;

    &lt;p&gt;如果由数据库来解决，只能执行一些简单的策略，如最后写有效（last write wins）。&lt;/p&gt;

    &lt;p&gt;由于业务服务能够更了解数据的作用，可以更加&lt;em&gt;灵活地选择对用户体验最好的冲突解决算法&lt;/em&gt;，如合并冲突的版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他设计原则&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;增量扩展性（Incremental scalability）&lt;/strong&gt;：支持逐个节点扩容，并减小对系统的影响&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;对称性（Symmetry）&lt;/strong&gt;：&lt;em&gt;每个节点的职责应该是相同的&lt;/em&gt;；对称性简化了系统的运维&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;去中心化（Decentralization）&lt;/strong&gt;：去中心化是对称性的进一步扩展；系统应该是去中心化，点对点的，而不是集中控制；&lt;em&gt;去中心化能够使得系统更加简单，更具可扩展性 &amp;amp; 可用性&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;异构性（Heterogeneity）：负载的分布要与节点的承载能力成正比&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;传统复制型关系数据库将关注点都放在保证副本强一致性上；虽然强一致性可以&lt;strong&gt;给应用的写操作提供方便的编程模型&lt;/strong&gt;， 但&lt;em&gt;导致系统的扩展性和可用性非常受限，无法处理网络分裂的情况。&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-system-architecture&quot;&gt;4-System Architecture&lt;/h1&gt;

&lt;p&gt;Dynamo 使用的分布式系统技术有：&lt;strong&gt;分区&lt;/strong&gt;（partition），&lt;strong&gt;复制&lt;/strong&gt;（replication），&lt;strong&gt;版本化&lt;/strong&gt;（versioning），&lt;strong&gt;成员管理&lt;/strong&gt;（membership），&lt;strong&gt;故障处理&lt;/strong&gt;（failure handling），&lt;strong&gt;规模扩展&lt;/strong&gt;（scaling）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo/dynamo_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下表展示了这些技术的优势：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;问题&lt;/th&gt;
      &lt;th&gt;技术&lt;/th&gt;
      &lt;th&gt;优势&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;数据分区&lt;/td&gt;
      &lt;td&gt;一致性 Hash&lt;/td&gt;
      &lt;td&gt;增量可扩展性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;写操作高可用&lt;/td&gt;
      &lt;td&gt;读时协调（冲突解决）的向量时钟&lt;/td&gt;
      &lt;td&gt;版本大小与更新频率解耦&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;短时故障处理&lt;/td&gt;
      &lt;td&gt;宽松的选举和 hinted handoff&lt;/td&gt;
      &lt;td&gt;部分副本不可用时，仍然可以保证高可用性和持久性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;持久故障恢复&lt;/td&gt;
      &lt;td&gt;基于 Merkle tree 的逆熵&lt;/td&gt;
      &lt;td&gt;后台同步版本不一致的副本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;成员管理与故障检测&lt;/td&gt;
      &lt;td&gt;基于 Gossip 协议的成员管理协议和故障检测&lt;/td&gt;
      &lt;td&gt;保持了架构的对称性：无需一个中心组件（centralized registry）来存储成员和节点状态等信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;4-1-system-interface&quot;&gt;4-1 System Interface&lt;/h2&gt;

&lt;p&gt;Dynamo 系统提供两个简单的接口：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;get(key)&lt;/li&gt;
  &lt;li&gt;put(key)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get(key)&lt;/code&gt; 会&lt;em&gt;定位到存储系统中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt; 对应的所有对象副本&lt;/em&gt;，&lt;strong&gt;返回对象（&lt;/strong&gt;可能是单个对象，也可能是一个对象列表: 有冲突情况下，包括了所有版本），&lt;strong&gt;以及一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt;（ 上下文）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put(key)&lt;/code&gt; 确定对象应该存放的位置，然后写到相应的磁盘（put 请求会携带 context 上报）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt; 包含了系统中对象的元数据，例如&lt;strong&gt;对象的版本&lt;/strong&gt;，对调用方是不透明的（ opaque）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上下文信息是和对象存储在一起的，这样系统容易验证 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 请求的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt; 是否合法&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Dynamo 将调用方提供的 key 和对象都视为不透明的字节序列（opaque array of bytes） 。它对 key 应用 MD5 Hash 得到一个 128bit 的 ID，并根据这个 ID 计算应该存储到哪些节点。&lt;/p&gt;

&lt;h2 id=&quot;4-2-partitioning-algorithm&quot;&gt;4-2 &lt;strong&gt;Partitioning Algorithm&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Dynamo 的一个核心需求是：支持数据&lt;strong&gt;增量扩展&lt;/strong&gt;（scale incrementally）。为了实现该目标，需要将数据分散到系统中的不同节点上。Dynamo 采取的方案是&lt;strong&gt;一致性 Hash&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在一致性哈希中，哈希函数的&lt;strong&gt;输出是一个固定的范围，&lt;/strong&gt;通常作为一个&lt;strong&gt;循环空间，或称环（ring）&lt;/strong&gt;。&lt;strong&gt;每个节点都会随机分配一个在这个循环空间内的值&lt;/strong&gt;，这个值代表了节点在这个环上的位置。&lt;/p&gt;

&lt;p&gt;如何确定一条数据对应的存储节点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对 key 进行哈希得到一个哈希值&lt;/li&gt;
  &lt;li&gt;在环上沿着顺时针方向找到第一个&lt;strong&gt;所带的值比这个哈希值更大的节点&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每个节点要负责环上从它自己到它的下一个节点之间的区域。&lt;strong&gt;一致性哈希的主要好处是 ：添加或删除节点只会影响相邻的节点，其他节点不受影响。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不过基础的一致性 Hash 算法有些问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给每个节点分配一个随机位置会导致数据与负载的非均匀分配&lt;/li&gt;
  &lt;li&gt;未考虑节点的异构（不同节点配置不同，对应的性能也不同）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dynamo 使用&lt;strong&gt;虚拟节点&lt;/strong&gt;（virtual node）进行优化：&lt;strong&gt;一个物理节点对应多个虚拟节点，每个虚拟节点分散到环上的不同位置&lt;/strong&gt;，能够有效进行负载的均匀分配。&lt;/p&gt;

&lt;p&gt;引用了虚拟节点之后：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点不可用时，其负载会均匀分散到其他可用节点上&lt;/li&gt;
  &lt;li&gt;新增节点会获得与其他节点大致相同的负载&lt;/li&gt;
  &lt;li&gt;一个物理节点对应的虚拟节点数目可以根据其实际性能来决定，可以充分考虑机器的异构性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-3-replication&quot;&gt;4-3 &lt;strong&gt;Replication&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;为了实现高可用性和持久性，Dynamo 将数据复制到 N 台机器上（N 可配）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个 key &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;，会被分配一个 Coordinator（协调者）&lt;/strong&gt;节点。 Coordinator &lt;strong&gt;负责落到它管理的范围内的数据的复制&lt;/strong&gt;。Coordinator 除了自己存储一份之外，还会在环上顺时针方向的其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N-1&lt;/code&gt; 个节点复制一份副本。因此在系统中，每个节点要负责从它自己往后的一共 N 个节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo/dynamo_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在图中，K 不仅存储在节点 B 中，还存储在节点 C，D 中。由于每个节点会保存其前继节点中的数据，所以节点 D 中包含的 Key 范围为 (A, D]，C 的范围为 (A, C]。&lt;/p&gt;

&lt;p&gt;在 Dynamo 中有一个&lt;strong&gt;优先列表&lt;/strong&gt;（preference list）概念：&lt;em&gt;存储某个特定 key 的所有节点组成一个列表&lt;/em&gt;&lt;strong&gt;。对于给定的 key，每个节点都能决定哪些节点可以进入这个列表&lt;/strong&gt;。为了应对节点失效的情况，preference list 会包含&lt;strong&gt;超过&lt;/strong&gt; N 个节点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;every node in the system can determine which nodes should be in this list for any particular key. To account for node failures, preference list contains more than N nodes.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;由于引入了虚拟节点，存储一个 key 的 N 个节点，实际上对应的物理节点可能少于 N 个（例如，一个节点可能会占用环上的不止一个节点）。为了避免这个问题 ，preference list 在选择节点的时候会跳过一些位置，以&lt;strong&gt;保证 list 里面的节点都在不同的物理节点上&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;4-4-data-versioning&quot;&gt;4-4 &lt;strong&gt;Data Versioning&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Dynamo 提供&lt;strong&gt;最终一致性&lt;/strong&gt;，所有数据变更操作会在后台异步传递给其他副本。&lt;/p&gt;

&lt;p&gt;在这种情况下，当 put(key) 返回时，最新数据可能还没有复制到 preference list 中的所有副本。此时进行 get(key) 操作可能不会获取到最新的数据，那么之后的更新操作会在旧数据上进行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;异步更新在没有故障的情况下会有一个耗时上限，但是如果存在故障（如网络分区），所有副本的更新耗时可能会无限大&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Dynamo 为了保证&lt;strong&gt;始终可写&lt;/strong&gt;的特性，需要容忍这种不一致性，&lt;strong&gt;将不同更新结果都保留，并在之后的步骤中处理更新冲突&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;加入用户向购物车中添加商品 A，之后查询购物车为空并重新添加商品 B，此时 Dynamo 需要将 A，B 两个商品都保留并在之后解决冲突&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-4-1-how-to-fix-conflicts&quot;&gt;4-4-1 How to Fix Conflicts&lt;/h3&gt;

&lt;p&gt;为了实现该目标，&lt;strong&gt;&lt;em&gt;Dynamo 将每次更新结果都作为一个新的，不可变更的版本&lt;/em&gt;&lt;/strong&gt;，则系统中会&lt;strong&gt;同时存在多个不同的版本&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;大部分情况下，新版本都包含旧版本的数据，而且系统自己可以判断哪个是权威版本&lt;/strong&gt; （syntactic reconciliation）；但是，在发生故障并且存在并发更新的场景下，版本会发生&lt;strong&gt;分叉&lt;/strong&gt;（version branching），导致&lt;strong&gt;对象版本冲突&lt;/strong&gt;。系统本身无法处理这种情况，需要&lt;strong&gt;客户端介入&lt;/strong&gt;，将多个分支合并成一个。&lt;/p&gt;

&lt;p&gt;冲突的版本可能会有多个，并且每个版本都有自己的子历史版本，这些版本都需要系统来将其一致化。&lt;/p&gt;

&lt;h3 id=&quot;4-4-2-vector-clock&quot;&gt;4-4-2 Vector Clock&lt;/h3&gt;

&lt;p&gt;Dynamo 使用&lt;strong&gt;向量时钟&lt;/strong&gt;（vector clock）来&lt;strong&gt;跟踪同一对象不同版本之间的因果性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一个向量时钟就是一个 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(node, counter)&lt;/code&gt; 列表&lt;/strong&gt;，如 D [(node-1, 2), [node-2, 3], [node-3, 1]]。&lt;strong&gt;一个向量时钟关联了一个对象的所有版本&lt;/strong&gt;，可以通过其来判断对象的两个版本是否在并行的分支上，或者它们是否有因果关系。如果对象的第一个时钟上的所有 counter 都小于它的第二个时钟上的 counter，那第一个时钟就是第二的祖先，可以安全的删除；否则，这两个修改就是有冲突的，需要解决冲突。&lt;/p&gt;

&lt;p&gt;客户端更新对象时，&lt;strong&gt;必须要先指定基于哪个版本进行更新&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;执行 get(key) 操作获取 context 信息：包含了 vector clock&lt;/li&gt;
  &lt;li&gt;基于指定的版本进行更新：携带 context&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Dynamo 在收到客户端的读请求后，如果能够获取到多个版本，并且无法解决这些版本之间的冲突，那么 Dynamo 会返回所有的版本，并在 context 中携带各个版本对应的 vector clock 信息。&lt;strong&gt;客户端在收到多个版本之后，解决冲突，并基于指定版本更新，将多个分支重新合并为一个新分支&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo/dynamo_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图展示了 vector clock 的用法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端 A 创建一个新的对象，并且该 put 请求被节点 Sx 处理。Sx 增加该对象的序列号 1，并使用该序列号创建该对象的 vector clock。系统中此时存在对象 D1 及对应的 clock: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx, 1)]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;客户端 A 更新该对象，假设更新请求被同一个节点 Sx 处理，那么系统中新增另一个对象 D2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx, 2)]&lt;/code&gt;。由于 D2 继承自 D1，因此可以覆盖 D1。&lt;em&gt;Dynamo 异步复制数据，所以可能存在节点包含了 D1，但是并没有 D2&lt;/em&gt;。&lt;/li&gt;
  &lt;li&gt;客户端 A 再次更新该对象（会先读并获取 D2），并且更新请求被另一个节点 Sy 处理；那么系统中就会存在对象 D3 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx, 2), (Sy, 1)]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;客户端 B 读取了 D2 并尝试更新，并且该请求被另一个节点 Sz 处理；那么系统中就会存在对象 D4 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx2,  2),(Sx, 1)]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;现在 Dynamo 系统中存在多个版本的对象：D1, D2, D3, D4
    &lt;ol&gt;
      &lt;li&gt;如果一个节点知道了 D1 或 D2 的存在，那么当其接收到 D4 时，能够判断 D1 或 D2 被新的数据（D4）覆盖了，此时可以直接回收 D1, D2&lt;/li&gt;
      &lt;li&gt;如果一个节点知道 D3 的存在，那么当其收到 D4 时，会发现 D3, D4 是冲突的（没有因果关系）。&lt;em&gt;这两个版本都应该被保留，并且待客户端下次读的时候全部返回，交给客户端解决冲突&lt;/em&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;客户端读取到了 D3, D4，返回的 context 综合了 D3, D4 的 clock: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx, 2),(Sy, 1),(Sz, 1)]&lt;/code&gt;。如果客户端解决冲突并在节点 Sx 进行协调写操作，那么 Sx 会更新自己的序列号，生成的新对象 D5 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx, 3),(Sy, 1),(Sz, 1)]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;vector clock 存在一个问题：如果多个节点先后执行同一个对象的写操作，那么该对象的时钟向量就会变得很长。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般写操作只会被 preference list 中的前 N 个节点执行，长度可控&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;4-5-execution-of-get--and-put--operations&quot;&gt;4-5 Execution of Get () and Put () Operations&lt;/h2&gt;

&lt;p&gt;在 Dynamo 中，&lt;strong&gt;任意节点都可以处理任意 key 的 get() &amp;amp; put() 请求&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;操作请求路由有两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;由负载均衡器根据节点的负载选择一个节点进行请求&lt;/li&gt;
  &lt;li&gt;使用能够感知分区的客户端，将请求直接路由到 coordinator 节点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;负责处理读写请求的节点被称为 coordinator&lt;/strong&gt;。一般情况下 coordinator 是 preference list 中&lt;strong&gt;前 N 个节点中的第一个&lt;/strong&gt;（注意 list 中的节点数大于 N）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果请求是通过负载均衡器转发的，那么可能会被路由到任意一个节点上。此时，如果被路由的节点不是 preference list 中前 N 个节点的第一个节点，那么它不会处理该请求，而是将请求转发到 list 中第一个节点&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;读写操作需要 preference list 中前 N 个节点都处于健康状态&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果前 N 个节点均健康，则取前 N 个节点&lt;/li&gt;
  &lt;li&gt;如果前 N 个节点中存在不可用节点，则跳过，优先访问 list 中编号较小的节点&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-5-1-quorum-algrithom&quot;&gt;4-5-1 Quorum Algrithom&lt;/h3&gt;

&lt;p&gt;为了保证副本的一致性，Dynamo 使用了一种类似仲裁系统（quorum systems）的一致性协议。 这个协议有两个配置参数：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;：&lt;strong&gt;允许执行一次读操作所需的最少投票者&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt;：&lt;strong&gt;允许执行一次写操作所需的最少投票者&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;并且  &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R + W &amp;gt; N&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种情况下， get or put 的延迟由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;（或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt;）个&lt;strong&gt;副本中最慢的一个决 定&lt;/strong&gt;。因此，为了降低延迟，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt; 通常设置的比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; 小。&lt;/p&gt;

&lt;h3 id=&quot;4-5-2-get--and-put--operations&quot;&gt;4-5-2 Get () and Put () Operations&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Put() 操作流程&lt;/strong&gt; ：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;coordinator 收到 put() 请求后，创建新的 vector clock，并将其保存在本地&lt;/li&gt;
  &lt;li&gt;coordinator 将最新的版本对象&lt;em&gt;发送给 preference list 中前 N 个健康节点&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;前 N 个节点中如果有至少 W-1 个节点返回成功，则该 put() 请求成功&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Get() 操作流程&lt;/strong&gt; ：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;coordinator 收到 get() 请求后，向 preference list 中前 N 个健康节点查询该 key 对应的数据版本&lt;/li&gt;
  &lt;li&gt;coordinator 收到 R 个响应之后，将结果返回给客户端
    &lt;ol&gt;
      &lt;li&gt;如果 coordinator 获取到了多个版本，会将&lt;strong&gt;没有因果关系的版本返回给客户端&lt;/strong&gt;，客户端需要对该结果进行&lt;strong&gt;冲突解决&lt;/strong&gt;，合并成最新版本，然后&lt;strong&gt;将结果重新回写 Dynamo&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-6-handling-failures-hinted-handoff&quot;&gt;4-6 Handling Failures: Hinted Handoff&lt;/h2&gt;
&lt;p&gt;传统的仲裁算法无法保证 Dynamo 系统在节点失效或者网络分区的情况下仍然可用，持久性也会降低。&lt;/p&gt;

&lt;p&gt;因此，Dynamo 采用&lt;strong&gt;宽松的仲裁机制&lt;/strong&gt;（sloppy quorum）：&lt;strong&gt;所有读写操作在 preference list 的前 N 个健康节点执行&lt;/strong&gt;（&lt;em&gt;前 N 个健康节点不一定是前 N 个节点，如果遇到不健康的节点，会顺延&lt;/em&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo/dynamo_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在之前数据分区的例子中，N =3。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 A 节点临时不可用，那么本应该发送给 A 的更新请求会被发送到 D&lt;/li&gt;
  &lt;li&gt;发送到 D 的副本的元数据中会提示 (hint) 这个副本本应该发送给 A&lt;/li&gt;
  &lt;li&gt;该数据被 D 保存到本地一个独立的数据库中
    &lt;ul&gt;
      &lt;li&gt;D 有一个定时任务不断扫描，如果发现 A 重新变得可用了，就将数据发送给 A&lt;/li&gt;
      &lt;li&gt;成功发送回 A 之后，D 可以将该数据从本地数据库中删除；以&lt;strong&gt;保证系统内的副本数保持不变&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过 hinted handoff 机制，保证了&lt;strong&gt;在节点或者网络发生临时故障时，读写操作不会失败，提高了可用性与持久性&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过配置不同的 R 与 W，可以满足不同级别的可用性与持久性；W = 1 可用性最高，但是持久性较低&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;为了提高容灾等级，保证整个数据中心挂掉的情况下系统仍然可用，可以将 preference list 中的节点分散到不同的数据中心。&lt;/p&gt;

&lt;h2 id=&quot;4-7-handling-permanent-failures-replica-synchronization&quot;&gt;4-7 Handling Permanent Failures: Replica Synchronization&lt;/h2&gt;

&lt;p&gt;hinted handoff 机制在短时故障的场景下运行良好，但是对于长期故障的场景无法保证持久性：在 hinted 副本移交给本应该存储该副本的节点之前，该副本就不可用了，那么系统中的副本就会出现不一致的情况。&lt;/p&gt;

&lt;p&gt;为了保证不同副本之间的一致性，&lt;strong&gt;Dynamo 实现一种逆熵（副本同步）协议来保证副本之间是同步的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为了&lt;em&gt;快速检测副本之间的不一致性，以及最小转移的数据量&lt;/em&gt;，Dynamo 使用了 Merkle tree。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Merkle tree 是一个 Hash tree：叶子节点是 key 对应的 value 的 hash 值；父节点是子节点的 hash&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果两棵树的根节点 hash 值相同，那么这两棵树的叶子节点肯定相同，则这两棵树是一致的；否则这两棵树存在不一致的数据，需要继续比较其子节点的 hash 值，直到找到不一致的子树。&lt;/p&gt;

&lt;p&gt;Dynamo 系统的&lt;strong&gt;每个节点为每段 key range 维护了一个单独的 Merkle tree&lt;/strong&gt;。不同节点之间可以比较其维护的 key range 内的 key 是否一致。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;key range: 一致性 hash 环中每个节点维护的范围&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;这种方案的缺点是：&lt;em&gt;每当有节点加入或离开系统时，一些 key range 会变，因此对应的 tree 需要重新计算&lt;/em&gt;。&lt;/p&gt;

&lt;h2 id=&quot;4-8-membership-and-failure-detection&quot;&gt;4-8 Membership and Failure Detection&lt;/h2&gt;

&lt;h3 id=&quot;4-8-1-ring-membership&quot;&gt;4-8-1 Ring Membership&lt;/h3&gt;

&lt;p&gt;Dynamo 使用&lt;strong&gt;显示机制来向 hash ring 中增删节点&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通常情况下节点不可用持续的时间都比较短，一个节点的临时不可用不能说明这个节点永久离开了系统，因此不应该在节点不可用时立即进行 re-partiton，或者修复无法访问的副本&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;管理员通过命令行手动添加或者删除节点，负责处理该请求的节点&lt;strong&gt;将成员变动的信息持久化到本地，并通过 gossip-based 算法广播成员变动信息&lt;/strong&gt;，保证成员信息的一致性。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;每个节点周期性地随机选择另一个节点，这两个节点互相交换自己拥有的成员信息，维护成员信息的一致性&lt;/em&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;节点启动时，计算自己的 token 集合（一致性 hash ring 上的 token range）&lt;/li&gt;
  &lt;li&gt;将节点映射到 token 集合中（包含虚拟节点）&lt;/li&gt;
  &lt;li&gt;将映射关系持久化到本地&lt;/li&gt;
  &lt;li&gt;与其他节点交换自己维护的成员信息，从而不同节点保持一致&lt;/li&gt;
  &lt;li&gt;通过 gossip-based 协议多次交换后，每个节点都会知道其他节点负责的 token 范围&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;成员信息的交换，既能保证维护信息的一致性，也能够使得&lt;strong&gt;每个节点都可以将任意 key 的读写操作直接发送给正确的节点处理&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;4-8-2-external-discovery&quot;&gt;4-8-2 External Discovery&lt;/h3&gt;

&lt;p&gt;上述成员信息维护流程啃根会导致 Dynamo 在逻辑上的临时分裂：管理员添加 A 节点，A 维护了自己的 token 集合；之后管理员又将 B 添加到系统中，B 也维护了自己的 token 集合；但是 A，B 两个节点&lt;em&gt;无法感知对方的存在&lt;/em&gt;，就无法进行信息交换。&lt;/p&gt;

&lt;p&gt;为了避免逻辑分裂，可以通过&lt;strong&gt;外部机制配置一些 Dynamo 节点作为种子节点&lt;/strong&gt;：&lt;em&gt;所有节点都知道种子节点的存在，并和种子节点交换自己的信息，最终所有节点都会感知对方的存在，避免逻辑分裂的可能&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;种子节点只是一个普通的 Dynamo 节点，不过是提前配置在配置中心或者配置文件中&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-8-3-failure-detection&quot;&gt;4-8-3 Failure Detection&lt;/h3&gt;

&lt;p&gt;故障检测是一个&lt;strong&gt;纯本地概念&lt;/strong&gt;（pure local notion）的检测机制：只要节点 B 没有应答 A 的请求，那么 A 就认为 B 发生故障，不可访问。&lt;/p&gt;

&lt;p&gt;如果 A 认为 B 是故障的，那么可以选择与 B 拥有同一个 partition 的其他节点（preference list 中的其他节点）来处理请求，并定期检查 B 是否再次可用。&lt;/p&gt;

&lt;p&gt;故障检测的目的是为了&lt;em&gt;避免尝试与不可访问的节点持续通信&lt;/em&gt;，如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;get(), put() 操作访问的节点&lt;/li&gt;
  &lt;li&gt;转移 partition 和 临时副本(hinted replica) 时的目标节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在没有客户端请求的情况下，节点之间并不需要知道对方是否故障；在客户端持续请求下，不同节点间会持续交互，此时如果对方不可访问，当前节点也会立马知道。&lt;/p&gt;

&lt;h2 id=&quot;4-9-addingremoving-storage-nodes&quot;&gt;4-9 Adding/Removing Storage Nodes&lt;/h2&gt;

&lt;p&gt;当新节点 X 添加到系统中后，它会获得一些&lt;strong&gt;随机分散在 hash ring 上的 token 集合&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo/dynamo_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如 X 加入 A, B 节点之间，X 就会负责&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(F, G], (G, A] and (A, X]&lt;/code&gt; 之间的 key。相应地，B, C, D 节点就不需要负责相应的 range 了。&lt;strong&gt;在收到 X 转移 key 的请求之后，B, C, D 会向 X 转移相应的 key&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;节点移除的分配顺序相反&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;通过这种方式，可以使得 key 在存储节点上均匀分布。同时，为了不重复转移 key range，需要在源节点与目标节点间添加确认机制。&lt;/p&gt;

&lt;h1 id=&quot;5-implementation&quot;&gt;5-Implementation&lt;/h1&gt;

&lt;p&gt;Dynamo 系统中的每个节点上有 3 个组件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;request coordination（请求协调）组件&lt;/li&gt;
  &lt;li&gt;成员验证 &amp;amp; 故障检测组件&lt;/li&gt;
  &lt;li&gt;本地持久化存储引擎&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-1-local-storage&quot;&gt;5-1 Local Storage&lt;/h2&gt;

&lt;p&gt;存储引擎组件设计为可插拔：&lt;strong&gt;为不同访问类型选择合适的存储引擎&lt;/strong&gt;。如 BDB 适合处理几十 KB 大小的对象，MySQL 适合处理更大的对象&lt;/p&gt;

&lt;h2 id=&quot;5-2-request-coordination&quot;&gt;5-2 Request Coordination&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Coordinator 构建在事件驱动的消息系统上，用于代替客户端执行读写请求&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读操作会从一个或者多个节点收集数据&lt;/li&gt;
  &lt;li&gt;写操作会向一个或者多个节点存储数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Coordinator 会&lt;strong&gt;为每个请求创建一个状态机&lt;/strong&gt;：包含了&lt;em&gt;识别 key 对应的节点，发送请求，等待响应，重试，处理响应，组合响应，返回给客户端&lt;/em&gt;等逻辑。&lt;/p&gt;

&lt;p&gt;每个状态机只会处理一个客户端请求，读操作流程为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;发送读请求给其他 Dynamo 节点&lt;/li&gt;
  &lt;li&gt;等待最少数量的响应
    &lt;ol&gt;
      &lt;li&gt;如果在一定时间内收到的响应数少于规定的，则认为请求失败&lt;/li&gt;
      &lt;li&gt;如果满足规定数量，则收集对象的所有版本，并确定返回版本&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;如果收到过期版本，则需要合并版本并回写给对应节点 —— 读修复(read repair)&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;生成上下文 context：包含版本向量时钟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;即使读操作的结果已经响应给客户端，&lt;strong&gt;状态机也会等待一段时间，用于接受剩余节点可能的有效响应&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;对于写操作，如果&lt;strong&gt;&lt;em&gt;总是选择 preference list 中的第一个健康节点作为 coordinator，可以完成写操作的序列化&lt;/em&gt;&lt;/strong&gt;，但是会导致负载不均衡（操作请求的 key 不一定是均匀分布的）。为了解决这个问题，&lt;strong&gt;preference list 中的前 N 个健康节点都可以作为 coordinator&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;并且，每个写操作请求前都会先进行一次读操作，所以&lt;strong&gt;写操作的 coordinator 可以选择前一次读操作返回最快的节点&lt;/strong&gt;（该信息存储在读操作的 context 中）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该策略同时提高了“读取刚写入数据”的概率&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;6-conclusions&quot;&gt;6-Conclusions&lt;/h1&gt;

&lt;p&gt;Dynamo 作为一个高可用，高可扩展的数据仓库，提供了期望的可用性和性能等级，可以正确地处理服务器故障、数据中心故障和网络分裂；支持增量扩展；允许&lt;strong&gt;客户端应用可以通过对 N、R 和 W 三个参数进行调优来达到期望的性能、可用性和持久性等级&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Dynamo 表明了&lt;strong&gt;最终一致性存储系统可以作为高可用应用（highly available applications）的一块基石。&lt;/strong&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">1-Abstract</summary></entry><entry><title type="html">现在完成时与一般过去时</title><link href="http://localhost:4000/present-progressive-and-past-tense.html" rel="alternate" type="text/html" title="现在完成时与一般过去时" /><published>2022-01-16T00:00:00+08:00</published><updated>2022-01-16T00:00:00+08:00</updated><id>http://localhost:4000/present-progressive-and-past-tense</id><content type="html" xml:base="http://localhost:4000/present-progressive-and-past-tense.html">&lt;p&gt;现在完成时与一般过去时是英语中用法极为灵活的两种时态，它们属于不同时间的两种时态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;现在完成时属于现在时态的范畴&lt;/li&gt;
  &lt;li&gt;一般过去时属于过去时态的范畴&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-构成形式不同&quot;&gt;1-构成形式不同&lt;/h2&gt;

&lt;p&gt;现在完成时的动词形式为：&lt;strong&gt;have (has) + 动词的过去分词&lt;/strong&gt;；一般过去时的动词形式为：&lt;strong&gt;动词的过去式&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一般过去时：Jack’s mother took him to school every day when he was in primary school.&lt;/li&gt;
  &lt;li&gt;现在完成时：Maria has never read any Chinese stories.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-强调对象不同&quot;&gt;2-强调对象不同&lt;/h2&gt;

&lt;p&gt;现在完成时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用来表示之前已发生或完成的动作或状态，其结果和现在有联系，现在完成时的&lt;strong&gt;&lt;em&gt;动作或状态发生在过去，但它的影响现在还存在&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;强调过去的事情对现在的影响，&lt;strong&gt;&lt;em&gt;强调的是影响&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般过去时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;表示过去的事实，不表示和现在的关系。&lt;/li&gt;
  &lt;li&gt;表示过去某时发生的动作或单纯叙述过去的事情，&lt;strong&gt;&lt;em&gt;强调动作&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Yesterday I went to the zoo.（仅说明昨天去了动物园，与现在无关）&lt;/li&gt;
  &lt;li&gt;Li Lei has read the book.（强调对现在的影响，那本书的内容已经了解）&lt;/li&gt;
  &lt;li&gt;Mr Green bought a new computer yesterday.（强调的是格林先生买新电脑的时间是昨天）&lt;/li&gt;
  &lt;li&gt;Mr Green has bought a new computer.（重点是格林先生现在有了一台新电脑）&lt;/li&gt;
  &lt;li&gt;I saw the film three days ago.（强调是三天前，而不是别的什么时候看的电影）&lt;/li&gt;
  &lt;li&gt;I have seen the film.（现在我仍记得电影的内容）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-时间状语不同&quot;&gt;3-时间状语不同&lt;/h2&gt;

&lt;p&gt;一般过去时常与 &lt;strong&gt;&lt;em&gt;具体的时间状语&lt;/em&gt;&lt;/strong&gt; 连用，而现在完成时通常与 &lt;strong&gt;&lt;em&gt;模糊的时间状语&lt;/em&gt;&lt;/strong&gt; 连用，或 &lt;strong&gt;&lt;em&gt;无时间状语&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一般过去时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Yesterday, Last week / month / year / night/ Monday, yesterday morning / afternoon / evening,
just now = a moment ago, …ago, the day before yesterday, 
in +（已过去的）某年/ 月, on +（已过去的）某天, at +（已过去的）几点钟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在完成时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;可以和带有 &lt;strong&gt;&lt;em&gt;since 或 for 等表示一段时间的状语&lt;/em&gt;&lt;/strong&gt; 连用, 表示动作或状态从某一时刻开始，一直持续到现在。&lt;/p&gt;

    &lt;p&gt;在与 for 及 since 引导的一段时间状语连用时，句子的谓语动词必须是&lt;strong&gt;&lt;em&gt;延续性动词&lt;/em&gt;&lt;/strong&gt;，短暂性动词不可和一段时间连用。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He has become a soldier for three years.（wrong）&lt;/li&gt;
      &lt;li&gt;He has been a soldier for three years. (right)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;往往与&lt;strong&gt;&lt;em&gt;表示不确定的过去时间状语&lt;/em&gt;&lt;/strong&gt;连用，如 &lt;strong&gt;already&lt;/strong&gt;(肯定句中)，&lt;strong&gt;yet&lt;/strong&gt;(否定，疑问，句末)，&lt;strong&gt;just&lt;/strong&gt;, &lt;strong&gt;before&lt;/strong&gt;, &lt;strong&gt;recently&lt;/strong&gt;, &lt;strong&gt;still&lt;/strong&gt;, &lt;strong&gt;lately&lt;/strong&gt;, &lt;strong&gt;never&lt;/strong&gt; 等
    &lt;ul&gt;
      &lt;li&gt;He has already obtained a scholarship.&lt;/li&gt;
      &lt;li&gt;I haven’t seen much of him recently (lately).&lt;/li&gt;
      &lt;li&gt;We have seen that film before.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;经常与&lt;strong&gt;&lt;em&gt;表示频率的时间状语&lt;/em&gt;&lt;/strong&gt;连用，如：&lt;strong&gt;often, sometimes, ever, never, twice, on several occasion&lt;/strong&gt; 等.
    &lt;ul&gt;
      &lt;li&gt;Have you ever been to Beijing?&lt;/li&gt;
      &lt;li&gt;I have never heard Bunny say anything against her.&lt;/li&gt;
      &lt;li&gt;George has met that gentleman on several occasions.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果上述关键词都没有出现的话，就看是描述一个过去的事实或动作，还是表示强调已经完成了的事件对现在产生的影响。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">现在完成时与一般过去时是英语中用法极为灵活的两种时态，它们属于不同时间的两种时态：</summary></entry></feed>