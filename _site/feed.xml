<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-22T22:28:29+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Find a needle in haystack</title><subtitle></subtitle><author><name>kkzhang</name></author><entry><title type="html">供给，需求与政府政策</title><link href="http://localhost:4000/principles-of-economics-3.html" rel="alternate" type="text/html" title="供给，需求与政府政策" /><published>2022-10-22T00:00:00+08:00</published><updated>2022-10-22T00:00:00+08:00</updated><id>http://localhost:4000/principles-of-economics-3</id><content type="html" xml:base="http://localhost:4000/principles-of-economics-3.html">&lt;h1 id=&quot;价格控制&quot;&gt;价格控制&lt;/h1&gt;

&lt;p&gt;在一个没有政府管制的竞争市场上，冰淇淋的价格将自发调整，使得供求达到平衡：均衡价格时，买者想买的冰淇淋数目等于卖者想卖的冰淇淋数目。&lt;/p&gt;

&lt;p&gt;不过，政府可以对冰淇淋的价格进行控制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;价格上限&lt;/strong&gt;：出售一种物品的法定最高价格&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;价格下限&lt;/strong&gt;：出售一种物品的法定最低价格&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;价格上限对市场的影响&quot;&gt;价格上限对市场的影响&lt;/h2&gt;

&lt;p&gt;假设在没有政府干预的情况下，冰淇淋的均衡价格为 3 美元。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;非限制性价格上限&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;假设价格上限为 4 美元，此时均衡价格低于价格上限，那么该价格上限是非限制性的，&lt;strong&gt;价格上限对价格或者销售量没有影响&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/economics/chap6/eco_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;限制性价格上限&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;假设价格上限为 2 美元，此时均衡价格高于价格上限，那么该价格上限是限制性的。&lt;/p&gt;

    &lt;p&gt;这种情况下，&lt;strong&gt;供给小于需求，冰淇淋出现短缺&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/economics/chap6/eco_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;当由于价格上限而导致短缺时，一些配给机制会出现：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;购买者排长队，愿意提前来并等候的人可以买到冰淇淋&lt;/li&gt;
      &lt;li&gt;卖者根据自己的偏好来配给冰淇淋&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;设置价格上限的动机是为了帮助买者，但是并不是所有买者都能从中受益，存在一些买者根本买不到冰淇淋&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结论：&lt;strong&gt;当政府对竞争市场实行限制性价格上限时，就产生了物品短缺，而且卖者必须在大量潜在买者中配给稀缺商品&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在自由市场中，价格用来配给商品&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;价格下限对市场的影响&quot;&gt;价格下限对市场的影响&lt;/h2&gt;

&lt;p&gt;假设在没有政府干预的情况下，冰淇淋的均衡价格为 3 美元。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;非限制性价格下限&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;假设价格下限为 2 美元，低于均衡价格，此时价格下限没有限制作用；市场力量自然地使价格向均衡价格移动。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/economics/chap6/eco_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;限制性价格下限&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;假设价格下限为 4 美元，高于均衡价格，此时价格下限存在限制性约束。&lt;/p&gt;

    &lt;p&gt;这种情况下，&lt;strong&gt;供给大于需求，冰淇淋出现过剩&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/economics/chap6/eco_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;价格下限引发的过剩也会导致不合意的配给机制：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;买者由于个人偏好可以选择产品&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;对价格控制的评价&quot;&gt;对价格控制的评价&lt;/h2&gt;

&lt;p&gt;在经济学中，价格时隐藏在供给曲线和需求曲线背后的千百万企业和消费者决策的结果，价格有平衡供求从而协调经济活动的关键作用。&lt;em&gt;当决策者通过法令确定价格时，就模糊了正常情况下指引社会资源配置的信号&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;价格控制的目标往往是帮助穷人，但是&lt;strong&gt;往往会损害哪些它本想帮助的人&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;租金控制可以保持低租金，但是无法鼓励房东修缮住房，并使找房变得困难&lt;/li&gt;
  &lt;li&gt;最低工资可以增加一些工人的收入，但是也会使其他工人成为失业者&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;税收&quot;&gt;税收&lt;/h1&gt;

&lt;p&gt;当政府对一种物品征税时，谁实际上承担了税收负担？买者？卖者？还是两者共同承担？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;税收归宿&lt;/strong&gt;（tax incidence）是指税收负担如何在组成市场的不同人之间分配。&lt;/p&gt;

&lt;h2 id=&quot;向卖者征税对市场的影响&quot;&gt;向卖者征税对市场的影响&lt;/h2&gt;

&lt;p&gt;假设政府规定，向冰淇淋卖者卖出的每个冰淇淋征收 0.5 美元的税收。那么将如何影响卖者和买者？&lt;/p&gt;

&lt;p&gt;可以按照分析供求的三个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;确定该法律影响的是供给曲线还是需求曲线&lt;/li&gt;
  &lt;li&gt;确定曲线移动的方向&lt;/li&gt;
  &lt;li&gt;考察这种移动如何影响均衡价格和数量&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/economics/chap6/eco_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一步：税收对卖者产生直接影响，因此使&lt;strong&gt;供给曲线移动&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;第二步：对卖者征税提高了生产和销售冰淇淋的成本，因此征税减少了每一种价格下的供给量，使&lt;strong&gt;供给曲线左移（或者说上移）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;供给曲线移动幅度：在每一种供给量下，卖者必须将价格提高 0.5 美元，以便弥补税收的影响。因此，供给曲线从 S1 向上移动到 S2，&lt;strong&gt;移动幅度正好是税收量&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;第三步：在新平衡下，冰淇淋价格由 3 美元上升为 3.3 美元；均衡数量由 100 个减少到 90 个。卖者的销售量减少了，买者的购买量也减少了，因此&lt;strong&gt;税收缩小了冰淇淋市场的规模&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;回到税收归宿问题，谁支付了税收？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;买者：购买价格增加了 0.3 美元&lt;/li&gt;
  &lt;li&gt;卖者：销售价格虽然为 3.3 美元，但是交税后的有效价格为 3.3 - 0.5 = 2.8 美元，比之前的 3 美元少了 0.2 美元&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，我们可以得出两个结论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;税收抑制了市场活动&lt;/strong&gt;：物品在新均衡的销售量减少了&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;买者与卖者分摊了税收负担&lt;/strong&gt;：在新均衡时，买者支付更多，卖者得到更少&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;向买者征税对市场的影响&quot;&gt;向买者征税对市场的影响&lt;/h2&gt;

&lt;p&gt;假设政府规定，向冰淇淋买者购买的每个冰淇淋征收 0.5 美元的税收。那么将如何影响卖者和买者？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/economics/chap6/eco_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;仍然按照三个步骤分析：&lt;/p&gt;

&lt;p&gt;第一步：向买者征税，直接影响需求，使得&lt;strong&gt;需求曲线移动&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;第二步：征税使买者在每一价格下的冰淇淋的需求量减少，使得需&lt;strong&gt;求曲线向左移动（或者说向下移动）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;需求曲线移动幅度：买者关注的是包括税收在内的总成本，因此在每一种需求量下，市场价格必须降低 0.5 美元，以弥补税收的影响。因此，税收使需求曲线从 D1 向下移动到 D2，移动幅度正好是税收量（0.5 美元）。&lt;/p&gt;

&lt;p&gt;第三步：在新平衡下，均衡价格由 3 美元下降到 2.8 美元；均衡数量由 100 下降到 90，冰淇淋市场规模缩小。同时，买者与卖者分摊了税收负担。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;买者：购买成本 2.8 + 0.5 = 3.3 美元&lt;/li&gt;
  &lt;li&gt;卖者：销售价格由 3 美元降低到 2.8 美元&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结论：&lt;strong&gt;对卖者征税和对买者征税使相同的：在新均衡下，买者和卖者共同承担了税收负担&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;弹性与税收归宿&quot;&gt;弹性与税收归宿&lt;/h2&gt;

&lt;p&gt;对物品征税时，由卖者与买者共同分摊税收负担，但是如何准确划分？&lt;/p&gt;

&lt;p&gt;税收负担更多地落在缺乏弹性的市场一方身上：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;当供给比需求更富有弹性时，税收更多地由消费者承担&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/economics/chap6/eco_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;当需求比供给更富有弹性时，税收更多地由生产者承担&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/economics/chap6/eco_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;价格上限是某种物品与服务的法定最高价格；价格下限是某种物品与服务的法定最低价格&lt;/li&gt;
  &lt;li&gt;当政府对一种物品征收税收时，该物品的均衡数量减少，市场规模缩小&lt;/li&gt;
  &lt;li&gt;税收归宿并不取决于向卖者征税还是向买者征税；税收归宿取决于供给和需求的价格弹性，税收负担更多地落在缺乏弹性的市场一方&lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="economics" /><summary type="html">价格控制</summary></entry><entry><title type="html">供给与需求的市场力量</title><link href="http://localhost:4000/principles-of-economics-2.html" rel="alternate" type="text/html" title="供给与需求的市场力量" /><published>2022-07-21T00:00:00+08:00</published><updated>2022-07-21T00:00:00+08:00</updated><id>http://localhost:4000/principles-of-economics-2</id><content type="html" xml:base="http://localhost:4000/principles-of-economics-2.html">&lt;p&gt;&lt;strong&gt;供给&lt;/strong&gt;与&lt;strong&gt;需求&lt;/strong&gt;是使市场经济运行的力量，它们决定了每种物品的产量及出售价格。&lt;/p&gt;

&lt;h1 id=&quot;市场与竞争&quot;&gt;市场与竞争&lt;/h1&gt;

&lt;p&gt;供给与需求这两个术语是指人们在&lt;strong&gt;竞争市场&lt;/strong&gt;上相互交易时的行为。&lt;/p&gt;

&lt;h2 id=&quot;什么是市场&quot;&gt;什么是市场&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;市场&lt;/strong&gt;（market）是&lt;em&gt;由某种物品或者服务的买者与卖者组成的一个群体&lt;/em&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;买者决定了产品的需求&lt;/li&gt;
  &lt;li&gt;卖者决定了产品的供给&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;市场有多种形式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;组织健全的市场&lt;/strong&gt;：如农产品市场上，买者与卖者在特定的时间与地点聚集在一起，同时市场上还有一些拍卖者协助确定价格并安排销售&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;没有组织的市场&lt;/strong&gt;：如某个小镇的冰淇淋市场，买者与卖者并没有在特定时间聚集在一起，冰淇淋卖者分散在各个地方并提供略有差异的产品，各个卖者标出冰淇淋价格，而各个买者决定在每个店中买多少冰淇淋&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是竞争&quot;&gt;什么是竞争&lt;/h2&gt;

&lt;p&gt;大多数市场是高度竞争的。以冰淇淋市场为例，每个买者都知道有一些卖者可供选择，并且每个卖者也认识到其提供的产品与其他卖者提供的产品是相似的。因此，冰淇淋价格并不是由任何一个买者或者卖者决定的。确切地说，&lt;strong&gt;&lt;em&gt;冰淇淋的价格和销售量是由所有买者和卖者通过在市场上相互交易而共同决定的&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;竞争市场&lt;/strong&gt;（competitive market）：&lt;em&gt;有许多买者和卖者，以至于每个人对市场价格的影响都微乎其微的市场&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;完全竞争市场是竞争市场的最高形式，该市场必须具备两个特征：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可供销售的物品是完全相同的&lt;/li&gt;
  &lt;li&gt;买者与卖者人数众多，以至于没有任何一个买者和卖者可以影响市场价格&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在完全竞争市场中，买者和卖者必须接受市场决定的价格，被称为价格接受者。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;垄断市场&lt;/strong&gt;：一些市场只有一个卖者，而这个卖者决定市场价格。&lt;/p&gt;

&lt;h1 id=&quot;需求&quot;&gt;需求&lt;/h1&gt;

&lt;h2 id=&quot;需求曲线价格与需求量之间的关系&quot;&gt;需求曲线：价格与需求量之间的关系&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;需求量&lt;/strong&gt;（quantity demanded）：买者愿意并且能够购买的一种物品的数量。&lt;/p&gt;

&lt;p&gt;需求量由很多因素决定，其中最主要的因素是物品的&lt;strong&gt;价格&lt;/strong&gt;。&lt;em&gt;在其他条件不变时，一种物品的价格上升，则对该物品的需求量减少；一种物品的价格下降，则对该物品的需求量降低&lt;/em&gt;，被称为&lt;strong&gt;需求定理&lt;/strong&gt;（law of demand）。&lt;/p&gt;

&lt;p&gt;把价格与需求联系在一起的曲线被称为&lt;strong&gt;需求曲线&lt;/strong&gt;（demand curve）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/economics/chap4/eco_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;市场需求与个人需求&quot;&gt;市场需求与个人需求&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;市场需&lt;/strong&gt;求是&lt;em&gt;所有人对某个特定物品或服务的需求总和&lt;/em&gt;。同样，市场需求曲线表示在所有影响消费者购买数量的其他因素不变时，一种物品的需求总量与该物品价格的关系。&lt;/p&gt;

&lt;h2 id=&quot;需求曲线的移动&quot;&gt;需求曲线的移动&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;如果某种因素改变了既定价格下的需求量，需求曲线就会移动&lt;/em&gt;&lt;/strong&gt;（之前我们假设其他因素保持不变）。例如：假如研究发现经常吃冰淇淋有助于身体健康，那么这个发现会增加对冰淇淋的需求。在现有价格下，买者会购买更多的冰淇淋，因此需求曲线就会移动。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使每一种价格水平下的需求量增加的任何变动，都会使需求曲线向右移动，称之为&lt;strong&gt;需求增加&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;使每一种价格水平下的需求量减少的任何变动，都会使需求曲线向左移动，称之为&lt;strong&gt;需求减少&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/economics/chap4/eco_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有许多因素会导致需求曲线移动：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;收入&lt;/li&gt;
  &lt;li&gt;相关物品价格&lt;/li&gt;
  &lt;li&gt;爱好&lt;/li&gt;
  &lt;li&gt;预期&lt;/li&gt;
  &lt;li&gt;购买者数量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;需求曲线表示在&lt;strong&gt;其他&lt;/strong&gt;所有影响买者的&lt;strong&gt;变量保持不变&lt;/strong&gt;的情况下，一种&lt;strong&gt;物品的价格变动时，该物品的需求量会发生什么变动&lt;/strong&gt;。当这些&lt;strong&gt;变量&lt;/strong&gt;中的一个&lt;strong&gt;变动&lt;/strong&gt;时，&lt;strong&gt;需求曲线会发生移动&lt;/strong&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;变量&lt;/th&gt;
      &lt;th&gt;变量的变动将导致&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;价格&lt;/td&gt;
      &lt;td&gt;沿着需求曲线变动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;收入，相关物品价格，爱好，预期，买者数量&lt;/td&gt;
      &lt;td&gt;使需求曲线移动&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;供给&quot;&gt;供给&lt;/h1&gt;

&lt;h2 id=&quot;供给曲线价格与供给量之间的关系&quot;&gt;供给曲线：价格与供给量之间的关系&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;供给量&lt;/strong&gt;（quantity supplied）：卖者愿意并且能够出售的该种物品的数量。&lt;/p&gt;

&lt;p&gt;决定供给量的因素有很多，价格仍然起着主要作用。价格与供给量之间的关系被称为&lt;strong&gt;供给定理&lt;/strong&gt;（law of supply）：&lt;em&gt;在其他条件不变时，一种物品价格上升，该物品供给量增加；一种物品价格下降，该物品供给量减少&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;把价格与供给量联系在一起的曲线被称为&lt;strong&gt;供给曲线&lt;/strong&gt;（supply curve）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/economics/chap4/eco_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;市场供给与个人供给&quot;&gt;市场供给与个人供给&lt;/h2&gt;

&lt;p&gt;与市场需求一样，市场供给是所有卖者供给的总和。&lt;/p&gt;

&lt;h2 id=&quot;供给曲线移动&quot;&gt;供给曲线移动&lt;/h2&gt;

&lt;p&gt;供给曲线是假设其他条件不变时，价格与供给量之间的关系；但是当其他因素发生变化时，供给曲线将发生移动。例如，糖的价格下降了，会增加冰淇淋的供给：在任何一种既定价格水平下，卖者愿意生产更多的冰淇淋，冰淇淋的供给曲线向右移动。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在既定价格水平下，使供给量增加的任何一种变动（如，糖价格下降），都会使供给曲线向右移动，称之为&lt;strong&gt;供给增加&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;在既定价格水平下，使供给量减少的任何一种变动，都会使供给曲线左移，称之为&lt;strong&gt;供给减少&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/economics/chap4/eco_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有许多变量会使供给曲线发生移动，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;投入品价格&lt;/li&gt;
  &lt;li&gt;技术&lt;/li&gt;
  &lt;li&gt;预期&lt;/li&gt;
  &lt;li&gt;卖者数量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结-1&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;供给曲线表示在&lt;strong&gt;其他&lt;/strong&gt;所有影响卖者的&lt;strong&gt;变量保持不变&lt;/strong&gt;的情况下，一种物品&lt;strong&gt;价格变动&lt;/strong&gt;时，该物品的供给量会发生什么变动。当这些&lt;strong&gt;变量&lt;/strong&gt;中的一个&lt;strong&gt;变动&lt;/strong&gt;时，&lt;strong&gt;供给曲线就会发生移动&lt;/strong&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;变量&lt;/th&gt;
      &lt;th&gt;变量的变动将导致&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;价格&lt;/td&gt;
      &lt;td&gt;沿着供给曲线的变动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;技术，投入品价格，预期，卖者数量&lt;/td&gt;
      &lt;td&gt;使供给曲线移动&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;供给与需求的结合&quot;&gt;供给与需求的结合&lt;/h1&gt;

&lt;h2 id=&quot;均衡&quot;&gt;均衡&lt;/h2&gt;

&lt;p&gt;市场价格达到使供给量与需求量相等的水平时的状态被称为&lt;strong&gt;均衡状态&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;均衡价格&lt;/strong&gt;：使供给与需求平衡的价格；&lt;strong&gt;均衡数量&lt;/strong&gt;：均衡价格下的供给量与需求量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/economics/chap4/eco_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;供给曲线与需求曲线相交于一点，该点被称为市场的均衡。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;在均衡价格时，买者愿意并且能够购买的物品数量正好与卖者愿意并且能够卖出的数量相等&lt;/em&gt;。均衡价格有时候也会被称为&lt;strong&gt;市场出清价格&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;买者与卖者的行为自然而然地使市场向供给与需求的均衡变动。当市场价格不等于均衡价格时，物品会表现为过剩或者短缺，并使市场达到均衡为止。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;过剩&lt;/strong&gt;：&lt;em&gt;供给量大于需求量&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;当市场价格高于均衡价格时，会使得供给量大于需求量，此时物品就会出现过剩。&lt;/p&gt;

    &lt;p&gt;卖者对过剩的反应时降低其价格。当价格下降时，会使需求量增加，供给减少。&lt;/p&gt;

    &lt;p&gt;这种变化表现为沿着供给与需求曲线的变动，而不是曲线的移动。价格会持续下降，最终市场达到均衡。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/economics/chap4/eco_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;短缺&lt;/strong&gt;：&lt;em&gt;需求量大于供给量&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;当市场价格低于均衡价格时，会使得需求量大于供给量，此时物品就会出现短缺。&lt;/p&gt;

    &lt;p&gt;由于太多的买者抢购太少的物品，卖者可以提高物品价格。当价格提高时，引起需求减少，供给增加。&lt;/p&gt;

    &lt;p&gt;这种变化表现为沿着供给和需求曲线移动，并推动市场走向均衡。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/economics/chap4/eco_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;在大多数自由市场上，价格最终都要变动到其均衡水平，过剩与短缺都只是暂时的。&lt;em&gt;任何物品的价格都会自发调整，使该物品的供给与需求达到平衡&lt;/em&gt;，被称为&lt;strong&gt;供求定理&lt;/strong&gt;（law of supply and demand）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;分析均衡变动的步骤&quot;&gt;分析均衡变动的步骤&lt;/h2&gt;

&lt;p&gt;当分析某个事件如何影响一个市场上的均衡时，按照三个步骤进行：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;确定该事件是使供给曲线移动还是时需求曲线移动&lt;/strong&gt;（或者两者均移动）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;确定曲线移动的方向&lt;/strong&gt;（左还是右）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;用供求图来说明这种移动如何改变均衡价格与均衡数量&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;例由需求移动引起的市场均衡变动&quot;&gt;例：由需求移动引起的市场均衡变动&lt;/h3&gt;

&lt;p&gt;假设某年夏季天气特别炎热，这种情况如何影响冰淇淋市场？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;天气炎热改变了需求曲线，人们在既定价格下想要购买更多的冰淇淋。供给曲线不会变，因为天气并不直接影响销售企业&lt;/li&gt;
  &lt;li&gt;由于既定价格下需求增多，所以需求曲线向右移动&lt;/li&gt;
  &lt;li&gt;在原有价格下，需求 &amp;gt; 供给（因为需求增多，而不是供给减少），引起短缺，因此卖家提高冰淇淋价格，达到新的均衡。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;整体来看，&lt;strong&gt;&lt;em&gt;天气炎热提高了冰淇淋价格，增加了冰淇淋的销售量&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/economics/chap4/eco_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;曲线的移动与沿着曲线的移动&quot;&gt;曲线的移动与沿着曲线的移动&lt;/h3&gt;

&lt;p&gt;我们注意到，当天气炎热时，冰淇淋需求增加，并使其价格上升；尽管供给曲线不变，但是供给数量增加了。这种情况下，我们称为，&lt;strong&gt;“供给量”增加，但是“供给不变”&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;供给是指供给曲线的位置，供给量是指供给者希望出售的数量&lt;/p&gt;

&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;供给曲线的移动&lt;/strong&gt;被称为“&lt;strong&gt;供给变动&lt;/strong&gt;”，&lt;strong&gt;需求曲线的移动&lt;/strong&gt;被称为“&lt;strong&gt;需求变动&lt;/strong&gt;”&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;沿着固定的供给曲线变动&lt;/strong&gt;被称为“&lt;strong&gt;供给量的变动&lt;/strong&gt;”，&lt;strong&gt;沿着固定需求曲线的变动&lt;/strong&gt;被称为“&lt;strong&gt;需求量的变动&lt;/strong&gt;”&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;例由供给移动引起的市场均衡变动&quot;&gt;例：由供给移动引起的市场均衡变动&lt;/h3&gt;

&lt;p&gt;假设在另一个夏季，台风摧毁了部分甘蔗田，使得糖的价格上升，这个事件如何影响冰淇淋市场？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;糖作为冰淇淋的投入品，其价格上升影响了供给曲线，企业在既定价格下减少冰淇淋的供给。需求曲线没变。&lt;/li&gt;
  &lt;li&gt;供给曲线向左移动&lt;/li&gt;
  &lt;li&gt;在原有价格下，供给 &amp;lt; 需求（因为供给减少，而不是需求增多），引起短缺，因此卖家提高冰淇淋价格，达到新的均衡。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;整体来看，糖的价格上升，导致冰淇淋的价格上升，但是销售量减少了&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/economics/chap4/eco_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;当供给或需求移动时价格和数量将如何变化&quot;&gt;当供给或需求移动时，价格和数量将如何变化？&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;供给未变&lt;/th&gt;
      &lt;th&gt;供给增加&lt;/th&gt;
      &lt;th&gt;供给减少&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;需求未变&lt;/td&gt;
      &lt;td&gt;价格相同 数量相同&lt;/td&gt;
      &lt;td&gt;价格下降 数量增加&lt;/td&gt;
      &lt;td&gt;价格上升 数量减少&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;需求增加&lt;/td&gt;
      &lt;td&gt;价格上升 数量增加&lt;/td&gt;
      &lt;td&gt;数量增加 价格不定&lt;/td&gt;
      &lt;td&gt;价格上升 数量不定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;需求减少&lt;/td&gt;
      &lt;td&gt;价格下降 数量减少&lt;/td&gt;
      &lt;td&gt;价格下降 数量不定&lt;/td&gt;
      &lt;td&gt;价格不定 数量减少&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;结论价格如何配置资源&quot;&gt;结论：价格如何配置资源&lt;/h1&gt;

&lt;p&gt;在市场经济中，价格是配置稀缺资源的机制。对于经济中的每种物品来说，价格确保供给与需求达到平衡。均衡价格决定了买者选择购买多少这种物品，以及卖者选择生产多少这种物品。&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="economics" /><summary type="html">供给与需求是使市场经济运行的力量，它们决定了每种物品的产量及出售价格。</summary></entry><entry><title type="html">编程珠玑: 算法设计技术</title><link href="http://localhost:4000/programming-pearls-8.html" rel="alternate" type="text/html" title="编程珠玑: 算法设计技术" /><published>2022-06-19T00:00:00+08:00</published><updated>2022-06-19T00:00:00+08:00</updated><id>http://localhost:4000/programming-pearls-8</id><content type="html" xml:base="http://localhost:4000/programming-pearls-8.html">&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;：具有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 个浮点数的向量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;：输入向量的任意连续子向量的最大和。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：输入向量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 为 [31, -41, 59, 26, -53, 58, 97, -93, -23, 84]，那么该程序输出为 x[2…6] 的总和。&lt;/p&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;当所有数都是正数时，问题比较简单，此时最大子向量就是整个输入向量。&lt;/p&gt;

&lt;p&gt;当输入向量中含有负数时，是否应该包含某个负数并期望旁边的正数会弥补它呢？&lt;/p&gt;

&lt;p&gt;为了使问题定义更加完整，假设所有的输入都是负数时，最大子向量为空向量，总和为 0.&lt;/p&gt;

&lt;h2 id=&quot;on3-算法&quot;&gt;O(n^3) 算法&lt;/h2&gt;

&lt;p&gt;该问题最直接的解法是对所有满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 ≤ i ≤ j &amp;lt; n&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(i, j)&lt;/code&gt; 整数对进行迭代。对每个整数对，都需要计算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[i, j]&lt;/code&gt; 的总和，并判断此时该和是否是迄今为止最大的和。&lt;/p&gt;

&lt;p&gt;代码比较简单，但是运行速度很慢。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// sum is sum of x[i...j]&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;on2-算法&quot;&gt;O(n^2) 算法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;我们注意到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[i...j]&lt;/code&gt; 的总和与前面已经计算出的总和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[i...j-1]&lt;/code&gt; 相关，利用该关系可以得到第一个平方算法。&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 	&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// sum is sum of x[i...j]&lt;/span&gt;
 	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一种平方算法是提前计算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[0...i]&lt;/code&gt; 各个数累加的和。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cumarr[i]&lt;/code&gt; 表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[0...i]&lt;/code&gt; 中各个数的累加和，则 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[i..j]&lt;/code&gt; 的累加和可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cumarr[j] - cumarr[i-1]&lt;/code&gt; 得到。&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;cumarr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 	&lt;span class=&quot;n&quot;&gt;cumarr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cumarr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cumarr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;cumarr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// sum is sum of x[i...j]&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;分治算法onlogn&quot;&gt;分治算法：O(nlogn)&lt;/h2&gt;

&lt;p&gt;前面讨论的算法考虑了所有的子向量，并计算每个子向量中的所有数的和。由于存在 O(n^2) 个子向量，因此至少需要 O(n^2) 的运行时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分治法原理&lt;/strong&gt;：&lt;em&gt;要解决规模为 n 的问题，可以递归地解决两个规模近似为 n/2 的子问题，然后对它们的答案进行合并可以得到整个问题的答案&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;在本问题中，我们将大小为 n 的向量分解为两个大小近似的子向量 a, b，之后递归地找出 a, b 中的最大子向量 ma, mb。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;整个向量的最大子向量为 ma：子向量在 a 中&lt;/li&gt;
  &lt;li&gt;整个向量的最大子向量为 mb：子向量在 b 中&lt;/li&gt;
  &lt;li&gt;整个向量的最大子向量为 mc：子向量跨越 a, b 之间的边界&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// zero elements&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// one element&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// find max crossing to left&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lmax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;lmax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// find max crossing to right&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;rmax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;rmax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lmax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;扫描算法on&quot;&gt;扫描算法：O(n)&lt;/h2&gt;

&lt;p&gt;扫描算法是从数组的最左端（x[0]）开始扫描，一直到最右端（x[n-1]），并记下所遇到的总和最大的子向量。&lt;/p&gt;

&lt;p&gt;假设已经解决了 x[0…i-1] 的问题，如何将其扩展为包含 x[i] 的问题？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;类似分治算法原理：前 i 个元素中，最大总和的子向量要么在前 i-1 个元素中（maxsofar），要么其结束位置为 i（maxendinghere）&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt; &lt;/th&gt;
          &lt;th&gt;maxsofar&lt;/th&gt;
          &lt;th&gt; &lt;/th&gt;
          &lt;th&gt;maxendinghere&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;i&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;maxendinghere&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// maxendinghere 一开始为结束位置为 x-1 的最大子向量的和，此处将其更新为结束位置为 i 的最大子向量的和&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 如果加上 x[i] 之后仍然为正值，那么 maxendinghere 则加上 x[i]；否则将 maxendinghere 设置为 0（空向量）&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;maxendinghere&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxendinghere&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxendinghere&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;上述几个算法给出了几个重要的算法设计技术：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保存状态，避免重复计算：动态规划&lt;/li&gt;
  &lt;li&gt;分治算法&lt;/li&gt;
  &lt;li&gt;扫描算法&lt;/li&gt;
  &lt;li&gt;将信息预处理至数据结构中&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="algrithom" /><summary type="html">问题描述</summary></entry><entry><title type="html">编程珠玑: 编程小事</title><link href="http://localhost:4000/programming-pearls-5.html" rel="alternate" type="text/html" title="编程珠玑: 编程小事" /><published>2022-06-11T00:00:00+08:00</published><updated>2022-06-11T00:00:00+08:00</updated><id>http://localhost:4000/programming-pearls-5</id><content type="html" xml:base="http://localhost:4000/programming-pearls-5.html">&lt;h3 id=&quot;脚手架&quot;&gt;脚手架&lt;/h3&gt;

&lt;p&gt;使用脚手架更方便地访问函数；最简单的脚手架是命令行技术&lt;/p&gt;

&lt;h3 id=&quot;编码&quot;&gt;编码&lt;/h3&gt;

&lt;p&gt;首先使用伪代码构建程序框架，然后将伪代码翻译成要实现的语言&lt;/p&gt;

&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;在脚手架中对组件进行测试；通过脚手架对程序进行自动化测试&lt;/p&gt;

&lt;h3 id=&quot;调试&quot;&gt;调试&lt;/h3&gt;

&lt;p&gt;不管是脚手架还是真实运行环境，调试工作总是很困难的&lt;/p&gt;

&lt;h3 id=&quot;计时&quot;&gt;计时&lt;/h3&gt;

&lt;p&gt;对程序执行时间进行计时，确保程序能够达到我们预期的性能&lt;/p&gt;

&lt;h3 id=&quot;断言的艺术&quot;&gt;断言的艺术&lt;/h3&gt;

&lt;p&gt;断言既可以知道程序的代码开发，也可以用来判断程序的正确性。我们可以将断言插入代码中，以确保程序运行时的行为与我们的理解一致&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="algrithom" /><summary type="html">脚手架</summary></entry><entry><title type="html">编程珠玑: 程序性能分析</title><link href="http://localhost:4000/programming-pearls-6-copy.html" rel="alternate" type="text/html" title="编程珠玑: 程序性能分析" /><published>2022-06-11T00:00:00+08:00</published><updated>2022-06-11T00:00:00+08:00</updated><id>http://localhost:4000/programming-pearls-6%20copy</id><content type="html" xml:base="http://localhost:4000/programming-pearls-6-copy.html">&lt;h2 id=&quot;设计层面&quot;&gt;设计层面&lt;/h2&gt;

&lt;p&gt;为了提高系统性能，可以在多个层面进行设计。&lt;/p&gt;

&lt;h3 id=&quot;问题定义&quot;&gt;问题定义&lt;/h3&gt;

&lt;p&gt;良好的问题定义可以避免对问题需求的过高估计。问题定义与程序效率之间具有复杂的相互影响。&lt;/p&gt;

&lt;h3 id=&quot;系统结构&quot;&gt;系统结构&lt;/h3&gt;

&lt;p&gt;将大型系统分解成多个模块&lt;/p&gt;

&lt;h3 id=&quot;算法和数据结构&quot;&gt;算法和数据结构&lt;/h3&gt;

&lt;p&gt;对于模块性能提升的关键是表示数据的结构和操作这些数据的算法&lt;/p&gt;

&lt;h3 id=&quot;代码调优&quot;&gt;代码调优&lt;/h3&gt;

&lt;p&gt;与系统无关的代码调优&lt;/p&gt;

&lt;h3 id=&quot;系统软件&quot;&gt;系统软件&lt;/h3&gt;

&lt;p&gt;改变系统所基于的软件；同时考虑与系统相关的代码调优&lt;/p&gt;

&lt;h3 id=&quot;硬件&quot;&gt;硬件&lt;/h3&gt;

&lt;p&gt;更快的硬件可以提高系统的性能&lt;/p&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;当性能问题无法回避时，对于不同的性能目标可以从不同的设计层面进行考虑。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;如果仅需要较小的性能提升，就对效果最佳的层面进行改进&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;首先考虑所有可能的设计层面，然后选择“性价比”最高的那个：较小投入可以获得较大的加速系数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;如果需要较大的性能提升，需要对多个层面进行改进&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;需要从各个不同方向对问题进行深入研究。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="algrithom" /><summary type="html">设计层面</summary></entry><entry><title type="html">Lion 设计与实现</title><link href="http://localhost:4000/lion-design-and-implements.html" rel="alternate" type="text/html" title="Lion 设计与实现" /><published>2022-05-28T00:00:00+08:00</published><updated>2022-05-28T00:00:00+08:00</updated><id>http://localhost:4000/lion-design-and-implements</id><content type="html" xml:base="http://localhost:4000/lion-design-and-implements.html">&lt;blockquote&gt;
  &lt;p&gt;本文是在美团内部面向其他团队的分享&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h1&gt;

&lt;h2 id=&quot;1-1-功能介绍&quot;&gt;1-1 功能介绍&lt;/h2&gt;

&lt;p&gt;Lion 是一个面向分布式系统的配置中心，采用中心化数据管理，通过 C/S 架构实现配置的统一管理和实时推送。&lt;/p&gt;

&lt;p&gt;应用程序使用 Lion 可实现配置与代码分离、配置变更推送、历史版本管理、灰度发布等功能。通过集中化的在线配置管理，应用可以实现秒级配置变更，并且保证所有节点配置的最终一致性。除此之外，Lion 还提供操作日志查看、灰度发布、配置审核等高级功能。&lt;/p&gt;

&lt;h2 id=&quot;1-2-sla-指标&quot;&gt;1-2 SLA 指标&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指标&lt;/th&gt;
      &lt;th&gt;目标&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;推送成功率&lt;/td&gt;
      &lt;td&gt;99.9%&lt;/td&gt;
      &lt;td&gt;配置修改成功后（5s内）所有客户端成功获取到最新配置的比例&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;推送时效性&lt;/td&gt;
      &lt;td&gt;&amp;lt;5s&lt;/td&gt;
      &lt;td&gt;配置从修改成功到客户端获取到新配置的时间&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当配置进行一次成功变更之后，&lt;strong&gt;Lion 只能保证最终一致性&lt;/strong&gt;，即所有 Client 最终都能获取到最新配置，&lt;strong&gt;不能保证强一致性&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;1-2-服务端性能指标&quot;&gt;1-2 服务端性能指标&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指标&lt;/th&gt;
      &lt;th&gt;数据&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;单机/集群写性能(8C8G)&lt;/td&gt;
      &lt;td&gt;700QPS/2500QPS&lt;/td&gt;
      &lt;td&gt;HTTP Open API&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;单机读性能(8C8G, RT &amp;lt; 100ms)&lt;/td&gt;
      &lt;td&gt;7000QPS&lt;/td&gt;
      &lt;td&gt;HTTP Open API&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;单机最优连接数(8C/16G)&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;服务端长轮询连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;北上同步延迟（1700QPS）&lt;/td&gt;
      &lt;td&gt;TP999&amp;lt;500ms&lt;/td&gt;
      &lt;td&gt;数据在一侧数据中心发生变更后，同步到另一侧的延迟&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;2-系统设计&quot;&gt;2-系统设计&lt;/h1&gt;

&lt;h2 id=&quot;2-1-整体架构&quot;&gt;2-1 整体架构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Lion 系统采用异地多活架构：北京 &amp;amp; 上海各部署一套数据中心，支持双写，通过自研同步组件（Consistency）保证两个数据中心间数据一致性。业务配置存储主要使用 MySQL, Redis 作为存储介质（ZK 即将下线）。&lt;/p&gt;

&lt;p&gt;用户可以通过管理端（Console）与 HTTP 接口（API）进行配置变更与查询操作，同时 Lion 也支持多语言的 SDK（Java，Node，C++，Golang），便于业务服务进行配置获取与变更监听操作。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模块名称&lt;/th&gt;
      &lt;th&gt;主要功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-config&lt;/td&gt;
      &lt;td&gt;用于 client 获取配置与监听配置变更&lt;/td&gt;
      &lt;td&gt;client 与 config 使用长轮询通信; config 集群北上多机房部署，支持多集群&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-consistency&lt;/td&gt;
      &lt;td&gt;不同数据中心间数据同步; 同一数据中心，不同存储介质数据同步&lt;/td&gt;
      &lt;td&gt;北上双集群部署&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-meta&lt;/td&gt;
      &lt;td&gt;实现 config, consistency 服务发现功能 consistency 同步数据分区策略控制; 用于 client 获取相关元数据：config 节点列表，黑白名单项目等&lt;/td&gt;
      &lt;td&gt;弱依赖 mns 实现节点注册发现功能，在 mns 不可用时降级到自研健康检测策略&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-client&lt;/td&gt;
      &lt;td&gt;与 config 服务交互实现配置获取/监听功能&lt;/td&gt;
      &lt;td&gt;定时从 meta 获取可用 config 节点列表，并通过长轮询访问 config 服务端; config 服务不可用时，从本地文件获取配置（可能是过期数据）; 支持多语言 sdk: java, node, go, c++&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-api&lt;/td&gt;
      &lt;td&gt;提供 http open api：用于业务方通过 http 实现配置的变更与查询&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-console&lt;/td&gt;
      &lt;td&gt;管理端交互，提供配置增删改查功能&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;2-1-配置获取与推送&quot;&gt;2-1 配置获取与推送&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Client 在获取配置时，加载策略依次为：&lt;strong&gt;1. 内存缓存，2. Lion 远程服务端，3. 本地持久化文件&lt;/strong&gt;。在从服务端某个节点加载失败时，会及时切换到其他可用节点，直到超时；之后会降级到本地文件（可能仍是上次获取到的旧值）。&lt;/p&gt;

&lt;p&gt;Config 服务端在收到 Client 获取配置的请求后，依次从：&lt;strong&gt;1. 内存缓存，2. Redis，3. DB&lt;/strong&gt; 中加载配置。配置加载成功之后，需要比较 Client 携带的配置版本号（c_version）与服务端加载到的配置版本号（s_version）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 c_verison == 0，则说明 Client 首次获取该配置，此时直接返回服务端配置&lt;/li&gt;
  &lt;li&gt;如果 c_version != 0 且 c_version &amp;lt; s_version，则说明该配置在 Client 上次加载之后又更新过，此时需要将最新配置返回&lt;/li&gt;
  &lt;li&gt;如果 c_version != 0 且 c_version &amp;gt;= s_version，则说明 Client 本地配置已经是最新值，此时请求被 hang 住，直到该配置被更新或者请求超时（100s）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-2-一致性保障&quot;&gt;2-2 一致性保障&lt;/h2&gt;

&lt;p&gt;Lion 配置存储分为北京/上海两个数据中心，每个数据中心分别有 DB, Redis, ZK(即将下线) 。为了实现异地多活，需要保证北上数据的一致性。&lt;/p&gt;

&lt;p&gt;Lion 采取的是最终一致性，一致性保障由 Consistency 模块维护，整体可以分为两个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;不同数据中心间的一致性&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;同一数据中心内不同存储介质的一致性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-2-1-同步模型&quot;&gt;2-2-1 同步模型&lt;/h3&gt;

&lt;p&gt;为了实现数据最终一致性，lion 对每次配置变更都会记录一条 log，被称为同步日志（sync log）。该 log 模型基本如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;key&lt;/th&gt;
      &lt;th&gt;release_key&lt;/th&gt;
      &lt;th&gt;local_db_status&lt;/th&gt;
      &lt;th&gt;remote_db_status&lt;/th&gt;
      &lt;th&gt;zk_status&lt;/th&gt;
      &lt;th&gt;redis_status&lt;/th&gt;
      &lt;th&gt;status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;配置唯一标识&lt;/td&gt;
      &lt;td&gt;配置变更唯一标识&lt;/td&gt;
      &lt;td&gt;同侧 db 状态：0 未同步，1 同步成功&lt;/td&gt;
      &lt;td&gt;异地 db 状态:0 未同步，1 同步成功&lt;/td&gt;
      &lt;td&gt;同侧 zk 状态：0 未同步，1 同步成功&lt;/td&gt;
      &lt;td&gt;同侧 redis 状态:0 未同步，1 同步成功&lt;/td&gt;
      &lt;td&gt;本次变更同步状态: 0 未加载，1 已加载未同步，2 同步成功&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;status 字段用于标识同步流程是否全部成功，如果同步失败，则会重试直到同步成功。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;不管是通过 http api 接口还是管理端变更配置，只会更新同侧的 db，并不会同步更新同侧数据中心内的 zk, redis（提高接口性能）。每次配置变更产生的 log 为：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;local_db&lt;/th&gt;
      &lt;th&gt;remote_db&lt;/th&gt;
      &lt;th&gt;zk&lt;/th&gt;
      &lt;th&gt;redis&lt;/th&gt;
      &lt;th&gt;status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;2-2-2-同步流程&quot;&gt;2-2-2 同步流程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同步流程步骤分为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;log 加载&lt;/strong&gt;：将未同步完成的日志从 db 中加载到内存队列中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;异地同步&lt;/strong&gt;：优先将 log 批量同步到异地；异地同步成功后将 log hash 到内存队列中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地同步&lt;/strong&gt;：将 log 顺序同步到本地 db, redis, zk 中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;结合 log 中各个同步状态进一步分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;本地 db 同步&lt;/strong&gt;：如果本地 db 未同步，则首先同步 db。如果同步成功，则 log.local_db = 1。（对 log 产生侧来说，local_db 默认 1，即默认不同步）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;异地同步&lt;/strong&gt;：该流程为异步操作，仅仅是&lt;em&gt;将 log 发送到异地并被接收，并在稍后将配置回写到 db, redis, zk&lt;/em&gt;。如果同步成功，则 log.remote_db = 1.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地 redis 同步&lt;/strong&gt;：如果同步成功，则 log.local_redis = 1.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地 zk 同步&lt;/strong&gt;：如果同步成功，则 log.local_zk = 1.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-可用性&quot;&gt;3-可用性&lt;/h2&gt;

&lt;p&gt;承诺 Lion 服务的可用性不低于 99.99%。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模块名称&lt;/th&gt;
      &lt;th&gt;集群分布&lt;/th&gt;
      &lt;th&gt;外部依赖&lt;/th&gt;
      &lt;th&gt;内部依赖&lt;/th&gt;
      &lt;th&gt;RTO&lt;/th&gt;
      &lt;th&gt;故障时主动切换 SLA&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-consistency&lt;/td&gt;
      &lt;td&gt;两地多机房&lt;/td&gt;
      &lt;td&gt;MySQL、S3、专线（弱）、DNS（弱）&lt;/td&gt;
      &lt;td&gt;lion-meta&lt;/td&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;0s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-api&lt;/td&gt;
      &lt;td&gt;两地多机房&lt;/td&gt;
      &lt;td&gt;MySQL、S3、Redis（弱）&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;0s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-config&lt;/td&gt;
      &lt;td&gt;两地多机房&lt;/td&gt;
      &lt;td&gt;MySQL、S3、Redis（弱）&lt;/td&gt;
      &lt;td&gt;lion-meta&lt;/td&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;0s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-console&lt;/td&gt;
      &lt;td&gt;两地多机房&lt;/td&gt;
      &lt;td&gt;MySQL&lt;/td&gt;
      &lt;td&gt;lion-api&lt;/td&gt;
      &lt;td&gt;60s&lt;/td&gt;
      &lt;td&gt;0s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-meta&lt;/td&gt;
      &lt;td&gt;两地多机房&lt;/td&gt;
      &lt;td&gt;MySQL、MNS（弱）&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;60s&lt;/td&gt;
      &lt;td&gt;0s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-client&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;DNS&lt;/td&gt;
      &lt;td&gt;lion-config、lion-meta（弱）&lt;/td&gt;
      &lt;td&gt;T_{断连感知}=120s&lt;/td&gt;
      &lt;td&gt;3s (timeout)+3s * (0~N) (N:异常 Config 数目)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;config 服务北上两地多机房部署，支持弹性伸缩：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于异常 config 节点，meta 会及时剔除，保证下发给 client 节点列表的可用性&lt;/li&gt;
  &lt;li&gt;client 在请求 config 服务端获取配置时，优先访问同地域节点；同地域无可用节点时，访问异地节点&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果所有 config 节点均不可用，则降级到本地持久化文件&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;config 服务加载配置时，强依赖 db，s3(文件配置)，弱依赖 redis：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;redis 不可用时，对配置获取 &amp;amp; 推送没有影响&lt;/li&gt;
  &lt;li&gt;db，s3 不可用时，client 无法获取到最新配置（通过 config 内存缓存可以获取到旧配置）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;consistency 服务北上两地多机房部署，支持弹性伸缩：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步 log 加载强依赖 db，db 不可用时，同步任务无法执行&lt;/li&gt;
  &lt;li&gt;consistency 节点异常时，meta 会及时剔除，并更新同步策略（尽可能降低节点变更对同步延迟的影响）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-隔离性&quot;&gt;4-隔离性&lt;/h2&gt;

&lt;p&gt;配置隔离可以从两个方面来看：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;配置获取&lt;/strong&gt;：客户端通过长轮询访问 lion-config 获取目标配置&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;配置同步&lt;/strong&gt;：配置变更在北上两地/同一数据中心内保持一致&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-1-配置获取&quot;&gt;4-1 配置获取&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;config 服务支持多集群，不同集群管理特定业务配置。对于一些配置容量大/稳定性要求高的业务，会拆分出独立集群，其他业务共享默认集群。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;config 集群&lt;/th&gt;
      &lt;th&gt;集群所属项目&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;zebra&lt;/td&gt;
      &lt;td&gt;{ds, group-ds}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;buffalo&lt;/td&gt;
      &lt;td&gt;{buffalo-reader-task，buffalo-client，buffalo-writer-task}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;waf&lt;/td&gt;
      &lt;td&gt;{com.sankuai.sec.waf.manage}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;default&lt;/td&gt;
      &lt;td&gt;{others}&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;各个集群&lt;strong&gt;配置管理相互独立，业务流量隔离&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;buffalo 配置获取只会访问 buffalo 集群，同时 buffalo 集群只管理 buffalo 相关的配置&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;不过，各个 config 集群依赖的底层存储（redis, db）仍共用一个集群&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-2-配置同步&quot;&gt;4-2 配置同步&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于不同业务对推送延迟的敏感程度不同，因此我们将配置同步分为两种：1. 普通配置，2. 高优先级配置；这两种配置同步流程相互隔离。&lt;/p&gt;

&lt;p&gt;通过将不同配置的同步流程隔离，使得普通配置的堆积并不会对高优先级配置的同步流程产生影响。&lt;/p&gt;

&lt;h3 id=&quot;4-2-1-局限&quot;&gt;4-2-1 局限&lt;/h3&gt;

&lt;p&gt;不管是配置同步还是配置推送，目前都是在业务逻辑层进行隔离，在底层存储方面，所有业务共享一套存储。因此，目前针对业务隔离仍存在一定的局限性，如 db 集群异常时，所有业务方都会受到影响。&lt;/p&gt;

&lt;p&gt;不过，鉴于当前单集群存储容量在中短期内仍能支撑业务增长，并且存储层的可用性也能满足 Lion 的需求，因此短期内仍会保持现有隔离方案。&lt;/p&gt;

&lt;h2 id=&quot;5-可观测性&quot;&gt;5-可观测性&lt;/h2&gt;

&lt;h3 id=&quot;5-1-推送链路&quot;&gt;5-1 推送链路&lt;/h3&gt;

&lt;p&gt;对于每次配置变更的推送情况，Lion 提供了推送链路的功能帮助用户排查配置的推送情况，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;推动成功率，推送延迟，每台机器的推送详情等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过，该功能对 lion-client 版本有所要求（&amp;gt;=0.8.15.4），目前覆盖率 &amp;gt;80%（各版本分布情况）.&lt;/p&gt;

&lt;h3 id=&quot;5-2-数据同步&quot;&gt;5-2 数据同步&lt;/h3&gt;

&lt;p&gt;对于配置同步，有两个关键指标：1. 同步延迟，2. 同步成功率。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步延迟的大小与配置大小，配置的变更频率，同步批次大小，同步任务间隔等有关。经过测试，对于小配置（&amp;lt;1KB），在 1700 QPS 下延迟 TP999&amp;lt;500ms，最大延迟 1.8s。&lt;/li&gt;
  &lt;li&gt;通过一致性大盘可以看到，数据一致性 &amp;gt;99.99%&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-faq&quot;&gt;6-FAQ&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;业务在接入 lion 时，会按照 key 的粒度编码获取配置，如果业务方代码中获取引用了大量 key，是否会导致不同 key 每次都通过 http 访问 config 服务端是否导致耗时增大？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;如果同一个项目调用了多个 key（&amp;gt;5），那么配置获取粒度会由 key 升级为项目/分组，也就是说会从 config 服务端一次获取整个项目/分组的配置；这样当访问其他 key 时，只需要从本地内存缓存即可获取，减小了配置获取耗时。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;如果 lion 服务端均不可用，对业务方有何影响？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;从配置获取来说，在服务端完全不可用时会降级到本地持久化文件，可能会获取到已经失效的配置，并且不会感知到最新的配置变更&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;除了服务端内部一致性，如何保证客户端与服务端间的数据一致性？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;增量同步：客户端通过长轮询周期性地与服务端通信，请求信息携带了当前客户端配置的最新版本号，服务端通过比较版本号来判断客户端的配置是否过期，如果过期则更新客户端&lt;/li&gt;
      &lt;li&gt;全量同步：客户端定时全量同步本地配置，此时直接从服务端获取全量配置并更新本地过期配置&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;北上数据同步时，如何保证同一条 log 不会被重复同步?&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;log 通过 status 区分同步状态；同步任务只会加载 status = 0 的记录，确保同一条 log 不会被重复加载&lt;/li&gt;
      &lt;li&gt;log 被加载后会进行分区，保证不同 consistency 节点不会同步相同的 log&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;如何保证配置变更一定会被同步成功？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;有三种同步机制：1. log 创建后被立即同步；2. 同步失败后会进行有补扫任务进行再次同步（50次）；3. 北上定时检测机制，对于不一致的数据会重新触发同步流程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;北上同步时，如何解决数据冲突？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;冲突解决方式为：最后写胜出（lrw），以最新版本为主。不过，两地同时写入的概率较低。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;在上海侧的一次变更，需要多长时间才能推送到北京侧业务机器?&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;北上同步延迟 TP999 &amp;lt; 500ms，我们承诺 99.9% 的配置会在 5s 内会全量推送到所有机器（具体每次配置变更推送延迟可以查看：Lion 推送链路）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;7-未来规划&quot;&gt;7-未来规划&lt;/h1&gt;

&lt;p&gt;中短期来看，Lion 规划主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提升用户体验：丰富多语言客户端功能，提升MWS易用性&lt;/li&gt;
  &lt;li&gt;提升系统可观测性：增强配置链路跟踪能力，提升监控能力，&lt;/li&gt;
  &lt;li&gt;提升容灾能力&lt;/li&gt;
  &lt;li&gt;提升系统效率：对齐业界同类系统，提高系统支撑能力、提升系统效率&lt;/li&gt;
  &lt;li&gt;提升平台化能力：增强存储及流量隔离，增强集群监控、运营统计，开放集群拆分&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">本文是在美团内部面向其他团队的分享</summary></entry><entry><title type="html">Linux Kernel: The Virtual Filesystem</title><link href="http://localhost:4000/linux-kernel-virtual-filesystem.html" rel="alternate" type="text/html" title="Linux Kernel: The Virtual Filesystem" /><published>2022-05-21T00:00:00+08:00</published><updated>2022-05-21T00:00:00+08:00</updated><id>http://localhost:4000/linux-kernel-virtual-filesystem</id><content type="html" xml:base="http://localhost:4000/linux-kernel-virtual-filesystem.html">&lt;p&gt;通过所谓的&lt;strong&gt;虚拟文件系统&lt;/strong&gt;的概念，Linux 系统能够支持多种文件系统类型。虚拟文件系统所隐含的思想是把表示多种不同类型的文件系统的共同信息存放在内核中，对文件系统的读写调用，内核都能将其替换成支持本地 Linux 文件系统或者其他文件系统的实际函数。&lt;/p&gt;

&lt;h1 id=&quot;1-虚拟文件系统的作用&quot;&gt;1-虚拟文件系统的作用&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;虚拟文件系统&lt;/strong&gt;（Virtual FileSystem）也被称为&lt;strong&gt;&lt;em&gt;虚拟文件系统转换&lt;/em&gt;&lt;/strong&gt;（Virtual FileSystem Switch），是一个&lt;strong&gt;&lt;em&gt;内核软件层&lt;/em&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;em&gt;用来处理与 Unix 标准文件系统相关的所有系统调用&lt;/em&gt;&lt;/strong&gt;；能够为各个文件系统提供一个通用的接口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VFS 是用户程序与文件系统实现之间的抽象层&lt;/strong&gt;。例如用户输入以下 shell 命令&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# /floppy 是 ms-dos 文件系统，而 /tmp 是 ext2 文件系统&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; /floppy/test /tmp/test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cp&lt;/code&gt; 程序并不需要操作目录的具体文件系统类型，相反，cp 程序与 VFS 交互。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;a 描述了 VFS 的层次，b 表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cp&lt;/code&gt; 应用程序的实现&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;VFS 支持的文件系统可以划分为三种类型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;磁盘文件系统&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;用于管理本地磁盘分区。比较知名的基于磁盘的文件系统有：Linux 使用的文件系统，Unix 家族文件系统，微软公司文件系统等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;网络文件系统&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这些文件系统允许访问属于其他网络计算机的文件系统所包含的文件，常见的有 NFS，Coda，AFS 等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;特殊文件系统&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这些文件系统不管理本地或者远程磁盘空间。如 /proc 文件系统就是一种典型的特殊文件系统&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Unix 目录简易了一棵根目录为 ’/’ 的树，根目录包含在&lt;em&gt;根文件系统&lt;/em&gt;（root filesystem）中。在 Linux 中，&lt;em&gt;根文件系统通常为 Ext2 or Ext3 类型，其他所有的文件系统都可以被“安装”在跟文件系统的子目录中&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当一个文件系统被安装在某个目录上时，在父文件系统中的目录内容不再是可访问的&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-1-通用文件模型&quot;&gt;1-1 通用文件模型&lt;/h2&gt;

&lt;p&gt;VFS 的主要思想在于引入了一个&lt;strong&gt;通用的文件模型&lt;/strong&gt;（common file model），该模型能够表示所有支持的文件系统。&lt;/p&gt;

&lt;p&gt;对于每个具体的文件系统，需要将其物理组织结构转换为虚拟文件系统的通用文件模型。Linux 内核对于每个文件操作必须使用一个指针，指向要访问的具体文件系统的适当函数。&lt;/p&gt;

&lt;p&gt;通用文件模型由以下对象类型组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;超级块对象&lt;/strong&gt;（superblock object）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;用于存放已安装文件系统的有关信息&lt;/em&gt;。对于基于磁盘的文件系统，该类对象通常对应于存放在磁盘上的文件系统控制块（filesystem control block）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;索引节点对象&lt;/strong&gt;（inode object）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;用于存放具体文件的一般信息&lt;/em&gt;。对于基于磁盘的文件系统，该类对象通常对应于存放在磁盘上的文件控制块（file control block）。&lt;em&gt;每个索引节点对象都有一个索引节点号，该索引节点号唯一标识文件系统中的文件&lt;/em&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;文件对象&lt;/strong&gt;（file object）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;用于存放打开的文件与进程之间进行交互的有关信息&lt;/em&gt;。这类信息仅当进程访问文件期间存在于内核内存中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;目录项对象&lt;/strong&gt;（dentry object）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;用于存放目录项（也就是文件的特地名称）与对应文件进行链接的有关信息&lt;/em&gt;。每个磁盘文件系统都以自己的方式将该类信息存放在磁盘上。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下图简单说明进程怎样与文件进行交互：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;三个不同的进程打开同一个文件，其中两个进程使用硬链接&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;每个进程都有自己的文件对象，但是只需要两个目录项对象（每个硬链接对应一个目录项对象）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;这两个目录项对象指向同一个索引节点对象&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;该索引节点对象标识超级块对象以及普通的磁盘文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了提高系统性能，最近最常用的目录项对象被存放在&lt;strong&gt;&lt;em&gt;目录项高速缓存&lt;/em&gt;&lt;/strong&gt;（dentry cache）的磁盘高速缓存（disk cache）中，以提高从文件路径名到最后一个路径分量的索引节点的转换效率。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般来说，磁盘高速缓存属于软机制，允许内核将原本存放在磁盘上的某些信息保存在 RAM 中，以加速对这些数据的访问&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-2-vfs-所处理的系统调用&quot;&gt;1-2 VFS 所处理的系统调用&lt;/h2&gt;

&lt;p&gt;下图列出了 VFS 处理的系统调用，涉及文件系统，普通文件，目录文件，符号链接文件等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;VFS 属于内核层，处理应用程序的系统调用&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select() poll()&lt;/code&gt;：等待一组文件描述符上发生的事情&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read() write() readv() writev() sendfile()&lt;/code&gt;：进行文件 IO 操作&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap() mmap2()&lt;/code&gt;：处理文件内存映射&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;VFS 是应用程序与具体文件系统之间的一层。不过，&lt;strong&gt;&lt;em&gt;在某些情况下一个文件操作可能由 VFS 本身执行，不需要调用底层函数&lt;/em&gt;&lt;/strong&gt;。例如，当进程关闭打开的文件时，并不需要涉及磁盘上相应文件，因此 VFS 只需要释放对应的文件对象即可。&lt;/p&gt;

&lt;p&gt;从某种意义上来说，VFS 可以被看作普通的文件系统，在必要时依赖某种具体的文件系统。&lt;/p&gt;

&lt;h1 id=&quot;2-vfs-的数据结构&quot;&gt;2-VFS 的数据结构&lt;/h1&gt;

&lt;p&gt;每个 VFS 对象都存放在一个适当的数据结构中，包括对象的属性和&lt;em&gt;指向对象方法表&lt;/em&gt;的指针。&lt;/p&gt;

&lt;h2 id=&quot;2-1-超级块对象&quot;&gt;2-1 超级块对象&lt;/h2&gt;

&lt;p&gt;超级块对象由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super_block&lt;/code&gt; 结构组成，部分字段如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有的超级块对象都以双向循环链表的形式链接在一起。链表的第一个元素用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super_blocks&lt;/code&gt; 变量表示，超级块对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s_list&lt;/code&gt; 字段存放指向链表相邻元素的指针。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sb_lock&lt;/code&gt; 自旋锁用于避免链表被多个处理器系统同时访问。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s_fs_info&lt;/code&gt; 字段指向属于具体文件系统的超级块信息。任何基于磁盘的文件系统都需要访问和更新自己的磁盘分配位图，以便分配或释放磁盘块。为了提高效率，由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s_fs_info&lt;/code&gt; 字段所指向的数据被复制到内存，VFS 允许这些文件系统直接对内存超级块的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s_fs_info&lt;/code&gt; 字段进行操作，无需访问磁盘。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不过这种方法可能会导致 VFS 超级块与磁盘上的超级块不同步，因此通过引入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s_dirt&lt;/code&gt; 标志来表示该超级块是否是脏的，以便及时更新磁盘上的数据。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Linux 通过周期性地将所有脏的超级块回写磁盘来减少不一致的风险&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;超级块的操作方法由数据结构 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super_operations&lt;/code&gt; 结构表示，该结构的起始地址存放在超级块的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s_op&lt;/code&gt; 字段中&lt;/p&gt;

    &lt;p&gt;每一个具体的文件系统可以定义自己的超级块操作。当 VFS 需要调用其中一个操作时，如 read_inode()，执行操作如下：&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_op&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_inode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
  &lt;span class=&quot;c1&quot;&gt;// sb 存放涉及的超级块对象地址；super_operation 表的 read_inode 字段存放对应函数的地址&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-1-1-超级块操作方法&quot;&gt;2-1-1 超级块操作方法&lt;/h3&gt;

&lt;p&gt;超级块操作表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super_operation&lt;/code&gt; 中一些比较常见的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alloc_inode(sb)&lt;/code&gt;：为索引节点对象分配空间，包括具体文件系统的数据所需空间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destroy_inode(inode)&lt;/code&gt;: 撤销索引节点对象，包括具体文件系统的数据&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_inode(inode)&lt;/code&gt;: 用磁盘上的数据填充以参数传递过来的索引节点对象的字段&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;索引节点对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_ino&lt;/code&gt; 字段标识从磁盘上要读取的具体文件系统的索引节点&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty_inode(inode)&lt;/code&gt;: 当索引节点被修改时调用&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_inode(inode)&lt;/code&gt;: 通过传递参数指定的索引节点对象内容更新一个文件系统的索引节点&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;索引节点对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_ino&lt;/code&gt; 字段标识所涉及的磁盘上文件系统的索引节点&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put_inode(inode)&lt;/code&gt;: 释放索引节点时调用，同时减少该节点引用计数器值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;drop_inode(inode)&lt;/code&gt;: 当最后一个用户释放该索引节点时调用；该索引节点将会被撤消&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete_inode(inode)&lt;/code&gt;: 撤消索引节点时调用；删除内存中的 VFS 索引节点和磁盘上的文件数据及元数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-2-索引节点对象&quot;&gt;2-2 索引节点对象&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;文件系统处理文件所需要的所有信息都存放在一个名为索引节点的数据结构中&lt;/strong&gt;。内存中的索引节点对象由一个 inode 数据结构组成。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;文件名可以随意更改，但是&lt;strong&gt;&lt;em&gt;对文件来说，索引节点时唯一的，并且随着文件的存在而存在&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_hash&lt;/code&gt;: 用于散列表的指针&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_list&lt;/code&gt;: 用于描述索引节点当前状态的链表的指针&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_sb_list&lt;/code&gt;: 用于超级块的索引节点链表的指针&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_dentry&lt;/code&gt;: 引用索引节点的目录项对象链表的头&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_ino&lt;/code&gt;: 索引节点号&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_count&lt;/code&gt;: 引用计数器&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_nlink&lt;/code&gt;: 硬链接数目&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_state&lt;/code&gt;: 索引节点的状态标志
    &lt;ul&gt;
      &lt;li&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_state&lt;/code&gt; 的值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I_DIRTY_SYNC&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I_DIRTY_DATASYNC&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I_DIRTY_PAGES&lt;/code&gt; ，则表明该索引节点是脏的，对应的磁盘索引节点必须更新&lt;/li&gt;
      &lt;li&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_state&lt;/code&gt; 字段的值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I_LOCK&lt;/code&gt;，表明对应的索引节点对象处于 IO 传输中；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I_FREEING&lt;/code&gt; 表示索引节点对象正在被释放；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I_CLEAR&lt;/code&gt; 表示索引节点对象的内容不再有意义；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I_NEW&lt;/code&gt; 表示索引节点对象已经分配，但是还没用磁盘索引节点读取来的数据填充&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_size&lt;/code&gt;: 文件的字节数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_blocks&lt;/code&gt;: 文件的块数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_op&lt;/code&gt;: 索引节点的操作&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_sb&lt;/code&gt;: 指向超级块对象的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;每个索引节点对象都会复制磁盘索引节点包含的一些数据&lt;/em&gt;&lt;/strong&gt;，如分配给文件的磁盘块数。&lt;/p&gt;

&lt;p&gt;每个索引节点对象总是处于下列双向循环链表中的某个链表中（链表相邻元素的指针存放在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_list&lt;/code&gt; 字段中）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;有效未使用的索引节点链表&lt;/strong&gt;：这些索引节点当前未被任何进程使用，且不为脏，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_count&lt;/code&gt; 字段为 0；链表首尾元素由变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode_unused&lt;/code&gt; 引用。该链表用作磁盘高速缓存。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;正在使用的索引节点链表&lt;/strong&gt;：这些索引节点当前正在被某些进程使用，且不为脏，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_count&lt;/code&gt; 字段为正数；链表的首尾元素由变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode_in_use&lt;/code&gt; 引用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;脏索引节点的链表&lt;/strong&gt;：链表的首尾元素由相应的超级块对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s_dirty&lt;/code&gt; 字段引用。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;这些链表都是通过适当索引节点对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_list&lt;/code&gt; 字段链接在一起&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;每个索引节点对象也包含在文件系统(per-filesystem)的双向循环链表中，链表的头存放在超级块对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s_inodes&lt;/code&gt; 字段中；索引节点对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_sb_list&lt;/code&gt; 字段存放了指向链表相邻元素的指针。&lt;/p&gt;

&lt;p&gt;索引节点对象也存放在一个被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode_hashtable&lt;/code&gt; 的散列表中。散链表加快了对索引节点的搜索。&lt;/p&gt;

&lt;h3 id=&quot;2-2-1-索引节点操作方法&quot;&gt;2-2-1 索引节点操作方法&lt;/h3&gt;

&lt;p&gt;与索引节点对象关联的方法也被称为&lt;strong&gt;索引节点操作&lt;/strong&gt;，由 &lt;strong&gt;inode_operation&lt;/strong&gt; 结构来表示，存放在索引节点对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_op&lt;/code&gt; 字段中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create(dir, dentry, mode, nameidata)&lt;/code&gt;: 在某一目录下，为目录项对象相关的普通文件创建一个新的磁盘索引节点&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookup(dir, dentry, nameidata)&lt;/code&gt;: 为包含在一个目录项对象中的文件名对应的索引节点查找目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;link(old_dentry, dir, new_dentry)&lt;/code&gt;: 创建一个名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new_dentry&lt;/code&gt; 的新的硬链接，指向 dir 目录下名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;old_dentry&lt;/code&gt; 的文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlink(dir, dentry)&lt;/code&gt;: 从一个目录中删除目录项对象所指定文件的硬链接&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;symlink(dir, dentry, mode)&lt;/code&gt;: 在某个目录下，为与目录项对象相关的目录创建一个新的索引节点&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mkdir(dir, dentry, mode)&lt;/code&gt;: 在某个目录下，为与目录项对象相关的目录创建一个新的索引节点&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmdir(dir, dentry)&lt;/code&gt;: 从一个目录删除子目录，子目录的名称包含在目录项对象中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-3-文件对象&quot;&gt;2-3 文件对象&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;文件对象描述进程如何与一个打开的文件进行交互&lt;/strong&gt;。文件对象是在文件被打开时创建的，由一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file&lt;/code&gt; 结构表示。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;文件对象在磁盘上没有对应的映像&lt;/em&gt;，因此 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file&lt;/code&gt; 结构中没有设置 dirty 字段来表示文件对象是否被修改&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;存放在文件对象中的主要信息是&lt;strong&gt;&lt;em&gt;文件指针&lt;/em&gt;&lt;/strong&gt;，即文件当前的位置，下个操作将在该位置执行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;由于几个进程可能同时访问同一文件，因此文件指针必须存放在文件对象而不是索引节点对象中&lt;/em&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;文件对象通过一个名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filp&lt;/code&gt; 的 slab 高速缓存分配，可分配的文件对象数目存在上限，因此&lt;strong&gt;&lt;em&gt;系统可同时访问的文件数目也存在上限&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;正在使用中的文件对象包含在具体文件系统的超级块的链表中，每个超级块对象把文件对象链表的头存放在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s_files&lt;/code&gt; 字段中。因此，属于不同文件系统的文件对象包含在不同的链表中。文件对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_list&lt;/code&gt; 字段用于指向链表的前后元素。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_count&lt;/code&gt; 字段为引用计数器，用于记录使用文件对象的进程数。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当内核本身使用该文件对象时，也需要增加计数器的值&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当 VFS 代表进程必须打开一个文件时，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_empty_filp()&lt;/code&gt; 函数分配一个新的文件对象。该函数调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmem_cache_alloc()&lt;/code&gt; 从 filp 高速缓存中获得一个空闲的文件对象，之后初始化该对象的字段。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;INIT_LIST_HEAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_ep_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;spin_lock_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_ep_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;atomic_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_uid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fsuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_gid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fsgid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RW_LOCK_UNLOCKED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;INIT_LIST_HEAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_maxcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之前说过，每个文件系统都有其自己的文件操作集合，用于执行文件读写等操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当内核将一个索引节点从磁盘装入内存时，就会把指向这些文件操作的指针存放在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_operatrions&lt;/code&gt; 结构中，而该结构的地址存放在索引节点对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_fop&lt;/code&gt; 字段中。&lt;/li&gt;
  &lt;li&gt;当进程打开文件时，VFS 就用存放在索引节点中的这个地址初始化新文件对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_op&lt;/code&gt; 字段，使得后续对该文件的操作能够调用这些函数。&lt;/li&gt;
  &lt;li&gt;如果有需要，VFS 随后可以通过在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_op&lt;/code&gt; 字段存放一个新值来修改文件操作的集合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-3-1-文件对象操作方法&quot;&gt;2-3-1 文件对象操作方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llseek(file, offset, origin)&lt;/code&gt;: 更新文件指针&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read(file, fuf, count, offset)&lt;/code&gt;: 从文件的 offset 处开始读取 count 个字节，然后增加 offset 的值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aio_read(req, buf, len, pos)&lt;/code&gt;: 异步 IO 读取操作&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write(file, buf, count, offset)&lt;/code&gt;: 从文件的 offset 处开始写入 count 个字节，然后增加 offset 的值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aio_write(req, buf, len, pos)&lt;/code&gt;: 异步 IO 写入操作&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap(file, vma)&lt;/code&gt;: 执行文件的内存映射，并将映射放入进程的地址空间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open(inode, file)&lt;/code&gt;: 通过创建一个新的文件对象来打开一个文件，并将其连接到对应的索引节点对象&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flush(file)&lt;/code&gt;: 当打开的文件引用被关闭时调用&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsync(file, dentry, flag)&lt;/code&gt;: 将文件所缓存的全部数据写入磁盘&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aio_fsync(req, flag)&lt;/code&gt;: 异步 IO 刷新操作&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock(file, cmd, file_lock)&lt;/code&gt;: 对 file 文件申请一个锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-4-目录项对象&quot;&gt;2-4 目录项对象&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;VFS 把每个目录看作由若干子目录和文件组成的一个普通文件&lt;/strong&gt;。当一个目录项被读入内存，VFS 就会将其转换成基于 dentry 结构的一个目录项对象。&lt;/p&gt;

&lt;p&gt;对于进程查找的路径名中的每个分量，内核都会为其创建一个目录项对象。&lt;strong&gt;&lt;em&gt;目录项对象将每个路径分量与其对应的索引节点联系起来&lt;/em&gt;&lt;/strong&gt;。如在查找路径名 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/tmp/test&lt;/code&gt; 时，内核为根目录 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt; 创建一个目录项对象，为根目录下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tmp&lt;/code&gt; 项创建一个第二级目录项对象，为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/tmp&lt;/code&gt; 目录下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt; 项创建一个第三级目录项对象。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;与文件对象一样，目录项对象在磁盘上也没有对应的映像，因此 dentry 结构不包含指出该对象已被修改的字段&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;目录项对象存放名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dentry_cache&lt;/code&gt; 的 slab 高速缓存中；目录项对象的创建和删除是通过调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmem_cache_alloc()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kmem_cache_free()&lt;/code&gt; 实现的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_count&lt;/code&gt;: 目录项对象的引用计数器&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_flag&lt;/code&gt;: 目录项高速缓存标志&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_inode&lt;/code&gt;: 与文件名关联的索引节点&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_parent&lt;/code&gt;: 父目录的目录项对象&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_child&lt;/code&gt;: 对目录而言，用于同一父目录中的目录项链表的指针&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_subdirs&lt;/code&gt;: 对目录而言，子目录项链表的头&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_name&lt;/code&gt;: 文件名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个目录项对西那个可以处于以下四种状态之一：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空闲状态&lt;/strong&gt;（free）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;该状态的目录项对象不包含有效信息，且还没被 VFS 使用&lt;/em&gt;。对应的内存区由 slab 分配器进行分配&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;未使用状态&lt;/strong&gt;（unused）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;该状态的目录项对象还没被内核使用&lt;/em&gt;。引用计数器 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_count&lt;/code&gt; 值为 0，但是其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_inode&lt;/code&gt; 字段指向关联的索引节点。目录项对象包含有效的信息，但是为了在必要时回收内存，对应内容可能会被丢失。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;正在使用状态&lt;/strong&gt;（in use）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;该状态的目录项对象正在被内核使用&lt;/em&gt;。引用计数器 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_count&lt;/code&gt; 值为正数，其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_inode&lt;/code&gt; 字段指向关联的索引节点对象。目录项对象包含有效的信息，且不能被丢弃。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;负状态&lt;/strong&gt;（negative）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;与目录项关联的索引节点不存在&lt;/em&gt;，可能是因为&lt;em&gt;相应的磁盘节点已经被删除&lt;/em&gt;，或者是因为&lt;em&gt;目录项对象是通过解析一个不存在文件的路径名创建的&lt;/em&gt;。目录项对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_inode&lt;/code&gt; 字段为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;，但是该对象仍被保存在目录项高速缓存中，以便后续对同一个文件目录名的查找操作能快速完成。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-4-1-目录项对象操作方法&quot;&gt;2-4-1 目录项对象操作方法&lt;/h3&gt;

&lt;p&gt;与目录项对象关联的方法称为&lt;strong&gt;目录项操作&lt;/strong&gt;，由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dentry_operation&lt;/code&gt; 结构表示，该结构的地址存放在目录项对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_op&lt;/code&gt; 字段中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_revalidate(dentry, nameidata)&lt;/code&gt;: 把目录项对象转换为一个文件路径名之前，判断该目录项对象是否仍然有效。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_delete(dentry)&lt;/code&gt;: 当对目录项对象的最后一个引用被删除时，调用该方法。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_release(dentry)&lt;/code&gt;: 当要释放一个目录项对象时（放入 slab 分配器），调用该方法。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_iput(dentry, ino)&lt;/code&gt;: 当一个目录项对象变为负状态使调用（即丢弃对应的索引节点）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-5-目录项高速缓存&quot;&gt;2-5 目录项高速缓存&lt;/h2&gt;

&lt;p&gt;由于从磁盘读入一个目录项并构造相应的目录项对象需要花费一定的时间，因此在完成对目录项对象的操作之后，并不会立即丢弃，而是将其保留在内存中。为了最大限度地提高处理这些目录项对象的效率，Linux 使用&lt;strong&gt;目录项高速缓存&lt;/strong&gt;，该缓存由两种类型的数据结构组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;一个处于正在使用，未使用或负状态的目录项对象的集合&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;所有未使用的目录项对象存放在一个“最近最少使用（LRU）”的双向链表中&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;正在使用的目录项对象被保存在一个双向链表中，该链表由索引对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_dentry&lt;/code&gt; 字段引用；目录项对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_alias&lt;/code&gt; 字段存放链表中相邻元素的地址&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;&lt;em&gt;每个索引节点对象可能与多个硬链接关联&lt;/em&gt;，因此需要一个链表&lt;/p&gt;

        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;当指向文件的最后一个硬链接被删除之后，一个正在被使用的目录项对象可能变成负状态。此时，该目录项对象被移动到未使用目录项对象组成的 LRU 链表中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;一个能够快速获取与给定的文件名和目录名对应的目录项对象的散列表&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果目标目录项对象不存在缓存中，那么散列函数范围空值&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;散列表是由数组实现，数组中的每个元素是一个指向链表的指针。目录项对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d_hash&lt;/code&gt; 字段包含指向具有相同散列值的链表中的相邻元素&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目录项高速缓存还相当于&lt;strong&gt;索引节点高速缓存&lt;/strong&gt;（inode cache）的控制器。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在内核内存中，不会丢弃与未使用目录项相关的索引节点，因此这些索引节点对象仍保存在 RAM 中，并且能够通过相应的目录项快速引用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dcache_lock&lt;/code&gt; 自旋锁用于保护目录项高速缓存数据结构避免被多个处理器同时访问。&lt;/p&gt;

&lt;h2 id=&quot;2-6-与进程相关的文件&quot;&gt;2-6 与进程相关的文件&lt;/h2&gt;

&lt;p&gt;之前提到，&lt;em&gt;每个进程都有自己当前的工作目录与根目录&lt;/em&gt;，这仅仅是进程与文件系统交互所必须维护的数据中的两个例子。类型 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_struct&lt;/code&gt; 数据结构维护了&lt;strong&gt;进程与文件系统交互所需要的数据&lt;/strong&gt;；&lt;em&gt;每个进程描述符的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs&lt;/code&gt; 字段指向该结构&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;: 共享这个表的进程个数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock&lt;/code&gt;: 用于表中字段的读写自旋锁&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;: 根目录的目录项&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pwd&lt;/code&gt;: 当前工作目录的目录项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_struct&lt;/code&gt;，还有另一个结构 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;files_struct&lt;/code&gt;，用于表示进程当前打开的文件。&lt;em&gt;进程描述符的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;files&lt;/code&gt; 字段存放了该表的地址&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt;: 指向文件对象的指针数组；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max_fds&lt;/code&gt;: 指向该数组的长度&lt;/li&gt;
  &lt;li&gt;通常，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt; 字段指向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;files_struct&lt;/code&gt; 结构的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd_array&lt;/code&gt; 字段，该字段包含 32 个文件对象指针。如果进程打开的文件数大于 32，内核就分配一个新的，更大的文件指针数组，并将地址存放在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt; 字段中，内核同时更新 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max_fds&lt;/code&gt; 字段的值&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt; 数组中有元素的每个文件来说，&lt;strong&gt;数组的索引就是文件描述符（file descriptor）&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt; 数组的&lt;em&gt;第一个元素（index = 0）通常是进程的标准输入文件&lt;/em&gt;，&lt;em&gt;第二个元素（index = 1）是进程的标准输出文件，第三个元素（index = 2）是进程的标准错误文件&lt;/em&gt;。如下图所示：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Unix 进程将文件描述符作为主文件标识符。&lt;em&gt;两个文件描述符可以指向同一个打开的文件&lt;/em&gt;，即数组中的两个元素可能指向同一个文件对象。&lt;/li&gt;
  &lt;li&gt;进程不能使用多于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NR_OPEN&lt;/code&gt;（一般为 1048576）个文件描述符。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open_fds&lt;/code&gt;: 指向打开文件描述符的指针。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open_fds_init&lt;/code&gt;: 文件描述符的初始集合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;使用文件对象&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当内核开始使用一个文件对象时，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fget()&lt;/code&gt; 函数：这个函数接收文件描述符 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt; 作为参数，返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;current→files→fd[fd]&lt;/code&gt; 中的地址，即对应文件对象的地址；同时使文件对象引用计数器 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_count&lt;/code&gt; 值 +1。如果没有文件与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt; 对应，则 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fget()&lt;/code&gt; 返回 NULL。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;释放文件对象&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当内核完成对文件对象的使用后，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fput()&lt;/code&gt; 函数：该函数将文件对象的地址作为参数，并减少文件对象引用计数器 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_count&lt;/code&gt; 的值。如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_count&lt;/code&gt; 的值变成 0，则该该函数调用文件操作的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release&lt;/code&gt; 方法，减少索引节点对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_write count&lt;/code&gt; 字段的值，并将文件对象从超级块链表中移除，释放文件对象给 slab 分配器，最后减少相关的文件系统描述符的目录项对象的引用计数器的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-文件系统类型&quot;&gt;3-文件系统类型&lt;/h1&gt;

&lt;p&gt;Linux 内核支持多种不同的文件系统。有一些特殊的文件系统在 Linux 内核设计中具有重要作用。&lt;/p&gt;

&lt;h2 id=&quot;3-1-特殊文件系统&quot;&gt;3-1 特殊文件系统&lt;/h2&gt;

&lt;p&gt;当网络和磁盘文件系统能够使用户处理存放在内核之外的信息时，特殊文件系统可以为系统管理员和程序员提供一种容易的方式来&lt;strong&gt;&lt;em&gt;操作内核的数据结构并实现操作系统的特殊特征&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;特殊文件系统提供给系统管理员使用，网络和磁盘文件系统提供给普通用户使用&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;常用的特殊文件系统如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意，有几个文件系统没有固定的安装点&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bdedv&lt;/code&gt; 块设备；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pipefs&lt;/code&gt; 管道；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; IPC 共享线性区；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sockfs&lt;/code&gt; 套接字；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;usbfs&lt;/code&gt; USB 设备；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tmpfs&lt;/code&gt; 临时文件（如果不被交换出去就保持在 RAM 中）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;特殊文件系统不局限于物理块设备&lt;/strong&gt;。不过，内核给每个安装的特殊文件系统分配一个虚拟的块设备，其主设备号为 0，次设备号具有任意值（不同特殊文件系统的值不同）。&lt;/p&gt;

&lt;h2 id=&quot;3-2-文件系统类型注册&quot;&gt;3-2 文件系统类型注册&lt;/h2&gt;

&lt;p&gt;VFS 需要对代码已经在内核中的所有文件系统的类型进行跟踪，需要进行文件系统类型注册来实现。&lt;/p&gt;

&lt;p&gt;每个注册的文件系统使用类型为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_system_type&lt;/code&gt; 对象来表示，该对象结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所有文件系统类型的对象都插入到一个单向链表中，该链表由自旋锁保护避免同时访问。&lt;/p&gt;

&lt;p&gt;在系统初始化期间，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register_filesystem()&lt;/code&gt; 函数来注册编译时指定的每个文件系统；该函数把相应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_system_type&lt;/code&gt; 对象插入到文件系统类型的链表中。&lt;/p&gt;

&lt;h1 id=&quot;4-文件系统处理&quot;&gt;4-文件系统处理&lt;/h1&gt;

&lt;p&gt;与其他 Unix 系统一样，Linux 也使用系统的&lt;strong&gt;根文件系统（system’s root filesystem）&lt;/strong&gt;：&lt;em&gt;由内核在引导阶段直接安装，并拥有系统初始化脚本及最基本的系统程序&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;其他文件系统要么由初始化脚本安装，要么由用户直接安装在已经安装的文件系统的目录上。&lt;/p&gt;

&lt;p&gt;作为一个目录树，每个文件系统都拥有自己的根目录（root directory）。安装文件系统的目录称之为&lt;strong&gt;安装点（mount point）&lt;/strong&gt;。&lt;strong&gt;&lt;em&gt;对于已经安装的文件系统属于安装点目录的一个子文件系统&lt;/em&gt;&lt;/strong&gt;，如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc&lt;/code&gt; 虚拟文件系统是系统的根文件系统的子文件系统。&lt;/p&gt;

&lt;h2 id=&quot;4-1-命名空间&quot;&gt;4-1 命名空间&lt;/h2&gt;

&lt;p&gt;在 Linux 中，每个进程可以拥有自己的已安装文件系统树，被称为进程的&lt;strong&gt;命名空间&lt;/strong&gt;（namespace）。通常大多数进程共享同一个命名空间，即位于系统的根文件系统且被 init 进程使用的已安装的文件系统树。&lt;/p&gt;

&lt;h1 id=&quot;5-路径名查找&quot;&gt;5-路径名查找&lt;/h1&gt;

&lt;p&gt;当进程需要识别一个文件时，就将文件路径名传递给某个 VFS 系统调用（如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mkdir()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rename()&lt;/code&gt; 等），VFS 会将路径名导出对应的索引节点。&lt;/p&gt;

&lt;p&gt;路径名查找的标准流程是&lt;strong&gt;分析路径名并把它拆分成一个文件名序列，除了最后一个文件名以外，其余所有文件名肯定都是目录&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果路径名的第一个字符是 “/”，则该路径名是绝对路径，需要从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;current→fs→root&lt;/code&gt;（进程根目录）所标识的目录开始搜索&lt;/li&gt;
  &lt;li&gt;否则，该路径名是相对路径，需要从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;current→fs→pwd&lt;/code&gt;（进程当前目录）所标识的目录开始搜索&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在对初始目录的索引节点进行处理时，需要检查与第一个名字&lt;strong&gt;匹配的目录项，获得相应的索引节点&lt;/strong&gt;；之后，&lt;strong&gt;从磁盘读取包含那个索引节点的目录文件&lt;/strong&gt;，并检查与第二个名字匹配的目录项，以获得相应的索引节点。对包含在路径中的每个名字，该过程反复执行。&lt;/p&gt;

&lt;p&gt;目录项高速缓存能够加速上述解析流程，因为最近最常使用的目录项对象保被缓存在内存中，每个&lt;strong&gt;目录项对象使得特定目录中的一个文件名与它相应的索引节点联系起来&lt;/strong&gt;。因此，可以避免在路径分析过程中从磁盘读取中间目录。&lt;/p&gt;

&lt;p&gt;路径名查找由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path_look_up()&lt;/code&gt; 函数执行，接收三个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;: 指向要解析的文件路径名的指针&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flags&lt;/code&gt;: 标志，表示将会如何访问查找到的文件&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nd&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nameidata&lt;/code&gt; 数据结构的地址，存放了查找操作的结果&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path_lookup()&lt;/code&gt; 返回时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nd&lt;/code&gt; 指向的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nameidata&lt;/code&gt; 结构用与路径名查找操作有关的数据填充&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nameidata&lt;/code&gt; 结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dentry&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mnt&lt;/code&gt; 分别指向所解析的&lt;strong&gt;&lt;em&gt;最后一个路径分量的目录项对象和已经安装文件系统对象&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这两个字段表示给定的路径文件&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flags&lt;/code&gt; 字段的取值有：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="Operating-System" /><summary type="html">通过所谓的虚拟文件系统的概念，Linux 系统能够支持多种文件系统类型。虚拟文件系统所隐含的思想是把表示多种不同类型的文件系统的共同信息存放在内核中，对文件系统的读写调用，内核都能将其替换成支持本地 Linux 文件系统或者其他文件系统的实际函数。</summary></entry><entry><title type="html">Linux Kernel: Signals</title><link href="http://localhost:4000/linux-kernel-signals.html" rel="alternate" type="text/html" title="Linux Kernel: Signals" /><published>2022-04-23T00:00:00+08:00</published><updated>2022-04-23T00:00:00+08:00</updated><id>http://localhost:4000/linux-kernel-signals</id><content type="html" xml:base="http://localhost:4000/linux-kernel-signals.html">&lt;p&gt;信号最早在 Unix 系统中被引入，&lt;strong&gt;用于在用户态进程间通信；内核也用信号通知进程系统所发生的事件&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&quot;1-信号的作用&quot;&gt;1-信号的作用&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;信号（signal）&lt;/strong&gt;是很短的消息，&lt;strong&gt;可以被发送到一个进程或者一组进程&lt;/strong&gt;。发送给进程的唯一信息通常是一个数，以此来标识信号。&lt;/p&gt;

&lt;p&gt;使用信号有两个目的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;让进程知道已经发生了一个特定的事件&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;强迫进程执行其自己代码中的信号处理程序&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;这两个目的并不互斥&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是 Linux 中前 31 个&lt;strong&gt;常规信号（regular signal）&lt;/strong&gt;。除了常规信号，POSIX 标准还引入了新的信号，被称为&lt;strong&gt;实时信号（real-time signal）&lt;/strong&gt;：在 Linux 中的编码范围为 32~64。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实时信号必须排队以便发送的多个信号能够被接收到&lt;/li&gt;
  &lt;li&gt;同种类型的常规信号并不排队：如果一个常规信号被连续发送多次，那么只有其中一个信号能够发送到接收进程&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux 内核并不使用实时信号，但还是通过几个特定的系统调用完全实现了 POSIX 标准&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;许多系统调用允许应用进程发送信号，并决定应用进程如何响应所接收到的信号&lt;/strong&gt;。下图是一些与信号相关的重要系统调用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;信号的一个比较重要的特点：&lt;strong&gt;信号可以随时被发送给状态不可预知的进程&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;发送给非运行进程的信号必须由内核保存，直到进程恢复执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阻塞一个信号要求信号的传递拖延，直到阻塞解除&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;使得信号产生一段时间之后才能对其传递这一问题变得更加严重&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内核将信号传递分为两个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;信号产生&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;内核更新目标进程的数据结构以表示一个新信号已被发送&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;信号传递&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;内核强迫目标进程对信号做出反应：要么&lt;em&gt;改变目标进程的执行状态&lt;/em&gt;，要么&lt;em&gt;开始执行一个特定的信号处理程序&lt;/em&gt;，要么两者都是&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;每个产生的信号至多被传递一次&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;信号是可消费资源，一旦已经被传递出去，那么进程描述符中有关这个信号的所有信息都被取消&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;挂起信号（pending signal）&lt;/strong&gt;：已经产生但还没有被传递的信号。&lt;em&gt;任何时候，一个进程仅存在给定类型的一个挂起信号，同一进程同种类型的其他信号不会被排队，只是简单地丢弃&lt;/em&gt;。但是，实时信号有所不同：同种类型的挂起信号可以有多个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;挂起信号（pending signal）&lt;/strong&gt;：已经产生但还没有被传递的信号。&lt;em&gt;任何时候，一个进程仅存在给定类型的一个挂起信号，同一进程同种类型的其他信号不会被排队，只是简单地丢弃&lt;/em&gt;。但是，实时信号有所不同：同种类型的挂起信号可以有多个。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;信号可以保留不可预知的挂起时间&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;为了实现信号，内核需要做到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;记住每个进程阻塞哪些信号&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当从内核态切换到用户态时，对每一个进程都需要检查是否有一个信号已到达&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;几乎发生在每个定时中断中（每毫秒）&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;确定是否可以忽略信号：当且仅当以下条件都满足时可以忽略信号：
    &lt;ul&gt;
      &lt;li&gt;目标进程没有被另一个进程跟踪&lt;/li&gt;
      &lt;li&gt;信号没有被目标进程阻塞&lt;/li&gt;
      &lt;li&gt;信号被目标进程忽略&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;处理信号：信号可能在进程运行期间的任意时刻请求把进程切换到一个信号处理函数，并在该函数返回后恢复原来执行的上下文&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-1-传递信号之前的操作&quot;&gt;1-1 传递信号之前的操作&lt;/h2&gt;

&lt;p&gt;进程可以对信号做出如下应答：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;显示地忽略信号&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;执行与信号相关的缺省操作&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;由内核定义的缺省操作有：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Terminate&lt;/em&gt;&lt;/strong&gt;：进程被终止（kill）&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Dump&lt;/em&gt;&lt;/strong&gt;：进程被终止，并且如何可能的话，创建包含进程执行上下文的核心转储文件&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Ignore&lt;/em&gt;&lt;/strong&gt;：信号被忽略&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Stop&lt;/em&gt;&lt;/strong&gt;：进程被停止，将进程设置为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TASK_STOPPED&lt;/code&gt; 状态&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Continue&lt;/em&gt;&lt;/strong&gt;：如果进程被停止（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TASK_STOPPED&lt;/code&gt;），则将其设置为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TASK_RUNNING&lt;/code&gt; 状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;通过调用相应的信号处理函数捕获信号&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意的是，对信号的阻塞与忽略是不同的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果信号被阻塞，则不会被传递，直到信号解除阻塞之后才传递该信号&lt;/li&gt;
  &lt;li&gt;被忽略的信号总是被传递，只不过没有进一步的操作而已&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; &amp;amp; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt; 信号不可以被显示地忽略，捕获或者阻塞，通常必须执行它们的缺省操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;允许有适当特权的用户通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt; 终止并停止任何进程（除了进程 0 &amp;amp; 1），不管程序采取怎样的防御措施&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-2-posix-信号与多线程应用&quot;&gt;1-2 POSIX 信号与多线程应用&lt;/h2&gt;

&lt;p&gt;POSIX 标准对多线程应用的信号处理有一些严格的要求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;信号处理程序必须在多线程应用的所有线程之间共享&lt;/li&gt;
  &lt;li&gt;每个发送给多线程应用的信号仅传送给一个线程，这个线程是由内核在从不会阻塞该信号的线程中任意挑选的&lt;/li&gt;
  &lt;li&gt;如果向多线程应用发送一个致命信号，那么内核将杀死该应用的所有线程，而不仅仅是杀死接收信号的那个线程&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了实现 POSIX 标准，Linux 把多线程应用实现为一组属于同一个线程组的轻量级进程&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果一个挂起信号被发送给某个特定进程，那么这个信号是私有的；如果发送给整个进程组，则其是共享的。&lt;/p&gt;

&lt;h2 id=&quot;1-3-与信号相关的数据结构&quot;&gt;1-3 与信号相关的数据结构&lt;/h2&gt;

&lt;p&gt;与信号相关的数据结构如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;task_struct: 进程描述符&lt;/li&gt;
  &lt;li&gt;signal_sturct: 信号描述符&lt;/li&gt;
  &lt;li&gt;sighand_struct: 信号处理程序描述符&lt;/li&gt;
  &lt;li&gt;shared_pending: 共享挂起信号队列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中进程描述符中与信号处理相关的字段如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pending: 私有挂起信号队列&lt;/li&gt;
  &lt;li&gt;signal: 信号描述符指针&lt;/li&gt;
  &lt;li&gt;block: 存放进程当前所屏蔽的信号&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-3-1-信号描述符与信号处理程序描述符&quot;&gt;1-3-1 信号描述符与信号处理程序描述符&lt;/h3&gt;

&lt;p&gt;进程描述符的 signal 字段指向&lt;strong&gt;信号描述符（signal descriptor）&lt;/strong&gt;：用来跟踪共享挂起信号。&lt;/p&gt;

&lt;p&gt;信号描述符被属于同一线程组的所有进程共享，即被调用 clone() 系统调用创建的所有进程共享。&lt;/p&gt;

&lt;p&gt;信号描述符中的相关字段：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了信号描述符，每个进程还引用一个&lt;strong&gt;信号处理程序描述符（signal handler descroptor）&lt;/strong&gt;：用来描述每个信号必须怎样被线程组处理。&lt;/p&gt;

&lt;p&gt;信号处理程序描述符相关字段：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 POSIX 多线程应用中，&lt;strong&gt;线程组中的所有轻量级进程都引用相同的信号描述符与信号处理程序描述符&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1-3-2-挂起信号队列&quot;&gt;1-3-2 挂起信号队列&lt;/h3&gt;

&lt;p&gt;为了跟踪进程当前的挂起信号，内核把两个挂起信号队列与每个进程相关联：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;共享挂起信号队列&lt;/strong&gt;：&lt;em&gt;&lt;strong&gt;信号描述符&lt;/strong&gt;的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shared_pending&lt;/code&gt; 字段，存放整个&lt;strong&gt;进程组&lt;/strong&gt;的挂起信号&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;私有挂起信号队列&lt;/strong&gt;：&lt;em&gt;&lt;strong&gt;进程描述符&lt;/strong&gt;的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pending&lt;/code&gt; 字段，存放&lt;strong&gt;特定进程&lt;/strong&gt;（轻量级进程）的挂起信号&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;挂起信号队列由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigpending&lt;/code&gt; 数据结构组成：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigpending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 包含 sigqueue 数据结构的双向链表头&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;sigset_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 指定挂起信号的位掩码&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 结构如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;siginfo_t&lt;/code&gt; 字段存放特定信号的信息，其中包含：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;si_signo&lt;/code&gt;: 信号编号&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;si_errno&lt;/code&gt;: 引起信号产生指令的出错码&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;si_code&lt;/code&gt;: 信号发送者代码&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;上图是比较重要的信号发送者代码：SI_KERNEL 一般内核函数；SI_TIMER 定时器到期；SI_ASYNCIO 异步 IO 完成。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2-产生信号&quot;&gt;2-产生信号&lt;/h1&gt;

&lt;p&gt;很多内核函数都会产生信号：完成信号处理的第一步，即&lt;strong&gt;根据需要更新一个或者多个进程的描述符&lt;/strong&gt;。但是，&lt;strong&gt;&lt;em&gt;并不直接执行第二步信号的传递操作，而是可能根据信号的类型和目标进程的状态唤醒一些进程，并促使这些进程接收信号&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当发送给&lt;em&gt;某个进程&lt;/em&gt;信号时，该信号可能来自内核，可能来自另一个进程。内核通过对以下内核函数调用而产生信号：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上述所有内核函数在结束时都调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;specific_send_sig_info()&lt;/code&gt; 函数&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;同样，发送给&lt;em&gt;整个进程组&lt;/em&gt;时，该信号可能来自内核，也可能来自另一个进程。内核通过调用为线程组产生信号的内核函数产生这类信号：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-1-specific_send_sig_info-函数&quot;&gt;2-1 specific_send_sig_info() 函数&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;specific_send_sig_info()&lt;/code&gt; 函数用于向指定进程发送信号，主要参数有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sig&lt;/code&gt;：信号编号&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;info&lt;/code&gt;：要么是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;siginfo_t&lt;/code&gt; 表的地址，要么是三个特殊值中的一个
    &lt;ul&gt;
      &lt;li&gt;0：信号是由用户态进程发送的&lt;/li&gt;
      &lt;li&gt;1： 信号是由内核发送的&lt;/li&gt;
      &lt;li&gt;2： 由内核发送的 SIGSTOP or SIGKILL 信号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;：指向目标进程描述符的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该函数执行以下步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查进程是否忽略信号。当以下条件全部满足时，信号就会被忽略：
    &lt;ul&gt;
      &lt;li&gt;进程没有被跟踪（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t→ptrace&lt;/code&gt;）&lt;/li&gt;
      &lt;li&gt;信号没有被阻塞&lt;/li&gt;
      &lt;li&gt;显示忽略信号（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t→singhand→action[sig-1]&lt;/code&gt;），或者隐含地忽略信号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;检查信号是否是非实时的（sig&amp;lt;32），并且进程的私有挂起信号队列上是否已经有另一个相同的挂起信号，如果存在，则不需要做任何事，直接返回 0&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send_signal()&lt;/code&gt; 函数把该信号添加到进程的（私有）挂起信号集合中&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send_signal()&lt;/code&gt; 函数成功调用，并且信号不被阻塞，则调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal_wake_up()&lt;/code&gt; 函数通知进程有新的挂起信号&lt;/li&gt;
  &lt;li&gt;函数返回，此时已成功产生信号&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-2-signal_wake_up-函数&quot;&gt;2-2 signal_wake_up() 函数&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal_wake_up()&lt;/code&gt; 函数执行以下步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t→thread_info→flags&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIF_SIGPENDING&lt;/code&gt; 标志置位&lt;/li&gt;
  &lt;li&gt;如果进程处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TASK_INTERUPTIBLE&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TASK_STOPPED&lt;/code&gt; 状态，而且信号是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt;，则调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_to_wake_up()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_to_wake_up()&lt;/code&gt; 返回 0，则说明进程是可运行的。此时，会检查进程是否在另一个 CPU 上运行，则向那个 CPU 发送一个处理器间中断，以强制当前进程的重新调度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;因为从调度函数返回时，每个进程都检查是否存在挂起信号，因此处理器间中断保证了目标进程能够很快注意到新的挂起信号&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;2-3-send_signal-函数&quot;&gt;2-3 send_signal() 函数&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send_signal()&lt;/code&gt; 函数在挂起信号队列中插入一个新元素。函数执行步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;info&lt;/code&gt; 的值是 2，则该信号是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt;，此时内核强制执行与这些信号相关的操作，不需要把信号添加到挂起队列中（流程结束）&lt;/li&gt;
  &lt;li&gt;递增进程拥有者挂起信号的数量&lt;/li&gt;
  &lt;li&gt;在挂起信号队列 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signals&lt;/code&gt; 增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 数据结构&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 结构中填充 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;siginfo_t&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;把队列位掩码中与信号相对应的位置为 1&lt;/li&gt;
  &lt;li&gt;如果第 5 步成功，则说明信号已经被成功追加到挂起信号队列中；如果失败，则不再向信号挂起队列中增加元素，可能是有太多的挂起信号，或者没有可以分配给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 数据结构的空闲空间，或者信号已经由内核强制立即发送&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有些情况，即使挂起队列没有空间存放相应挂起信号，目标进程也要能接收信号；如内核必须保证 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill()&lt;/code&gt; 系统调用能够成功执行。&lt;/p&gt;

&lt;h2 id=&quot;2-4-group_send_sig_info-函数&quot;&gt;2-4 group_send_sig_info() 函数&lt;/h2&gt;

&lt;p&gt;该函数用于向整个进程组发送信号。&lt;/p&gt;

&lt;h1 id=&quot;3-传递信号&quot;&gt;3-传递信号&lt;/h1&gt;

&lt;p&gt;假设内核已经注意到信号的到来，并调用上述函数为接收此信号的进程准备相关信息。但是，如果该进程此时并没有在 CPU 上运行，内核则会延迟传递信号的任务。那么，为了确保进程的挂起信号能够被处理，内核应该如何操作？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;内核在允许进程恢复用户态下的执行之前，检查进程 TIF_SIGPENDING 标志。每当内核处理完一个中断或者异常时，就检查是否存在挂起信号&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内核调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_signal()&lt;/code&gt; 函数处理非阻塞的信号（通常是在 CPU 要返回到用户态时才调用该函数）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_signal()&lt;/code&gt; 函数重复调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dequeue_signal()&lt;/code&gt; 函数，直到私有挂起队列与共享挂起信号队列中都没有非阻塞的挂起信号时，循环结束&lt;/li&gt;
  &lt;li&gt;对于要处理的信号可以执行三种操作：忽略信号，执行缺省操作，执行信号处理程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-1-执行信号的缺省操作&quot;&gt;3-1 执行信号的缺省操作&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;对于缺省操作为 Ignore 的信号直接忽略&lt;/li&gt;
  &lt;li&gt;对于缺省操作为 Stop 的信号可能停止线程组中的所有进程：把进程状态都置为 TASK_STOPPED，并调用 schedule() 函数&lt;/li&gt;
  &lt;li&gt;缺省操作为 Dump 的信号会在进程的工作目录中创建一个转储文件&lt;/li&gt;
  &lt;li&gt;缺省操作为 Terminate 的信号会 kill 线程组&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-2-捕获信号&quot;&gt;3-2 捕获信号&lt;/h2&gt;

&lt;p&gt;如果信号有一个专门的处理程序，那么 do_signal() 函数必须强迫该处理程序执行。&lt;/p&gt;

&lt;p&gt;信号处理程序是用户态进程定义的函数，并包含在用户态的代码段中。do_signal() 函数运行在内核态，而信号处理程序运行在用户态。针对这种情况，Linux 采用的方法是&lt;strong&gt;把保存在内核态堆栈中的硬件上下文拷贝到当前进程的用户态堆栈中&lt;/strong&gt;。&lt;strong&gt;用户态进程在信号处理程序终止时，自动调用 sigreturn() 系统调用将硬件上下文拷贝回内核态堆栈中，并恢复用户态堆栈中原来的内容&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;捕获信号的执行流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个非阻塞信号发送给进程&lt;/li&gt;
  &lt;li&gt;当中断或者异常发生时，内核切换到内核态，在返回到用户态前，内核执行 do_signal() 函数，该函数依次处理信号和建立用户态堆栈&lt;/li&gt;
  &lt;li&gt;当进程切换回用户态时，开始执行信号处理程序&lt;/li&gt;
  &lt;li&gt;处理程序终止时，调用 sigreturn() 系统调用，恢复内核态与用户态堆栈信息&lt;/li&gt;
  &lt;li&gt;系统调用结束时，用户态进程恢复正常执行&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-与信号处理相关的系统调用&quot;&gt;4-与信号处理相关的系统调用&lt;/h1&gt;

&lt;p&gt;用户态进程可以发送和接收信号，可以通过一些系统调用来完成。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill()&lt;/code&gt;：能够发送任何信号&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tkill()&lt;/code&gt; &amp;amp; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tgkill()&lt;/code&gt;：向线程组中指定进程发送信号&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigpending()&lt;/code&gt;：允许进程检查挂起的阻塞信号集合&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigsuspend()&lt;/code&gt;：把进程置为 TASK_INTERRUPTIBLE 状态&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="Operating-System" /><summary type="html">信号最早在 Unix 系统中被引入，用于在用户态进程间通信；内核也用信号通知进程系统所发生的事件。</summary></entry><entry><title type="html">Linux Kernel: System Calls</title><link href="http://localhost:4000/linux-kernel-system-calls.html" rel="alternate" type="text/html" title="Linux Kernel: System Calls" /><published>2022-04-21T00:00:00+08:00</published><updated>2022-04-21T00:00:00+08:00</updated><id>http://localhost:4000/linux-kernel-system-calls</id><content type="html" xml:base="http://localhost:4000/linux-kernel-system-calls.html">&lt;p&gt;操作系统为用户态进程与硬件设备（如 CPU，磁盘，打印机等）进行交互提供了一组接口。这种方式有以下优点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编程更加容易：用户不需要学习底层硬件设备编程&lt;/li&gt;
  &lt;li&gt;提高了系统安全性：内核在满足某个请求之前，可以检查该请求的正确性&lt;/li&gt;
  &lt;li&gt;使程序更具可移植性：只要内核提供的接口相同，那么在任意内核上都可以正确编译 &amp;amp; 执行程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Unix 系统通过向内核发出系统调用（system call）实现了用户态进程与硬件设备之间的大部分接口。&lt;/p&gt;

&lt;h1 id=&quot;1-posix-api-与系统调用&quot;&gt;1-POSIX API 与系统调用&lt;/h1&gt;

&lt;p&gt;API 只是一个函数定义，说明了如何获得一个给定的服务；而&lt;strong&gt;系统调用是通过软中断向内核态发出一个明确的请求&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;libc 标准库定义的一些 API 引用了封装例程（wrapper routine），封装例程的目的就是为了发布系统调用。通常，&lt;strong&gt;每个系统调用对应一个封装例程，而封装例程定义了应用程序使用的 API&lt;/strong&gt;。但是反过来，&lt;strong&gt;一个 API 没必要对应一个特定的系统调用&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;API 可能直接提供用户态的服务；一个 API 实现可能调用多个系统调用；不同的 API 可能调用了同一个系统调用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;POSIX API 标准只是针对 API，而不针对系统调用。从用户角度来看，API 与系统调用没有差别（可能函数名，参数等有所不同）；而从内核开发者的角度看，&lt;em&gt;系统调用属于内核，而用户态的库函数不属于内核&lt;/em&gt;。&lt;/p&gt;

&lt;h1 id=&quot;2-系统调用处理程序及服务例程&quot;&gt;2-系统调用处理程序及服务例程&lt;/h1&gt;

&lt;p&gt;当用户态进程调用一个系统调用时，CPU 切换到内核态并开始执行一个内核函数；而系统调用最终会跳转到&lt;strong&gt;系统调用处理程序（system call handler）&lt;/strong&gt;的汇编语言语言函数。&lt;/p&gt;

&lt;p&gt;每个系统调用都被一个&lt;strong&gt;系统调用号（system call number）&lt;/strong&gt;标识，因此进程在进行系统调用时需要传递该参数以识别所需的系统调用。&lt;/p&gt;

&lt;p&gt;系统调用处理程序与其他异常处理程序的结构类似，执行以下操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;在内核态保存大多数寄存器的内容&lt;/strong&gt;（汇编语言编写，所有系统调用通用操作）&lt;/li&gt;
  &lt;li&gt;调用名为&lt;strong&gt;系统调用服务例程（system call service routine）&lt;/strong&gt;的相应 C 函数来&lt;strong&gt;处理系统调用&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;退出系统调用处理程序：&lt;strong&gt;用保存在内核栈中的值加载寄存器&lt;/strong&gt;，CPU 从内核态切换回用户态（汇编语言实现，所有系统调用通用操作）&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般来说，xyz() 系统调用对应的系统调用服务例程的名字通常为 sys_xyz()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_10/lk_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图展示了应用程序，封装例程，系统调用处理程序，系统调用服务例程之间的调用关系。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYSCALL&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYSEXIT&lt;/code&gt; 是汇编语言指令，分别把 CPU 从用户态切换到内核态和从内核态切换到用户态。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;内核中有一个&lt;strong&gt;系统调用分派表（dispatch table）&lt;/strong&gt;用于将系统调用号与相应的服务例程关联起来。&lt;/p&gt;

&lt;h1 id=&quot;3-进入和退出系统调用&quot;&gt;3-进入和退出系统调用&lt;/h1&gt;

&lt;p&gt;用户态进程有两种方式调用系统调用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int $0x80&lt;/code&gt; 汇编指令&lt;/li&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter&lt;/code&gt; 汇编指令&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内核也有两种方式从系统调用退出，从而使 CPU 切回用户态：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iret&lt;/code&gt; 汇编指令&lt;/li&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysexit&lt;/code&gt; 汇编指令&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-1-通过-int-0x80-指令发出系统调用&quot;&gt;3-1 通过 int $0x80 指令发出系统调用&lt;/h2&gt;

&lt;p&gt;当用户态进程发出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int $0x80&lt;/code&gt; 指令时，CPU 切换到内核态并开始从地址 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call&lt;/code&gt; 处（如上图）开始执行指令。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call()&lt;/code&gt; 函数首先将系统调用号与所有可能用到的 CPU 寄存器保存到相应的栈中&lt;/li&gt;
  &lt;li&gt;该函数在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebx&lt;/code&gt; 中存放当前进程的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info&lt;/code&gt; 数据结构的地址&lt;/li&gt;
  &lt;li&gt;检查 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info&lt;/code&gt; 结构中的相关字段&lt;/li&gt;
  &lt;li&gt;对用户态进程传入的系统调用号进行有效性判断&lt;/li&gt;
  &lt;li&gt;调用系统调用号对应的服务例程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当系统调用服务例程结束时，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call()&lt;/code&gt; 从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eax&lt;/code&gt; 寄存器获得服务例程的返回值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call()&lt;/code&gt; 关闭本地中断并检查当前进程的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info&lt;/code&gt; 结构中的相关标志（为了在返回用户态之前处理相关工作）&lt;/li&gt;
  &lt;li&gt;跳转到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restore_all&lt;/code&gt; 标记处恢复保存在内核栈中的寄存器的值，并执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iret&lt;/code&gt; 汇编指令开始重新执行用户态进程&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-2-通过-sysenter-指令发出系统调用&quot;&gt;3-2 通过 sysenter 指令发出系统调用&lt;/h2&gt;

&lt;p&gt;汇编指令 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 需要执行几个一致性与安全检查，速度相对较慢；而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter&lt;/code&gt; 指令被称为快速系统调用，提供了一种从用户态快速切换到内核态的方法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;标准库中的封装例程把系统调用号装入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eax&lt;/code&gt; 寄存器，并调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__kernel_vsyscall()&lt;/code&gt; 函数&lt;/li&gt;
  &lt;li&gt;函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__kernel_vsyscall()&lt;/code&gt; 把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp, edx, ecx&lt;/code&gt; 内容保存到用户态堆栈中（系统调用处理程序将使用这些寄存器），同时把用户栈指针拷贝到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp&lt;/code&gt; 中，之后执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter&lt;/code&gt; 指令&lt;/li&gt;
  &lt;li&gt;CPU 从用户态切换到内核态，内核开始执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter_entry()&lt;/code&gt; 函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当系统调用服务例程结束时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter_entry()&lt;/code&gt; 函数执行与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call()&lt;/code&gt; 函数相同的操作。&lt;/p&gt;

&lt;h1 id=&quot;4-参数传递&quot;&gt;4-参数传递&lt;/h1&gt;

&lt;p&gt;与普通函数类似，系统调用也需要传参，可能是实际的值，可能是用户态进程地址空间的变量。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每个系统调用至少包含系统调用号参数&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;普通函数的传参是把参数值写入程序栈（用户态或者内核态）实现的；而系统调用是一种横跨内核态与用户态的特殊函数，所以既不能使用用户态栈，也不能使用内核态栈。&lt;strong&gt;在发出系统调用之前，系统调用参数被写入 CPU 寄存器，之后在调用系统调用服务例程之前，内核再把存放在 CPU 中的参数拷贝到内核态堆栈中&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为什么不直接将参数从用户态栈拷贝到内核态栈？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同时操作两个栈比较复杂&lt;/li&gt;
  &lt;li&gt;寄存器的使用使得系统调用处理程序的结构与其他异常处理程序的结构类似&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了使用寄存器传递参数，对参数有些限制：参数长度不能超过寄存器的长度（32 位）；参数不能超过 6 个。&lt;/p&gt;

&lt;p&gt;用于存放系统调用号与系统调用参数的寄存器分别为：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eax&lt;/code&gt;(系统调用号),  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebx, ecx, edx, esi, ebp&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter_entry()&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call()&lt;/code&gt; 会把这些寄存器的值保存在内核堆栈中。&lt;/p&gt;

&lt;h2 id=&quot;4-1-验证参数&quot;&gt;4-1 验证参数&lt;/h2&gt;

&lt;p&gt;在内核满足用户请求之前，需要检查所有系统调用参数。尤其对于表示地址的参数，内核必须检查该地址是否在进程的地址空间之内：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;验证该线性地址是否属于进程的地址空间&lt;/li&gt;
  &lt;li&gt;验证该线性地址是否小于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PAGE_OFFSET&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-2-访问进程地址空间&quot;&gt;4-2 访问进程地址空间&lt;/h2&gt;

&lt;p&gt;系统调用服务例程需要频繁读写进程地址空间的数据。Linux 通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_user()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put_user()&lt;/code&gt; 宏来使得访问更加容易：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_user()&lt;/code&gt;: 从一个地址读取 1, 2 或 4 个连续字节&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put_user()&lt;/code&gt;: 把这几种大小的内容写入一个地址中&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5-内核封装例程&quot;&gt;5-内核封装例程&lt;/h1&gt;

&lt;p&gt;尽管系统调用主要由用户态进程使用，但是也可以被内核线程调用，内核线程不能使用库函数（库函数属于用户态）。为了简化相应封装例程的声明，LInux 定义了 7 个从 _syscall0 到 _syscall6 的一组宏，每个宏对应着系统调用所用的参数个数。&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="Operating-System" /><summary type="html">操作系统为用户态进程与硬件设备（如 CPU，磁盘，打印机等）进行交互提供了一组接口。这种方式有以下优点：</summary></entry><entry><title type="html">非谓语动词</title><link href="http://localhost:4000/non-predicate-verb.html" rel="alternate" type="text/html" title="非谓语动词" /><published>2022-04-04T00:00:00+08:00</published><updated>2022-04-04T00:00:00+08:00</updated><id>http://localhost:4000/non-predicate-verb</id><content type="html" xml:base="http://localhost:4000/non-predicate-verb.html">&lt;h1 id=&quot;1-什么是非谓语动词&quot;&gt;1-什么是非谓语动词&lt;/h1&gt;
&lt;h2 id=&quot;1-1-介绍&quot;&gt;1-1-介绍&lt;/h2&gt;

&lt;p&gt;非谓语动词，又叫非限定动词。非谓语动词是指在句子中不是谓语的动词，主要包括&lt;strong&gt;&lt;em&gt;不定式、动名词和分词（现在分词和过去分词）&lt;/em&gt;&lt;/strong&gt;，即动词的非谓语形式。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;动名词与现在分词虽然表现形式相同，但是起到的作用是有所区别的。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;动名词只具有名词词性，在句子中做主语或者宾语。现在分词具有动词词性（与 be 动词连用补足），形容词词性（作定语），副词词性（作状语）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;非谓语动词除了不能独立作谓语外，可以承担句子的其他成分。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;非谓语动词中需要记住的口诀：&lt;strong&gt;&lt;em&gt;主动进行现在分词，被动完成过去分词，不定式表将来&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;需要注意的是，非谓语动词本身不能表示现在，过去，和将来。&lt;strong&gt;&lt;em&gt;非谓语动词表示进行，将来和完成时是相对于谓语动作来说的&lt;/em&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;和谓语动作同时发生表示进行&lt;/li&gt;
  &lt;li&gt;发生在谓语动作之后表示将来&lt;/li&gt;
  &lt;li&gt;发生在谓语动作之前表示完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-1-不定式&quot;&gt;1-1-1 不定式&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;基本形式&lt;/th&gt;
      &lt;th&gt;被动式&lt;/th&gt;
      &lt;th&gt;进行式&lt;/th&gt;
      &lt;th&gt;完成式&lt;/th&gt;
      &lt;th&gt;完成被动式&lt;/th&gt;
      &lt;th&gt;完成进行式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;to do&lt;/td&gt;
      &lt;td&gt;to be done&lt;/td&gt;
      &lt;td&gt;to be doing&lt;/td&gt;
      &lt;td&gt;to have done&lt;/td&gt;
      &lt;td&gt;to have been done&lt;/td&gt;
      &lt;td&gt;to have been doing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示主动，并且一般表示将来&lt;/td&gt;
      &lt;td&gt;表示被动，并且一般表示将来&lt;/td&gt;
      &lt;td&gt;表示主动和进行&lt;/td&gt;
      &lt;td&gt;表示主动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成进行&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;The teacher told us to do morning exercises.(to do)&lt;/li&gt;
  &lt;li&gt;The car to be bought is for his sister. (to be done)&lt;/li&gt;
  &lt;li&gt;She pretended to be reading when the teacher came into the classroom. (to be doing)&lt;/li&gt;
  &lt;li&gt;The thief is said to have escaped. (to have done)&lt;/li&gt;
  &lt;li&gt;The thief is said to have been arrested. (to have been done)&lt;/li&gt;
  &lt;li&gt;She is said to have been working in the factory over the last 20 years. (to have been doing)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-2-动名词&quot;&gt;1-1-2 动名词&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;基本形式&lt;/th&gt;
      &lt;th&gt;被动式&lt;/th&gt;
      &lt;th&gt;完成式&lt;/th&gt;
      &lt;th&gt;完成被动式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;doing&lt;/td&gt;
      &lt;td&gt;being done&lt;/td&gt;
      &lt;td&gt;having done&lt;/td&gt;
      &lt;td&gt;having been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示主动&lt;/td&gt;
      &lt;td&gt;表示被动&lt;/td&gt;
      &lt;td&gt;表示主动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Travelling in space by ordinary people will be common in the future. (doing)&lt;/li&gt;
  &lt;li&gt;Freddy and his band could go nowhere without being followed by their fans. (being done)&lt;/li&gt;
  &lt;li&gt;I have no idea of his having done such a thing against you. (having done)&lt;/li&gt;
  &lt;li&gt;Many customers complain of having been given short weight at that shop. (having been done)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-3-现在分词&quot;&gt;1-1-3 现在分词&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;基本形式&lt;/th&gt;
      &lt;th&gt;被动式&lt;/th&gt;
      &lt;th&gt;完成式&lt;/th&gt;
      &lt;th&gt;完成被动式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;doing&lt;/td&gt;
      &lt;td&gt;being done&lt;/td&gt;
      &lt;td&gt;having done&lt;/td&gt;
      &lt;td&gt;having been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示主动和进行&lt;/td&gt;
      &lt;td&gt;表示被动和进行&lt;/td&gt;
      &lt;td&gt;表示主动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;He sat there，reading a newspaper. (doing)&lt;/li&gt;
  &lt;li&gt;The area being studied may be rich in coal. (being done)&lt;/li&gt;
  &lt;li&gt;Having finished my homework，I began to watch TV. (having done)&lt;/li&gt;
  &lt;li&gt;Having been told many times，she still can’t remember it. (having been done)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-4-过去分词&quot;&gt;1-1-4 过去分词&lt;/h3&gt;

&lt;p&gt;过去分词只有一种形式：done.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;及物动词的过去分词作表语，&lt;strong&gt;&lt;em&gt;与句子的主语是被动关系&lt;/em&gt;&lt;/strong&gt;，表示主语的状态。既表示被动，又强调已完成。
    &lt;ul&gt;
      &lt;li&gt;The cup is broken.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不及物动词的过去分词作表语，&lt;strong&gt;&lt;em&gt;与句子的主语是主动关系&lt;/em&gt;&lt;/strong&gt;，表示主语的状态，同样强调动作的完成。
    &lt;ul&gt;
      &lt;li&gt;He is retired.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;2-动词不定式&quot;&gt;2-动词不定式&lt;/h1&gt;
&lt;h2 id=&quot;2-1-介绍&quot;&gt;2-1-介绍&lt;/h2&gt;

&lt;p&gt;动词不定式是一种非谓语动词形式，其结构为 &lt;strong&gt;to do&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中 to 不是介词，而是动词不定式的符号，称为小品词&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;动词不定式没有人称和数的变化，但有时态和语态的变化。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;动词不定式和其后面的名词等构成不定式短语&lt;/em&gt;，在句子中可以&lt;strong&gt;用作主语、表语、宾语、定语、状语、补足语、独立成分或与疑问词等连用&lt;/strong&gt; 。&lt;/p&gt;

&lt;h2 id=&quot;2-2-时态--语态&quot;&gt;2-2-时态 &amp;amp; 语态&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;不定式&lt;/th&gt;
      &lt;th&gt;主动语态&lt;/th&gt;
      &lt;th&gt;被动语态&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;一般式&lt;/td&gt;
      &lt;td&gt;to do&lt;/td&gt;
      &lt;td&gt;to be done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;进行式&lt;/td&gt;
      &lt;td&gt;to be doing&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成式&lt;/td&gt;
      &lt;td&gt;to have done&lt;/td&gt;
      &lt;td&gt;to have been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成进行式&lt;/td&gt;
      &lt;td&gt;to have been doing&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;They pretended not to see us.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;不定式的一般式表示与谓语动词动作 &lt;strong&gt;&lt;em&gt;几乎同时发生&lt;/em&gt;&lt;/strong&gt; 或者 &lt;strong&gt;&lt;em&gt;发生在谓语动词动作之后&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;He pretended to be sleeping.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;不定式的进行式表示&lt;strong&gt;&lt;em&gt;在谓语动词动作发生的同时,不定式的动作也正在进行&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;She pretended to have known it before.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;完成式表示不定式动作&lt;strong&gt;&lt;em&gt;发生在谓语动作之前&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’re happy to have been working with you.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;完成进行式表示&lt;strong&gt;&lt;em&gt;谓语动作发生之前,不定式的动作一直在进行而且可能之后也继续&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-3-用法&quot;&gt;2-3-用法&lt;/h2&gt;

&lt;h3 id=&quot;2-3-1-主语&quot;&gt;2-3-1 主语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;To be a doctor is hard. &lt;/li&gt;
  &lt;li&gt;To learn English well is not easy.  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;单个不定式作主语时，谓语动词用单数&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;动词不定式（短语）作主语时，为了避免句子的头重脚轻，可以&lt;strong&gt;用 “it” 作形式主语，而把真正的主语即动词不定式（短语）放在句子的后部&lt;/strong&gt;。如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It is not easy to learn English well.&lt;/li&gt;
  &lt;li&gt;It is important for students to use English every day.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-2-宾语&quot;&gt;2-3-2 宾语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;动词不定式当宾语的格式为：vt + to do.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;动词不定式（短语）可以放在一些动词后面用作宾语，能以动词不定式作宾语的动词有：begin, start, want, forget, remember, learn, like, hate, love, ask , decide, expect, want, hope, wish, offer, fail, plan, learn, pretend, refuse, manage, help, agree, promise, prefer, mean 等等&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;I want to tell you a story.&lt;/li&gt;
  &lt;li&gt;They begin to work at eight every morning.&lt;/li&gt;
  &lt;li&gt;Don’t forget to lock the door.&lt;/li&gt;
  &lt;li&gt;Would you like to go and have a picnic with us tomorrow?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果 and 连接两个动词不定式，&lt;em&gt;第二个动词不定式一般省 “to”&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He wants to go and have a swim with us.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;若作宾语的动词不定式（短语）很长，可用 it 作形式宾语&lt;/strong&gt;（与形式主语类似）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I find it interesting to learn English with you.&lt;/li&gt;
  &lt;li&gt;He found it hard to catch up with others.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-3-3-表语&quot;&gt;2-3-3 表语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;表语，属于主语补足语，语法名词，是指说明主语的身份、性质、品性、特征和状态的词或从句。表语常由名词、形容词、介词短语、动名词、不定式、副词来充当，它&lt;em&gt;常位于系动词之后&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;不定式表示目的
    &lt;ul&gt;
      &lt;li&gt;The purpose of education is to develop a fine personality in children.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示事态发展的结果、预期的结果、不幸的命运
    &lt;ul&gt;
      &lt;li&gt;He was to perish in a shipwreck and to leave a wife and two children.&lt;/li&gt;
      &lt;li&gt;You are to die at ninety-eight.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用于第一人称疑问句，表示征求意见
    &lt;ul&gt;
      &lt;li&gt;What am I to say if they ask me the question?&lt;/li&gt;
      &lt;li&gt;What am I to do if I have no money?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示“同意、安排、命令、决定、劝告、意愿、禁止”等
    &lt;ul&gt;
      &lt;li&gt;They are to marry next week.&lt;/li&gt;
      &lt;li&gt;Children are not to smoke.&lt;/li&gt;
      &lt;li&gt;You must be patient and persistent if you are to succeed.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;不定式作表语，可用主动形式表示被动意义&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;She is to blame.&lt;/li&gt;
      &lt;li&gt;Something is still to find out.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-4-定语&quot;&gt;2-3-4 定语&lt;/h3&gt;

&lt;p&gt;动词不定式作定语，&lt;em&gt;放在所修饰的名词或代词后&lt;/em&gt;。与所修饰名词有如下关系:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;主谓关系&lt;/p&gt;

    &lt;p&gt;不定式作定语表示主谓关系，指的是中心词是不定式的逻辑主语&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He is not a man to tell a lie.&lt;/li&gt;
      &lt;li&gt;See if you can get the car to start.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动宾关系&lt;/p&gt;

    &lt;p&gt;不定式作定语表示动宾关系，指的是中心词是不定式的逻辑宾语&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;We have a lot of work to do.&lt;/li&gt;
      &lt;li&gt;I have some clothes to wash.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;当不定式与所修饰的中心词有动宾关系时，不定式的动词需为及物动词，若是不及物动词，不定式后需加上适当的介词。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I need a pen to write with.&lt;/li&gt;
      &lt;li&gt;Give me some paper to write on.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同位关系&lt;/p&gt;

    &lt;p&gt;不定式做定语表示同位关系，指的是不定式是中心词的内容，两者具有同位关系&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I have a wish to go to college.&lt;/li&gt;
      &lt;li&gt;I had a dream to fly in the sky like a bird.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有时不表示任何特别关系&lt;/p&gt;

    &lt;p&gt;有时不定式与被修饰的名词不存在主谓、动宾、同位关系的，此时被修饰的名词多是些抽象名词&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;We have no need to be afraid of them!&lt;/li&gt;
      &lt;li&gt;The dog found out the way to open the door.&lt;/li&gt;
      &lt;li&gt;I am sure of his ability to cope with this.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-5-状语&quot;&gt;2-3-5 状语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;状语的作用：状语说明地点、时间、原因、目的、结果、条件、方向、程度、方式和伴随状语等。状语一般由副词、介词短语、分词和分词短语、不定式或相当于副词的词或短语来担当。其位置一般放在句首，但也可放在句末或句中。状语是一种用来修饰动词，形容词，副词或全句的词，说明时间，地点，程度，方式等概念。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;表示目的&lt;/p&gt;

    &lt;p&gt;不定式用作目的状语时，常常翻译成”为了”，”目的是”。&lt;/p&gt;

    &lt;p&gt;不定式用作目的状语&lt;strong&gt;&lt;em&gt;常放在句首和句末&lt;/em&gt;&lt;/strong&gt;。一般说来，用于句首属于强调性用法，即强调动词的目的。&lt;/p&gt;

    &lt;p&gt;有时为了&lt;strong&gt;&lt;em&gt;特别强调目的状语，可以在不定式之前加上 in order 或 so as，即构成 in order to do sth.和 so as to do sth. 结构&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;To finish my work, I worked overtime late into the night last Friday.&lt;/li&gt;
      &lt;li&gt;He worked day and night to get the money.&lt;/li&gt;
      &lt;li&gt;She sold her hair to buy the watch chain.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;注意不定式放句首时，逻辑主语与句子主语要一致。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;wrong: To save money, every means has been tried.&lt;/li&gt;
      &lt;li&gt;right: To save money, he has tried every means.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表示结果&lt;/p&gt;

    &lt;p&gt;不定式作结果状语只限于下面几个词：&lt;strong&gt;&lt;em&gt;learn（得知），find（发现），see（看见），hear（听见），to be told（被告知），make（使得&lt;/em&gt;&lt;/strong&gt;）等。&lt;/p&gt;

    &lt;p&gt;only + 不定式常表示出乎意料的结果。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I hurried to the library only to find it is closed.&lt;/li&gt;
      &lt;li&gt;He arrived late only to find the train had gone.&lt;/li&gt;
      &lt;li&gt;I visited him only to find him out.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表示原因&lt;/p&gt;

    &lt;p&gt;不定式作原因状语主要&lt;strong&gt;&lt;em&gt;用于表示情绪与心理状态的动词或形容词&lt;/em&gt;&lt;/strong&gt;，表示人对某事某物的反应如何，常译作“因……而……”。&lt;/p&gt;

    &lt;p&gt;常见的这类形容词有 able（有能力的），afraid（害怕的），cruel（残忍的），possible（可能的），proud（自豪的），unable（没能力的），useless（没用的），willing（愿意的）等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I am so glad to hear the news .&lt;/li&gt;
      &lt;li&gt;They were very sad to hear the news.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表示程度&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;It’s too dark for us to see anything.&lt;/li&gt;
      &lt;li&gt;The question is simple for him to answer.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-6-宾语补足语&quot;&gt;2-3-6 宾语补足语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;宾语补足语指有些及物动词，接了宾语意义仍不完整，还需要有一个其他的句子成分，来补充说明宾语的意义、状态等，简称宾补。
宾语和它的补足语构成复合宾语。而复合宾语的第一部分通常由名词或代词充当，第二部分表示第一部分的名词或代词发出的动作或身份、特征等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在复合宾语中，动词不定式可充当宾语补足语，如下动词常跟这种复合宾语: want, wish, ask, tell, order, beg, permit, help, advise, persuade, allow, prepare, cause, force, call on, wait for, invite…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Father will not allow us to play on the street.&lt;/li&gt;
  &lt;li&gt;We believe him to be guilty.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，介词有时也与这种复合宾语连用:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;With a lot of work to do, he didn’t go to the cinema.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;有些动词如 make, let, see, watch, hear, feel, have 等与不带有 to 的不定式连用，但改为被动语态时，不定式要加 to&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I saw him cross the road.&lt;/li&gt;
  &lt;li&gt;He was seen to cross the road.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-动名词&quot;&gt;3-动名词&lt;/h1&gt;
&lt;h2 id=&quot;3-1-介绍&quot;&gt;3-1-介绍&lt;/h2&gt;

&lt;p&gt;动名词是由动词变化而来，一方面保留着动词的某些特征，具有动词的某些变化形式，用以表达名词所不能表达的较为复杂的意念；另一方面动名词在句子的用法及功能与名词类同: 在句子中可以作主语、宾语、表语、定语，它也可以被副词修饰或者用来支配宾语。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;既有动词的变化形式，又具有名词的用法&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-2-用法&quot;&gt;3-2-用法&lt;/h2&gt;

&lt;h3 id=&quot;3-2-1-主语&quot;&gt;3-2-1 主语&lt;/h3&gt;

&lt;p&gt;动名词做主语，&lt;strong&gt;谓语动词用单数&lt;/strong&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;直接位于句首做主语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Swimming is a good sport in summer.&lt;/li&gt;
      &lt;li&gt;Fighting broke out between the South and the North.&lt;/li&gt;
      &lt;li&gt;Breathing became difficult at that altitude.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;用 it 作形式主语&lt;/strong&gt;，把&lt;strong&gt;动名词&lt;/strong&gt;(真实主语)&lt;strong&gt;置于句尾作后置主语&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;动名词做主语时，不太常用 it 作先行主语，多见于某些形容词及名词之后。常见的能用于这种结构的形容词还有：good，better，wonderful, enjoyable，interesting，foolish，difficult，useless，senseless，worthwhile，等。但是 important，essential，necessary 等形容词不能用于上述结构。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;It is no use waiting for him any longer.&lt;/li&gt;
      &lt;li&gt;It is no good learning without practice.&lt;/li&gt;
      &lt;li&gt;It is dangerous using this method to measure the speed of light.&lt;/li&gt;
      &lt;li&gt;It is worthwhile consulting your tutor about it again.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用于 “&lt;strong&gt;There be” 结构&lt;/strong&gt;中
    &lt;ul&gt;
      &lt;li&gt;There is no saying when he’ll come. 很难说他何时回来&lt;/li&gt;
      &lt;li&gt;There is no joking about such matters.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用于&lt;strong&gt;布告形式的省略结构&lt;/strong&gt;中
    &lt;ul&gt;
      &lt;li&gt;No smoking. =  Smoking is not allowed here.&lt;/li&gt;
      &lt;li&gt;No parking.  = parking is not allowed here.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动名词的复合结构作主语&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当动名词有自己的逻辑主语时，常可以在前面加上一个&lt;strong&gt;名词或代词的所有格&lt;/strong&gt;，构成动名词的复合结构(此时，名词或代词的所有格做动名词的逻辑主语)。&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;His coming to help was a great encouragement to us.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-2-定语&quot;&gt;3-2-2 定语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;动名词一般为名词性，很少做定语，不过在&lt;strong&gt;&lt;em&gt;一些特殊的情况下可以用来表示所修饰名词的用途&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;sleeping bag&lt;/li&gt;
      &lt;li&gt;walking stick&lt;/li&gt;
      &lt;li&gt;drinking water&lt;/li&gt;
      &lt;li&gt;swimming pool&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有些动名词已经转化成了形容词，常用作定语修饰物，表示“令人……的”，如 exciting, shocking, puzzling, confusing, disappointing, discouraging, boring, tiring, moving, touching, interesting, satisfying, frightening, amazing 等
    &lt;ul&gt;
      &lt;li&gt;That must be a terrifying experience.&lt;/li&gt;
      &lt;li&gt;The experiment was an amazing success.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-3-宾语&quot;&gt;3-2-3 宾语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;一些动词后用动名词作宾语，如 finish 完成，enjoy享受，mind介意，suggest建议，practise练习，admit 承认，advise 建议，allow 允许，appreciate 感激，avoid 避免，consider 考虑，delay 推迟，deny 否认，discuss 讨论，dislike 不喜欢，enjoy 喜爱，escape 逃脱，excuse 原谅，fancy 设想， forbid 禁止，forgive 原谅，imagine 想像，keep 保持，mention 提及，mind 介意 miss 没赶上，pardon 原谅，permit 允许， prevent 阻止，risk 冒险，understand 理解
    &lt;ul&gt;
      &lt;li&gt;I admit breaking the window.&lt;/li&gt;
      &lt;li&gt;Try to imagine being on the moon.&lt;/li&gt;
      &lt;li&gt;He tried to escape being punished.&lt;/li&gt;
      &lt;li&gt;You shouldn’t keep thinking about it.&lt;/li&gt;
      &lt;li&gt;Would you mind going with her?&lt;/li&gt;
      &lt;li&gt;I can’t understand neglecting children like that.&lt;/li&gt;
      &lt;li&gt;We only missed seeing each other by five minutes.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有些动词短语后跟动名词作宾语，如 insist on, be worth，give up，object/objection to，put off，keep on，insist on，leave off，look forward to，think of, can’t help, be/get used to, spend…in ,can’t stand，feel like 等
    &lt;ul&gt;
      &lt;li&gt;Do you feel like going out for dinner with me tonight?&lt;/li&gt;
      &lt;li&gt;Chinese people are looking forward to holding the 27th Olympic games.&lt;/li&gt;
      &lt;li&gt;I am used to going to bed late and getting up late.&lt;/li&gt;
      &lt;li&gt;The professor was quite used to students’ being late for his lecture.&lt;/li&gt;
      &lt;li&gt;He put off making a decision till he had more information.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-4-表语&quot;&gt;3-2-4 表语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;动名词作表语时句子&lt;strong&gt;主语常是表示无生命的事物名词或 what 引导的名词性从句&lt;/strong&gt;。表语动名词与主语通常是对等的关系，表示主语的内容，&lt;strong&gt;主语、表语可互换位置&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果句中的主语和表语同为动词时，要注意保持两个动词在形式上的一致。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;Your task is cleaning the windows. = Cleaning the windows is your task.&lt;/li&gt;
      &lt;li&gt;What I hate most is being laughed at. = Being laughed at is what I hate most.&lt;/li&gt;
      &lt;li&gt;The most popular pastime is playing chess. = Playing chess is the most popular pastime.&lt;/li&gt;
      &lt;li&gt;The only thing that interests her is working. = Working is the only thing that interests her.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-现在分词&quot;&gt;4-现在分词&lt;/h1&gt;
&lt;h2 id=&quot;4-1-介绍&quot;&gt;4-1-介绍&lt;/h2&gt;

&lt;p&gt;分词分为现在分词与过去分词，均是非谓语动词。分词在句子中不能单独充当谓语，不过可以充当其他成分：定语，表语，补语，状语，并且&lt;strong&gt;&lt;em&gt;分词具有动词性质&lt;/em&gt;&lt;/strong&gt;，因此是类动词的一种。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;动名词只具有名词词性&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;现在分词一方面&lt;strong&gt;&lt;em&gt;具有动词特性，可以拥有自己的宾语与状语&lt;/em&gt;&lt;/strong&gt;；另一方面&lt;strong&gt;&lt;em&gt;具有形容词与副词的特性，可以充当定语，表语，补语，状语&lt;/em&gt;&lt;/strong&gt;。现在分词可以表示主动或者正在进行的动作。&lt;/p&gt;

&lt;h2 id=&quot;4-2-时态与语态&quot;&gt;4-2-时态与语态&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;时态&lt;/th&gt;
      &lt;th&gt;主动语态&lt;/th&gt;
      &lt;th&gt;被动语态&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;一般式&lt;/td&gt;
      &lt;td&gt;doing&lt;/td&gt;
      &lt;td&gt;being done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成式&lt;/td&gt;
      &lt;td&gt;having done&lt;/td&gt;
      &lt;td&gt;having been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;否定式&lt;/td&gt;
      &lt;td&gt;-ing 前加 not&lt;/td&gt;
      &lt;td&gt;-ing 前加 not&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;现在分词的&lt;strong&gt;一般式通常表示其动作与谓语动词同时发生；完成式表示其动作在谓语动词的动作发生之前完成；被动式表示其逻辑主语为现在分词动作的承受者&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;She sat there reading a novel.&lt;/li&gt;
  &lt;li&gt;Having finished her homework, the little girl began to watch TV.&lt;/li&gt;
  &lt;li&gt;The building being built is our library.&lt;/li&gt;
  &lt;li&gt;Having been warned by the teacher, the students didn’t make such mistakes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-3-用法&quot;&gt;4-3-用法&lt;/h2&gt;

&lt;h3 id=&quot;4-3-1-定语&quot;&gt;4-3-1 定语&lt;/h3&gt;

&lt;p&gt;现在分词作定语，表示&lt;em&gt;正在进行的或主动的动作，也可以说明被修饰词的性质和特征&lt;/em&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;现在分词单独做定语，通常放在所修饰词之前
    &lt;ul&gt;
      &lt;li&gt;The sleeping boy is Tom.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;现在分词短语作定语，通常放在所修饰词的后面，类似于定语从句
    &lt;ul&gt;
      &lt;li&gt;Tell the children playing outside not to make noise.&lt;/li&gt;
      &lt;li&gt;Tell the children who are playing outside not to make noise.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-2-表语&quot;&gt;4-3-2 表语&lt;/h3&gt;

&lt;p&gt;现在分词作表语，通常表示主语的特征。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The story is moving.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-3-3-宾语补足语&quot;&gt;4-3-3 宾语补足语&lt;/h3&gt;

&lt;p&gt;现在分词作宾语补足语，表示正在进行的或主动进行的动作，与&lt;strong&gt;&lt;em&gt;前边的宾语有逻辑上的“主表“或”主谓“关系&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We all found his equipment interesting. (主表关系)&lt;/li&gt;
  &lt;li&gt;I saw Mary going upstairs then. (主谓关系)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-3-4-状语&quot;&gt;4-3-4 状语&lt;/h3&gt;

&lt;p&gt;现在分词作状语时，可作时间、条件、结果、原因和伴随状语，表示正在进行的或主动的动作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;分词的逻辑主语就是主句的主语，因此要注意人称、时态和语态的一致性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;作原因状语，相当于原因状语从句
    &lt;ul&gt;
      &lt;li&gt;Being ill, Mary didn’t come to school yesterday.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作时间状语，相当于时间状语从句
    &lt;ul&gt;
      &lt;li&gt;Seeing their teacher coming, the students stopped talking.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作条件状语，相当于条件状语从句
    &lt;ul&gt;
      &lt;li&gt;Working harder, you’ll be No. 1 in your class.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作让步状语，相当于让步状语从句
    &lt;ul&gt;
      &lt;li&gt;Weighing almost two hundred pounds, the stone was moved by him alone.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作结果状语，相当于结果状语从句
    &lt;ul&gt;
      &lt;li&gt;He died, leaving nothing but debts.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作伴随状语，相当于伴随状语从句
    &lt;ul&gt;
      &lt;li&gt;Look at the people lying on the beach.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作方式状语，相当于伴随状语从句
    &lt;ul&gt;
      &lt;li&gt;Please answer the question using another way.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-5-独立成分&quot;&gt;4-3-5 独立成分&lt;/h3&gt;

&lt;p&gt;现在分词作独立成分，即独立主格。常见形式有：generally speaking(一般来说), Judging form/by (由…判断)。&lt;/p&gt;

&lt;p&gt;独立主格没有主语和谓语，只有逻辑上的主语，因此，它在句法上不是句子，而是一个独立于句子成分外的独特结构形式。&lt;/p&gt;

&lt;p&gt;独立主格结构可置于句首或者句尾，用逗号与主句隔开；形式为：&lt;strong&gt;名词/名词短语/代词 + 不定式/ing分词/ed分词/形容词/副词/介词短语（名词前也可以加with）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;独立主格结构主要用于描绘性文字中，其作用相当于一个状语从句，常用来表示时间、原因、条件、行为方式或伴随情况等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;表示时间
    &lt;ul&gt;
      &lt;li&gt;The meeting being over, all of us went home.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示条件
    &lt;ul&gt;
      &lt;li&gt;The condition being favorable, he may succeed.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示原因
    &lt;ul&gt;
      &lt;li&gt;There being no taxis, we had to walk.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示伴随情况
    &lt;ul&gt;
      &lt;li&gt;Almost all metals are good conductors, silver being the best of all.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示补充说明
    &lt;ul&gt;
      &lt;li&gt;We redoubled our efforts, each man working like two.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-什么是非谓语动词 1-1-介绍</summary></entry></feed>