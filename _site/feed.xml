<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-19T21:27:42+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Find a needle in haystack</title><subtitle>Code.
</subtitle><author><name>kkzhang</name></author><entry><title type="html">Redis Cluster Tutorial</title><link href="http://localhost:4000/redis-cluster-tutorial.html" rel="alternate" type="text/html" title="Redis Cluster Tutorial" /><published>2022-02-13T00:00:00+08:00</published><updated>2022-02-13T00:00:00+08:00</updated><id>http://localhost:4000/redis-cluster-tutorial</id><content type="html" xml:base="http://localhost:4000/redis-cluster-tutorial.html">&lt;h2 id=&quot;1-introduction&quot;&gt;1-Introduction&lt;/h2&gt;

&lt;p&gt;Redis Cluster 支持&lt;strong&gt;数据自动在多个 Redis 节点间分片&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通过 Redis Cluster，能够实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;自动切分数据集到多个节点&lt;/strong&gt;（Sharding）&lt;/li&gt;
  &lt;li&gt;当部分节点故障或不可达的情况下，Redis Cluster 能够继续提供服务（High Availability）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Redis Cluster 提供&lt;strong&gt;&lt;em&gt;一定程度的高可用&lt;/em&gt;&lt;/strong&gt;，当某些节点失败或者不能访问的情况下能够继续提供服务。但是当大量节点失败的情况下集群也会停止服务（例如大多数主节点不可用）。&lt;/p&gt;

&lt;h2 id=&quot;2-tcp-ports&quot;&gt;2-TCP Ports&lt;/h2&gt;

&lt;p&gt;每个 Redis Cluster 节点需要打开两个 TCP 端口用于不同的连接。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;端口 &lt;strong&gt;6379&lt;/strong&gt;：用于提供&lt;strong&gt;客户端连接&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;该端口需要开放给所有与集群交互的客户端；同时，也要开放给集群中的其他节点用于 keys 迁移&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;端口 &lt;strong&gt;16379&lt;/strong&gt;：用于&lt;strong&gt;集群总线&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;该端口需要开放给集群中的其他节点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;客户端只能连接 6379，而不能连接 16739；而集群中的节点可以访问 6379 与 16739 两个端口&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;集群总线用于集群节点之间访问，使用&lt;em&gt;二进制协议&lt;/em&gt;，主要用于&lt;strong&gt;失败检测、配置升级、故障转移授权&lt;/strong&gt;等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;二进制协议更适合节点间使用小的带宽和处理时间来交换数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;3-data-sharding&quot;&gt;3-Data Sharding&lt;/h2&gt;

&lt;p&gt;Redis Cluster 的&lt;strong&gt;数据分片&lt;/strong&gt;不是使用一致性 Hash，而是使用一种 &lt;strong&gt;Hash Slot（哈希槽&lt;/strong&gt;）的形式。&lt;/p&gt;

&lt;p&gt;Redis Cluster 中共有 16384 个 Slot，如何决定每个 key 分配到哪个槽呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Slot_Index = &lt;strong&gt;CRC16(key) % 16384&lt;/strong&gt; 计算 Slot 索引&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cluster 中的每个节点负责一部分 Hash Slot，比如集群中有３个节点，则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A 存储的范围：0 ~ 5500&lt;/li&gt;
  &lt;li&gt;Ｂ存储的范围：5501 ~ 11000&lt;/li&gt;
  &lt;li&gt;Ｃ存储的范围：11001 ~ 16384&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种分配方式便于集群节点的新增与剔除。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新增一个节点Ｄ：需要把Ａ、Ｂ、Ｃ中的部分 Hash Slot 数据移到 Ｄ 节点&lt;/li&gt;
  &lt;li&gt;删除 Ａ 节点：需要把 Ａ 节点的 Hash Slot 的数据移到 Ｂ 和 Ｃ 节点；当 Ａ 节点的数据全部被移走后，Ａ 节点就可以完全从集群中删除&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Slot 在不同节点之间的迁移不需要暂停服务&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过 Hash Tag 的概念，Redis Cluster 可以通过一个命令（或事务, 或 lua 脚本）同时操作多个 key。&lt;/p&gt;

&lt;p&gt;Hash Tag 可以使得&lt;strong&gt;相同 Tag 的不同 key 被分配到同一个 Slot&lt;/strong&gt; 。如：key_1 = “this{foo}”, key_2 = “another{foo}”，这两个 key 的 tag 均为 foo，会被分配到同一个 Slot 中，所以可以在一个命令中操作它们。&lt;/p&gt;

&lt;h2 id=&quot;4-master-replica-model&quot;&gt;4-Master-Replica Model&lt;/h2&gt;

&lt;p&gt;为了提高 Cluster 的可用性，保证在部分节点故障或网络不通时 Cluster 依然能正常工作，Redis Cluster 使用了主从模型：&lt;strong&gt;&lt;em&gt;每个 Hash Slot 有 1（主节点）到 N 个副本（ N-1 个从节点&lt;/em&gt;&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;在上面的例子中，A, B, C 设为主节点，A1, B1, C1 分别为其从节点。如果 B 不可用，则会将 B1 提升为主节点，从而保证集群能够继续提供服务；但是如果 B1 同时也不可用了，则集群就不能继续工作了。&lt;/p&gt;

&lt;h2 id=&quot;5-consistency-guarantees&quot;&gt;5-Consistency Guarantees&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Redis Cluster 不能保证强一致性&lt;/strong&gt;：一些已经向 Client 确认写成功的操作，会在某些不确定的情况下丢失。&lt;/p&gt;

&lt;p&gt;无法保证强一致性的原因有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;主从节点之间使用了异步的方式来同步数据&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;网络分区期间可能导致的写操作数据丢失&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当 Client 向主节点 B 节点提交一个写操作后，主节点 B 将数据保存在本地并回复给 Client 操作成功 ，之后 B 异步地将刚才写操作的变更复制到从节点  B1, B2, B3。&lt;/p&gt;

&lt;p&gt;由于是异步复制，所以在 B 响应 Client 之后，并且同步给从节点之前，主节点 Ｂ 故障了，其中一个没有收到该写操作的从节点会晋升成主节点，该写操作就这样永远丢失了。&lt;/p&gt;

&lt;p&gt;为了提高一致性，可以考虑使用同步复制，不过会使得性能降低。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;在性能和一致性之间，需要一个权衡&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Redis Cluster 支持同步复制，通过 WAIT 命令实现，可以让数据丢失的概率降低。但是&lt;strong&gt;&lt;em&gt;即使使用了同步复制，Redis Cluster 仍不是强一致性的&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;考虑一种网络分区的情况：集群中存在主节点 A, B, C，从节点 A1, B1, C1，客户端 Z1，其中 Z1 与 B 可以网络互通，A, A1, B1, C, C1 之间网络互通，但是与 Z1, B 网络不通（一共两个网络分区）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Z1 可以继续向 B 发起写操作，Ｂ 也接受 Z1 的写操作&lt;/li&gt;
  &lt;li&gt;当网络恢复时，如果这个时间间隔足够短，集群仍然能继续正常工作&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果时间比较长，以至于 &lt;strong&gt;&lt;em&gt;B1 在大多数的这边被重新选为主节点&lt;/em&gt;&lt;/strong&gt;，那么刚才 Z1 发给 Ｂ 的写操作都将丢失&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Z1 给 Ｂ 发送写操作是有一个限制的，如果时间长度达到了大多数节点那边可以选出一个新的主节点时，少数这边的所有主节点都不接受写操作&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如何评断网络分区的时间是长还是短？&lt;/p&gt;

&lt;p&gt;Redis Cluster 中存在一个&lt;strong&gt;节点超时配置&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当达到了这个节点超时的时间之后，主节点被认为已经宕机，可以用它的一个从节点来代替&lt;/li&gt;
  &lt;li&gt;同样，在节点超时时，如果主节点依然不能联系到其他主节点，它将&lt;em&gt;进入错误状态，不再接受写操作&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-appendix&quot;&gt;6-Appendix&lt;/h2&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;https://redis.io/topics/cluster-tutorial#:~:text=Redis%20Cluster%20provides%20a%20way,are%20not%20able%20to%20communicate&quot;&gt;redis-io&lt;/a&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">1-Introduction</summary></entry><entry><title type="html">同位语从句</title><link href="http://localhost:4000/appositive-clause.html" rel="alternate" type="text/html" title="同位语从句" /><published>2022-02-13T00:00:00+08:00</published><updated>2022-02-13T00:00:00+08:00</updated><id>http://localhost:4000/appositive-clause</id><content type="html" xml:base="http://localhost:4000/appositive-clause.html">&lt;h2 id=&quot;1-同位语&quot;&gt;1-同位语&lt;/h2&gt;

&lt;p&gt;一个名词（或其它形式）&lt;strong&gt;&lt;em&gt;对另一个名词或代词进行解释或补充说明&lt;/em&gt;&lt;/strong&gt;，这个名词（或其它形式）就是同位语。&lt;/p&gt;

&lt;p&gt;同位语与被它限定的词的格式要一致，并常常紧挨在一起。同位语除表示其同位成分的全部意义外，还可以表示部分意义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mr. Smith, our new teacher, is very kind to us.&lt;/li&gt;
  &lt;li&gt;He told me that his brother John was a world-famous doctor.(John 是 brother 的同位语)&lt;/li&gt;
  &lt;li&gt;Yesterday I talked to my English teacher, Mr. James.&lt;/li&gt;
  &lt;li&gt;We Chinese people are brave and hard-working.(Chinese people 是 we 的同位语)&lt;/li&gt;
  &lt;li&gt;He is interested in sports, especially ball games.(ball games 是 sports 的同位语)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-同位语从句&quot;&gt;2-同位语从句&lt;/h2&gt;

&lt;p&gt;同位语从句指的是在复合句中充当同位语的从句，属于名词性从句的范畴。&lt;/p&gt;

&lt;p&gt;同位语从句用来&lt;em&gt;对其前面的抽象名词进行解释说明&lt;/em&gt;，被解释说明的词和同位语在逻辑上是&lt;strong&gt;主表关系&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2-1-先行词&quot;&gt;2-1 先行词&lt;/h3&gt;

&lt;p&gt;可以连接同位语从句的名词有：&lt;strong&gt;news，idea，fact，promise，question，doubt，thought，hope，message，suggestion，words(消息)，possibility, decision&lt;/strong&gt; 等(一般的”抽象”名词)。&lt;/p&gt;

&lt;h3 id=&quot;2-2-引导词&quot;&gt;2-2 引导词&lt;/h3&gt;

&lt;p&gt;引导同位语从句的词语通常有连词 that, whethe, 连接代词和连接副词等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;that 连接从句时，&lt;strong&gt;从句为一个句意完整的陈述句&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;that 不能省略，没有具体的含义，&lt;strong&gt;&lt;em&gt;不充当句子成分，只起连接作用&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The idea &lt;em&gt;that you can do this work well without thinking&lt;/em&gt; is quite wrong.(that 引导的从句作 idea 的同位语)&lt;/li&gt;
      &lt;li&gt;We heard the news &lt;em&gt;that our team had won&lt;/em&gt;.(news 的同位语)&lt;/li&gt;
      &lt;li&gt;They were worried over the fact &lt;em&gt;that you were sick&lt;/em&gt;.(fact 的同位语)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;在某些名词(如 &lt;strong&gt;demand, wish, suggestion, resolution&lt;/strong&gt;等) 后面的同位语从句要&lt;strong&gt;用虚拟语气&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;There was a suggestion &lt;em&gt;that Brown should be dropped from the team&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;引导同位语从句的连词 that 通常不省略，但在&lt;em&gt;非正式文体中也可以省去&lt;/em&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He grabbed his suitcase and gave the impression &lt;em&gt;he was boarding the Tokyo plane&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;whether 引导同位语从句&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;if 不能引导同位语从句&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;There is some doubt &lt;em&gt;whether he will come&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;Answer my question &lt;em&gt;whether you are coming&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;The question &lt;em&gt;whether it is right or wrong&lt;/em&gt; depends on the result.&lt;/li&gt;
      &lt;li&gt;We are not investigating the question &lt;em&gt;whether he is trustworthy&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接代词 what, who, whom, whose 引导同位语从句
    &lt;ul&gt;
      &lt;li&gt;I have no idea &lt;em&gt;what size shoes she wears&lt;/em&gt;.(what 作 size 的定语)&lt;/li&gt;
      &lt;li&gt;The question &lt;em&gt;who will take his place&lt;/em&gt; is still not clear.(who 作同位语从句的主语)&lt;/li&gt;
      &lt;li&gt;Have you any idea &lt;em&gt;what time it starts&lt;/em&gt;?&lt;/li&gt;
      &lt;li&gt;I have no idea &lt;em&gt;who can really understand my complicated mind&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接副词 where, when, why, how 引导同位语从句
    &lt;ul&gt;
      &lt;li&gt;I have no idea &lt;em&gt;when he will come back&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;It is a question &lt;em&gt;how he does it&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;He had no idea &lt;em&gt;why she left&lt;/em&gt;.&lt;/li&gt;
      &lt;li&gt;You have no idea &lt;em&gt;how worried I was&lt;/em&gt;!&lt;/li&gt;
      &lt;li&gt;We haven’t yet settled the question &lt;em&gt;where we are going to spend our summer vacation&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-同位语</summary></entry><entry><title type="html">定语从句</title><link href="http://localhost:4000/attributive-clause.html" rel="alternate" type="text/html" title="定语从句" /><published>2022-02-11T00:00:00+08:00</published><updated>2022-02-11T00:00:00+08:00</updated><id>http://localhost:4000/attributive-clause</id><content type="html" xml:base="http://localhost:4000/attributive-clause.html">&lt;h2 id=&quot;1-基本概念&quot;&gt;1-基本概念&lt;/h2&gt;

&lt;h3 id=&quot;1-1-定义&quot;&gt;1-1 定义&lt;/h3&gt;

&lt;p&gt;一个简单句跟在&lt;em&gt;名词或代词（先行词）后进行修饰限定&lt;/em&gt;，就叫做定语从句；定语从句在主句中充当定语成分。&lt;/p&gt;

&lt;p&gt;被定语从句修饰的词叫&lt;strong&gt;先行词&lt;/strong&gt;；定语从句通常只能放在被修饰的先行词之后。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;单词做定语放在被修饰词之前&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;1-2-引导词&quot;&gt;1-2 引导词&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;引导定语从句的词有：
    &lt;ul&gt;
      &lt;li&gt;关系代词：&lt;strong&gt;that, who, whom, which, as&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;关系副词：&lt;strong&gt;when, where, why&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;引导词位于定语从句之前，先行词之后（as 除外）。&lt;/li&gt;
  &lt;li&gt;引导词的作用有：
    &lt;ul&gt;
      &lt;li&gt;连接先行词和定语从句&lt;/li&gt;
      &lt;li&gt;在定语从句中充当一定的成分（&lt;strong&gt;&lt;em&gt;关系代词充当主语或宾语，关系副词充当状语&lt;/em&gt;&lt;/strong&gt;）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-关系代词的用法&quot;&gt;2-关系代词的用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;who/that&lt;/strong&gt; 指人，是主格；&lt;strong&gt;在定语从句中代替先行词，又作定语从句的主语，不能省略&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Do you know the gentleman who/that is sitting there？&lt;/li&gt;
      &lt;li&gt;The student who/that answered the question was John.&lt;/li&gt;
      &lt;li&gt;Nothing is difficult to the man who/that will try.&lt;/li&gt;
      &lt;li&gt;The windows was broken by the boy who/that lives opposite.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;whom/who/that&lt;/strong&gt; 指人，是宾格；&lt;strong&gt;在定语从句中代替先行词，又作定语从句的宾语(动宾或介宾)&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;当作&lt;strong&gt;动宾&lt;/strong&gt;（动词后接宾语）时，关系代词可省略
        &lt;ul&gt;
          &lt;li&gt;Do you know the gentleman (whom/who/that) we met just now？&lt;/li&gt;
          &lt;li&gt;The author (whom/who/that) you criticized.&lt;/li&gt;
          &lt;li&gt;Then I telephoned the doctor (whom/who/that) Charles had recommended.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;当作&lt;strong&gt;介宾&lt;/strong&gt;（介词后接宾语）时：&lt;em&gt;介词不提前，关系代词可省略；介词提前，关系代词不可省&lt;/em&gt;，即 “介词+whom” (指人时介词后的关系代词只能用whom)
        &lt;ul&gt;
          &lt;li&gt;The man (whom/who/that) I spoke with is my teacher.&lt;/li&gt;
          &lt;li&gt;The man with whom I spoke is my teacher.&lt;/li&gt;
          &lt;li&gt;The man with whom I traveled couldn’t speak English&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;固定的动词短语（动词+介词），如 look for, take care of 等不能把动词与介词拆开，即介词不能提至引导词前。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;She is the right girl (who/whom/that) we are looking for.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;whose&lt;/strong&gt; 是所有格 “…的” 形式；&lt;strong&gt;whose + n. 一起在定语从句中充当主语、宾语(&lt;/strong&gt;动宾或介宾)，即先行词的什么东西。&lt;/p&gt;

    &lt;p&gt;whose 用来指人或物（只用作定语) ，且 whose 不能省略。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;em&gt;whose + n. = the + n. + of which/whom&lt;/em&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;I didn’t find the desk whose leg was broken. (主语)&lt;/li&gt;
      &lt;li&gt;He is the student whose pencil I broke yesterday. (动宾)&lt;/li&gt;
      &lt;li&gt;The boss in whose company I work is very kind. (介宾)&lt;/li&gt;
      &lt;li&gt;They rushed over to help the man whose car had broken down. (主语)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;which/that&lt;/strong&gt; 指物，&lt;strong&gt;代替先行词，且在定语从句中作主语或宾语(动宾或介宾)&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;作主语
        &lt;ul&gt;
          &lt;li&gt;The house which/that was destroyed in the earthquake is weak.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;作宾语&lt;/p&gt;

        &lt;p&gt;which/that 作宾语时，同样分为动宾与介宾两种情况：1. 作动宾时，which/that 可以省略；2. 作介宾时，介词不提前时，关系代词 which/that 可以省略；介词提前时，关系代词 which/that 不可以省略。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;The pen (which/that) you found yesterday is mine.&lt;/li&gt;
          &lt;li&gt;The games (that/which) the young men competed in were difficult.&lt;/li&gt;
          &lt;li&gt;The games in which the young men competed were difficult.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;介词 + which 指物；介词 + whom 指人&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;as&lt;/strong&gt; 指人或物，在定语从句中可作主语，宾语，表语或状语，不能省略&lt;/p&gt;

    &lt;p&gt;主要用于 “&lt;strong&gt;the same …as…；such …as…；so …as…；as … as…；as follows&lt;/strong&gt; ” 固定结构中。在这种形式的结构中，要用 as 代替 who(m), which, 或 that 引导定语从句。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Such people as knew Hill thought he was honest.&lt;/li&gt;
      &lt;li&gt;Such people as Hill knew thought he was honest.&lt;/li&gt;
      &lt;li&gt;My hometown is no longer the same as it was.&lt;/li&gt;
      &lt;li&gt;Here is so big a stone as no one can lift.&lt;/li&gt;
      &lt;li&gt;The child knows as much as grow-ups (know).&lt;/li&gt;
      &lt;li&gt;I’d like to have the same books as are used in your school.&lt;/li&gt;
      &lt;li&gt;He is not such a person as I expected.&lt;/li&gt;
      &lt;li&gt;He will marry as pretty a girl as he can find.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-关系副词的用法&quot;&gt;3-关系副词的用法&lt;/h2&gt;

&lt;p&gt;关系副词，兼有副词与连接词两种作用，在&lt;strong&gt;不及物动词的连接中要求用关系副词&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;关系副词在句中作状语，关系副词=介词+关系代词，定语从句中常用的关系副词有三个：&lt;strong&gt;when，where，why&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;when = during/on/in which  where = in/at/on which  why = for which&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;when&lt;/strong&gt; 主要用于修饰表时间的名词，同时它在定语从句中用作&lt;strong&gt;时间状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;There comes a time when you have to make a choice.&lt;/li&gt;
      &lt;li&gt;Gone are the days when they could do what they liked.&lt;/li&gt;
      &lt;li&gt;We’ll put off the picnic until next week, when the weather may be better.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;先行词为时间名词时不一定用关系副词 when 来引导定语从句；需要进一步判断先行词在定语从句中成分。如果在定语从句中作时间状语，则用 when；如果在定语从句中作主语或者宾语时，要用 that, which 等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Don’t forget the time (that, which) I’ve told you.（先行词 time 作 told 的宾语）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;where&lt;/strong&gt; 主要用于修饰表地点的名词，同时它在定语从句中用作&lt;strong&gt;地点状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;This is the village where he was born.&lt;/li&gt;
      &lt;li&gt;That’s the hotel where we were staying last summer.&lt;/li&gt;
      &lt;li&gt;Barbary was working in Aubury, where she went daily in a bus.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;同样，先行词为地点的名词时，不一定要用 where 引导，需要进一步判断先行词在定语从句中的成分。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He works in a factory that/which makes TV sets.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;why&lt;/strong&gt; 主要用于修饰表原因的名词(主要是the reason)，同时它在定语从句中用作&lt;strong&gt;原因状语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;We don’t know the reason why he didn’t show up.&lt;/li&gt;
      &lt;li&gt;She didn’t tell me the reason why she refused the offer.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;why 与 where/when 的用法有点不同：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;why 可以省略或者替换成 that&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;That’s one of the reasons (why, that) I asked you to come.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;why 只能引导限制性定语从句，where/when 可以引导非限制性定语从句
        &lt;ul&gt;
          &lt;li&gt;The main reason, why he lost his job, was that he drank. (wrong)&lt;/li&gt;
          &lt;li&gt;The main reason why he lost his job was that he drank. (right)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-限制性与非限制性定语从句的区别&quot;&gt;4-限制性与非限制性定语从句的区别&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在句中作用不同
    &lt;ul&gt;
      &lt;li&gt;限制性定语从句&lt;strong&gt;对&lt;/strong&gt;被修饰的&lt;strong&gt;先行词有限定制约作用&lt;/strong&gt;，使该词的含义更具体,更明确。&lt;strong&gt;限制性定语从句不能被省略&lt;/strong&gt;，否则句意就不完整。&lt;/li&gt;
      &lt;li&gt;非限制性定语从句&lt;strong&gt;与先行词关系不是十分密切&lt;/strong&gt;，只是对其作一些附加说明，不起限定制约作用。如果将非限制性定语从句省去，主句的意义仍然完整。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表现形式不同&lt;/p&gt;

    &lt;p&gt;限制性定语从句因与先行词关系密切，所以&lt;strong&gt;不可以用逗号将其与主句隔开&lt;/strong&gt;；非限制性定语从句与先行词关系不是十分密切，所以&lt;strong&gt;可用逗号将其与主句隔开。&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Do you remember the girl who taught us English?&lt;/li&gt;
      &lt;li&gt;Clock is a kind of instrument which can tell people time.&lt;/li&gt;
      &lt;li&gt;This is the place where he used to live.&lt;/li&gt;
      &lt;li&gt;Mr. Zhang, who came to see me yesterday, is an old friend of mine.&lt;/li&gt;
      &lt;li&gt;We walked down the village street, where they were having market day.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;前三个例句中，定语从句与先行词关系密切，为限制性定语从句，不可用逗号隔开；后面两个例句中，定语从句与先行词关系不密切，为非限制性定语从句。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先行词内容有所不同&lt;/p&gt;

    &lt;p&gt;大多数限制性和非限制性定语从句的先行词往往为某一个词或短语，而特殊情况下&lt;strong&gt;&lt;em&gt;非限制性定语从句的先行词也可为整个主句,此时非限制性定语从句常由 which 引导&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;A middle-aged woman killed her husband&lt;/em&gt;, &lt;strong&gt;which&lt;/strong&gt; frightened me very much.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;A five-year-old boy can speak two foreign languages&lt;/em&gt;, &lt;strong&gt;which&lt;/strong&gt; surprises all the people present.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用的关系词有所不同
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;that 不可以引导非限制性定语从句&lt;/p&gt;

        &lt;p&gt;所有关系代词和关系副词都可以引导限制性定语从句，大部分关系代词与关系副词都可以引导非限制性定语从句，但是 that 除外。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;He gave his mother a color TV set for her birthday, that pleased her a lot.（wrong）&lt;/li&gt;
          &lt;li&gt;He gave his mother a color TV set for her birthday, &lt;strong&gt;&lt;em&gt;which&lt;/em&gt;&lt;/strong&gt; pleased her a lot.（wright）&lt;/li&gt;
          &lt;li&gt;He didn’t pass the exam, that disappointed me.（wrong）&lt;/li&gt;
          &lt;li&gt;He didn’t pass the exam, &lt;strong&gt;&lt;em&gt;which&lt;/em&gt;&lt;/strong&gt; disappointed me.（wright）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关系词替代情况不同&lt;/p&gt;

        &lt;p&gt;关系代词 whom 在限制性定语从句中作宾语时可用 who 代替 whom ,但 whom 在非限制性定语从句中作宾语时不可用 who 来代替。&lt;/p&gt;

        &lt;p&gt;在限制性定语从句中,先行词指人时可用 that 代替 who/whom ,但在非限制性定语从句中先行词指人时, 不可用 that 代替 who/whom。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关系代词省略情况不同&lt;/p&gt;

        &lt;p&gt;关系代词在&lt;strong&gt;&lt;em&gt;限制性定语从句中作宾语时可以省去&lt;/em&gt;&lt;/strong&gt;,非限制性定语从句的所有关系词均不可省。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;This is the book (&lt;em&gt;which/that&lt;/em&gt;) he lost yesterday.&lt;/li&gt;
          &lt;li&gt;The book, &lt;em&gt;which&lt;/em&gt; he lost yesterday, has been found.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-wich-与-that&quot;&gt;5-wich 与 that&lt;/h2&gt;

&lt;h3 id=&quot;5-1-定语从句中只用-that-不用-which&quot;&gt;5-1 定语从句中只用 that, 不用 which&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;先行词是 &lt;strong&gt;everything, anything, nothing&lt;/strong&gt; (something 除外), &lt;strong&gt;all, none, few, little, some&lt;/strong&gt; 等不定代词时，或当先行词被 &lt;strong&gt;every, any, all, some, no, little, few, much 等词修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Have you set down everything that Mr. Li said?&lt;/li&gt;
      &lt;li&gt;There seems to be nothing that is impossible to him in the world.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;当先行词指人时，偶尔也可用关系代词 who。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Any man that/who has a sense of responsibility won’t do such a thing.&lt;/li&gt;
      &lt;li&gt;All the guests that/who were invited to her wedding were important people.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被序数词修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;The first American movie that I watched was the Titanic.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被形容词最高级修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;This is the best museum that I have visited all my life.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;被 the very, the only, the first/last 等修饰&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;She is the only person that understands me.&lt;/li&gt;
      &lt;li&gt;After the big fire, the old car is the only thing that he owns.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词&lt;strong&gt;前面有 who, which 等疑问代词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Who is the man that is standing in front of the crowd?&lt;/li&gt;
      &lt;li&gt;Which is the room that Mr. Wang lives in?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词为人与动物或人与物
    &lt;ul&gt;
      &lt;li&gt;Look at the man and his donkey that are walking alone the street.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词是 reason, way 等词时，关系代词常用 that 代替 in which, for which, why，也常可省略
    &lt;ul&gt;
      &lt;li&gt;She admired the way (that) they solved the questions.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5-2-定语从句中只用-which-不用-that&quot;&gt;5-2 定语从句中只用 which, 不用 that&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在非限定性定语从句中，在任何情况下都不能用 that
    &lt;ul&gt;
      &lt;li&gt;This brunch of carnation, which is wound by silk ribbon, is the first gift to my mom.&lt;/li&gt;
      &lt;li&gt;These books, which you can get at any corner of the town, will give you all the information.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;关系代词前面有介词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Those days in which you could travel without a passport has gone.&lt;/li&gt;
      &lt;li&gt;That is the motel at which we stayed several years ago.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;先行词本身为 that (指代作用)
    &lt;ul&gt;
      &lt;li&gt;what about that which had appeared in recent activities.&lt;/li&gt;
      &lt;li&gt;The knowledge are from various fields and that which display the waves of human being.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-基本概念</summary></entry><entry><title type="html">表语从句</title><link href="http://localhost:4000/predicative-clause.html" rel="alternate" type="text/html" title="表语从句" /><published>2022-02-09T00:00:00+08:00</published><updated>2022-02-09T00:00:00+08:00</updated><id>http://localhost:4000/predicative-clause</id><content type="html" xml:base="http://localhost:4000/predicative-clause.html">&lt;h2 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h2&gt;

&lt;p&gt;表语从句放在连系动词之后，充当复合句中的表语。&lt;/p&gt;

&lt;p&gt;表语从句( Predicative Clause )就是指一个&lt;strong&gt;句子作为表语，说明主语是什么或者怎么样&lt;/strong&gt;，由名词、形容词或相当于名词或形容词的词或短语充当，和&lt;strong&gt;连系动词一起构成谓语&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;2-构成&quot;&gt;2-构成&lt;/h2&gt;

&lt;p&gt;主语+连系动词+句子作表语(表语从句)&lt;/p&gt;

&lt;h2 id=&quot;3-引导表语从句的关联词&quot;&gt;3-引导表语从句的关联词&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;引导表语从句的&lt;strong&gt;连系动词&lt;/strong&gt;有：&lt;strong&gt;be，look，seem，sound，appea&lt;/strong&gt;r 等
    &lt;ul&gt;
      &lt;li&gt;China is no longer what she used to be.&lt;/li&gt;
      &lt;li&gt;The question remains whether they will be able to help us.&lt;/li&gt;
      &lt;li&gt;At that time，it seemed as if I couldn’t think of the right word.&lt;/li&gt;
      &lt;li&gt;It seems to me that we should answer for this. (在我看来…)&lt;/li&gt;
      &lt;li&gt;It appears to her that he wants to teach us all he has. (在她看来…)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;从属连词 whether，as，as if / though&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;He looked just as he had looked ten years before.&lt;/li&gt;
      &lt;li&gt;It sounds as if someone is knocking at the door.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;从属连词 that&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;The trouble is that I have lost his address.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;because，why&lt;/strong&gt; 引导表语从句
    &lt;ul&gt;
      &lt;li&gt;That’s because he didn’t understand me.（强调原因；那是因为…）&lt;/li&gt;
      &lt;li&gt;That’s why he got angry with me.（强调结果；那是为什么…）&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;what 引导的主语从句&lt;strong&gt;表示结果&lt;/strong&gt;或&lt;strong&gt;名词 reason 作主语&lt;/strong&gt;时，后面的表语从句表示原因时要用 that 引导，不宜用 because.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The reason why I was sad was &lt;strong&gt;that&lt;/strong&gt; he didn’t understand me.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;连接代词/连接副词&lt;/strong&gt;引导表语从句&lt;/p&gt;

    &lt;p&gt;连接代词有 : &lt;strong&gt;who，whom，whose，what，which，whoever，whatever，whichever&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The problem is who we can get to replace her.&lt;/li&gt;
      &lt;li&gt;That was what she did this morning on reaching the attic.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;连接副词有：&lt;strong&gt;where，when，how，why&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The question is how he did it.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用虚拟语气的表语从句&lt;/p&gt;

    &lt;p&gt;在&lt;strong&gt;表示建议、劝告、命令含义的名词后的表语从句，谓语动词需用 “should+动词原形” 表示&lt;/strong&gt;(should 可省略)。&lt;/p&gt;

    &lt;p&gt;常见的词有：&lt;strong&gt;advice，suggestion，order，proposal，plan，idea&lt;/strong&gt; 等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;My suggestion is that we (should) start early tomorrow.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-总结&quot;&gt;4-总结&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;连系动词 be，appear，seem，look等之后可以跟表语从句&lt;/li&gt;
  &lt;li&gt;引导表语从句的引导词分为：
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;wh-疑问词&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;My question is who left.&lt;/li&gt;
          &lt;li&gt;What I wonder is when he left.&lt;/li&gt;
          &lt;li&gt;That’s what he wants.&lt;/li&gt;
          &lt;li&gt;This is where they once lived.&lt;/li&gt;
          &lt;li&gt;That is why he didn’t come here.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;whether&lt;/strong&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;if 不能引导表语从句&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;ul&gt;
          &lt;li&gt;My question is whether he left (or not).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;that&lt;/strong&gt;&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;that 有时可省略&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;ul&gt;
          &lt;li&gt;The fact is that he left.&lt;/li&gt;
          &lt;li&gt;The truth is（that）I didn’t go there.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;because，as，as if，as though&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;It’s just because he doesn’t know her.&lt;/li&gt;
          &lt;li&gt;Things are not always as they seem to be.&lt;/li&gt;
          &lt;li&gt;He looks as if he’s tired.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-介绍</summary></entry><entry><title type="html">宾语从句</title><link href="http://localhost:4000/object-clause.html" rel="alternate" type="text/html" title="宾语从句" /><published>2022-02-08T00:00:00+08:00</published><updated>2022-02-08T00:00:00+08:00</updated><id>http://localhost:4000/object-clause</id><content type="html" xml:base="http://localhost:4000/object-clause.html">&lt;h2 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h2&gt;

&lt;p&gt;定义：&lt;strong&gt;置于动词、介词等词性后面，在句子中起宾语作用的从句叫做宾语从句。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;宾语从句分为三类：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;动词的宾语从句&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;介词的宾语从句&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;形容词的宾语从句&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;宾语从句语法需要关注三点：时态，语序，连词。&lt;/strong&gt;宾语从句的语序必须是陈述语序，谓语动词、介词、动词不定式，v.-ing形式后面都能带宾语从句，有些形容词(afraid，sure，glad等)之后也可以带宾语从句。&lt;/p&gt;

&lt;h2 id=&quot;2-连接词&quot;&gt;2-连接词&lt;/h2&gt;

&lt;p&gt;在复合句中作主句的宾语，连接词有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;连词：that (that 常可省略), whether, if&lt;/li&gt;
  &lt;li&gt;代词：who, whose, what, which&lt;/li&gt;
  &lt;li&gt;副词：when ,where, how, why 等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-1-that-引导的宾语从句&quot;&gt;2-1 that 引导的宾语从句&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;在非正式场合that可以省略&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;可跟 that 从句做宾语的动词有：&lt;strong&gt;say, think, insist, wish, hope, demand, imagine, wonder, know, suppose, see, believe, agree, admit, deny, expect, explain, order, command, feel, dream, suggest, hear, mean, notice, prefer, request, require, propose, declare, report&lt;/strong&gt; 等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The boy believes that he will travel through space to other planets.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，&lt;strong&gt;当主句谓语动词是 think, believe, suppose, expect 等词，而宾语从句的意思是否定时，常把否定转移至主句表示。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I don’t think it is right for him to treat you like that.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在以下情况中 that 不能省略&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当句中的动词后接&lt;em&gt;多于两个由 that 引导的宾语从句&lt;/em&gt;时，第一个 that 可省，但后面的 that 不可省。
    &lt;ul&gt;
      &lt;li&gt;He said (that) you were too young to understand the matter and that he was asked not to tell you.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当&lt;em&gt;主句的谓语动词与 that 宾语从句之间有插入语&lt;/em&gt;时，that 一般不可省。
    &lt;ul&gt;
      &lt;li&gt;Just then I noticed, for the first time, that our master was wearing his fine green coat and his black silk cap.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当 &lt;em&gt;that 从句是双宾语中的直接宾语&lt;/em&gt;时，that 不可省。
    &lt;ul&gt;
      &lt;li&gt;I can’t tell him that his mother died.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;许多带复合宾语的句子，&lt;em&gt;that 引导的宾语从句经常移到句子后部，而用 it 作形式宾语&lt;/em&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I find it necessary that we should do the homework on time.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-2-whetherif-引导的宾语从句&quot;&gt;2-2 whether/if 引导的宾语从句&lt;/h3&gt;

&lt;p&gt;由 whether/if 引导的宾语从句，实际上是&lt;em&gt;一般疑问句演变而来的，&lt;/em&gt;意思是“是否”，此时&lt;strong&gt;宾语从句要用陈述句语序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一般说来，在宾语从句中 whether 与 if 可以互换使用，但在特殊情况下 if 与 whether 是不能互换的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I wonder whether(if) they will come to our party.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下场景不能互换：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;只能用 whether，不能用 if 引导的宾语从句&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;在带 to 的不定式前
        &lt;ul&gt;
          &lt;li&gt;We decided whether to walk there.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在介词的后面
        &lt;ul&gt;
          &lt;li&gt;I’m thinking of whether we should go to see the film.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;在 discuss, decided 等动词后面的宾语从句
        &lt;ul&gt;
          &lt;li&gt;We discussed whether we had a sports meeting next week.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;直接与 or not 连用时
        &lt;ul&gt;
          &lt;li&gt;I can’t say whether or not they can come on time.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;只能用 if 不能用 whether 引导的宾语从句&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;if 引导条件状语从句，意为“如果”
        &lt;ul&gt;
          &lt;li&gt;The students will go on a picnic if it is sunny.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;if 引导否定概念的宾语从句时
        &lt;ul&gt;
          &lt;li&gt;He asked if I didn’t come to school yesterday.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;引导状语从句 even if(即使)和 as if(好象)时
        &lt;ul&gt;
          &lt;li&gt;He talks as if he has known all about it.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-连接代词和连接副词引导的宾语从句&quot;&gt;2-3 连接代词和连接副词引导的宾语从句&lt;/h3&gt;

&lt;p&gt;这样的宾语从句实际上是由&lt;em&gt;特殊疑问句变化而来的&lt;/em&gt;，&lt;strong&gt;宾语从句要用陈述句语序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;用于这种结构的动词常常是：&lt;strong&gt;see, say, tell, ask, answer, know, decide, show, find out, imagine, suggest, doubt, wonder, discover, understand, inform, advise&lt;/strong&gt; 等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;连接代词有：who, whom, whose, which, what，在&lt;strong&gt;句中担任主语、宾语、定语或者表语&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;Can you tell me whom you are waiting for?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;连接副词有：when,where,why,how，在&lt;strong&gt;句中担任状语的成分&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;None of us knows where these new parts can be bought.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-语序&quot;&gt;3-语序&lt;/h2&gt;

&lt;p&gt;无论主句是陈述句还是疑问句，&lt;strong&gt;宾语从句都必须使用陈述语序&lt;/strong&gt;，即“主句+连接词+宾语从句(主语+谓语+……)”句式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Could you tell me who knows the answer?&lt;/li&gt;
  &lt;li&gt;The small children don’t know what is in their stockings.&lt;/li&gt;
  &lt;li&gt;He asked whose handwriting was the best in our class.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-时态&quot;&gt;4-时态&lt;/h2&gt;

&lt;p&gt;含宾语从句的复合句，主句、从句谓语动词的时态呼应，包括以下几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;主句的谓语动词是一般现在时，从句的谓语动词可根据需要，选用相应的&lt;strong&gt;任何时态&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;I don’t know when he will come back.&lt;/li&gt;
      &lt;li&gt;He tells me that his sister came back yesterday.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;主句的谓语动词是过去时，宾语从句的谓语动词只可根据需要，选用过去时态即&lt;strong&gt;一般过去时、过去进行时、过去将来时或过去完成时的某一种形式&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;The children didn’t know who he was.&lt;/li&gt;
      &lt;li&gt;He asked his father how it happened.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果宾语从句所表示的是&lt;em&gt;客观事实、普遍真理、自然现象或习惯性动作&lt;/em&gt;等，不管主句用什么时态，&lt;em&gt;从句时态都用一般现在时&lt;/em&gt;。
    &lt;ul&gt;
      &lt;li&gt;The teacher said that the earth goes round the sun.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-总结&quot;&gt;5-总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;宾语从句可以作及物动词、介词及形容词的宾语。&lt;/li&gt;
  &lt;li&gt;宾语从句的语序一律用陈述句语序。&lt;/li&gt;
  &lt;li&gt;连接词 that 引导宾语从句在句中无词义，不充当句子成份，多数情况下可以省略。&lt;/li&gt;
  &lt;li&gt;whether 和 if 都可引导宾语从句，但 whether 后可紧跟 or not；whether 从句可作介词的宾语。&lt;/li&gt;
  &lt;li&gt;如果从句太长，可以用形式宾语it。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-介绍</summary></entry><entry><title type="html">过去完成时</title><link href="http://localhost:4000/perfect-past-tense.html" rel="alternate" type="text/html" title="过去完成时" /><published>2022-01-20T00:00:00+08:00</published><updated>2022-01-20T00:00:00+08:00</updated><id>http://localhost:4000/perfect-past-tense</id><content type="html" xml:base="http://localhost:4000/perfect-past-tense.html">&lt;h2 id=&quot;含义与结构&quot;&gt;含义与结构&lt;/h2&gt;

&lt;p&gt;过去完成时表示&lt;strong&gt;&lt;em&gt;过去某一时间或动作&lt;/em&gt;&lt;/strong&gt;以前已经发生或完成了的动作，对过去的某一点造成的某种影响或是结果，用来指&lt;strong&gt;在另一个过去动作之前就已经完成了的事件&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;动作发生的时间是”过去的过去”，侧重事情的结果。&lt;/p&gt;

&lt;p&gt;基本结构为：&lt;strong&gt;主语+had+动词过去分词&lt;/strong&gt;（done）&lt;/p&gt;

&lt;h2 id=&quot;用法&quot;&gt;用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;表示在&lt;strong&gt;过去某一时刻或动作以前完成了的动作&lt;/strong&gt;，表示“过去的过去”；可以用 &lt;strong&gt;by, before&lt;/strong&gt; 等介词短语或一个时间状语从句来表示，也可以用一个表示过去的动作来表示，还可能通过上下文来表示。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;By&lt;/strong&gt; the time I got outside, the bus had already left.&lt;/li&gt;
      &lt;li&gt;She had studied English for six years &lt;strong&gt;before&lt;/strong&gt; she went to college.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示由过去的某一时刻开始，一直&lt;strong&gt;延续到过去另一时间&lt;/strong&gt;的动作或状态，常和 &lt;strong&gt;for, since&lt;/strong&gt; 构成的时间状语连用。
    &lt;ul&gt;
      &lt;li&gt;He had lived in the house &lt;strong&gt;for&lt;/strong&gt; five years.&lt;/li&gt;
      &lt;li&gt;He said he had worked in that factory &lt;strong&gt;since&lt;/strong&gt; 1949.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;叙述过去发生的事情，在已叙述了过去发生的事情后，反过来&lt;strong&gt;追述或补述以前发生的动作&lt;/strong&gt;时，常使用过去完成时。
    &lt;ul&gt;
      &lt;li&gt;Mr. Smith died yesterday. He had been a good friend of mine.&lt;/li&gt;
      &lt;li&gt;I didn’t know a thing about the verbs, for I had not studied my lesson.（因为我没有好好学习，作为补充）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在含有定语从句的&lt;strong&gt;主从复合句&lt;/strong&gt;中，如果&lt;strong&gt;叙述的是过去的事&lt;/strong&gt;，&lt;strong&gt;先发生的动作常用过去完成时&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;I returned the book that I had borrowed.&lt;/li&gt;
      &lt;li&gt;She found the key that she had lost.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;过去完成时常常&lt;strong&gt;用在 told, said, knew, heard, thought 等动词后的宾语从句&lt;/strong&gt;（或间接引语）中，这时从句中的动作发生在主句表示的过去的动作之前。
    &lt;ul&gt;
      &lt;li&gt;He said that he had known her well.&lt;/li&gt;
      &lt;li&gt;I thought I had sent the letter a week before.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;含有时间状语从句，对于过去不同时间发生的两个动作，&lt;strong&gt;发生在前的动作，用过去完成时；发生在后的动作，用一般过去时&lt;/strong&gt;。如 &lt;strong&gt;when, before, after, as soon as, till/until 引导的从句。&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;When&lt;/strong&gt; I woke up, it had already stopped raining.&lt;/li&gt;
      &lt;li&gt;She didn’t go to bed &lt;strong&gt;until&lt;/strong&gt; she had finished her work.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;需要注意的是，如果&lt;strong&gt;两个动作紧接着发生&lt;/strong&gt;，则常常不用过去完成时，特别是在包含 &lt;strong&gt;before&lt;/strong&gt; 和&lt;strong&gt;after&lt;/strong&gt; 的复合句中，因为这时&lt;em&gt;从句的动作和主句的动作发生的先后顺序已经非常明确&lt;/em&gt;，可以用一般过去时代替过去完成时。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;After he arrived in England, Marx worked hard to improve his English.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动词 &lt;strong&gt;think, want, hope, mean, plan, intend 等用过去完成时来表示过去未曾实现&lt;/strong&gt;的想法，希望，打算或意图等。
    &lt;ul&gt;
      &lt;li&gt;They &lt;strong&gt;had wanted&lt;/strong&gt; to help but could not get there in time.&lt;/li&gt;
      &lt;li&gt;We &lt;strong&gt;had hoped&lt;/strong&gt; to be able to come and see you.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;过去完成时还可用在 &lt;strong&gt;hardly…when…, no sooner…than…, It was the first (second, etc) time (that)…&lt;/strong&gt; 等固定句型中。
    &lt;ul&gt;
      &lt;li&gt;Hardly had he begun to speak when the audience interrupted him.（一 … 就 …，倒装句）&lt;/li&gt;
      &lt;li&gt;No sooner had he arrived than he went away again.（一 … 就 …，倒装句）&lt;/li&gt;
      &lt;li&gt;It was the third time that he had been out of work that year.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">含义与结构</summary></entry><entry><title type="html">such &amp;amp; so</title><link href="http://localhost:4000/such-and-so.html" rel="alternate" type="text/html" title="such &amp;amp; so" /><published>2022-01-20T00:00:00+08:00</published><updated>2022-01-20T00:00:00+08:00</updated><id>http://localhost:4000/such-and-so</id><content type="html" xml:base="http://localhost:4000/such-and-so.html">&lt;p&gt;such 和 so 都可以&lt;strong&gt;表示程度&lt;/strong&gt;，含有“如此、这/那样、这/那么”的意思，但它们在用法上有一定区别。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;such 为形容词，一般&lt;strong&gt;修饰名词&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;so 为副词，一般&lt;strong&gt;修饰形容词或副词&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;such-用法&quot;&gt;such 用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;such + a/an + 可数名词单数
    &lt;ul&gt;
      &lt;li&gt;All of us have never seen &lt;strong&gt;&lt;em&gt;such an animal before&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
      &lt;li&gt;He said he would rather be poor than get money &lt;strong&gt;&lt;em&gt;in such a way&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + a/an + 形容词 + 可数名词单数
    &lt;ul&gt;
      &lt;li&gt;She is &lt;strong&gt;&lt;em&gt;such a good teacher&lt;/em&gt;&lt;/strong&gt; just as we expect.&lt;/li&gt;
      &lt;li&gt;I really thank you for giving &lt;strong&gt;&lt;em&gt;such an exciting party&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 可数名词复数
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Such things&lt;/em&gt;&lt;/strong&gt; often happen in our daily life.&lt;/li&gt;
      &lt;li&gt;I don’t think &lt;strong&gt;&lt;em&gt;such people&lt;/em&gt;&lt;/strong&gt; are dangerous.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 形容词 + 可数名词复数
    &lt;ul&gt;
      &lt;li&gt;He told us &lt;strong&gt;&lt;em&gt;such funny stories&lt;/em&gt;&lt;/strong&gt; that we all couldn’t help laughing.&lt;/li&gt;
      &lt;li&gt;He’s amazed to see &lt;strong&gt;&lt;em&gt;such beautiful fishes&lt;/em&gt;&lt;/strong&gt; under the sea.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 不可数名词
    &lt;ul&gt;
      &lt;li&gt;When he knew &lt;strong&gt;&lt;em&gt;such news&lt;/em&gt;&lt;/strong&gt;, he began to cry.&lt;/li&gt;
      &lt;li&gt;It’s dangerous to go swimming in &lt;strong&gt;&lt;em&gt;such weather&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;such + 形容词 + 不可数名词
    &lt;ul&gt;
      &lt;li&gt;We are glad to see that he has made &lt;strong&gt;&lt;em&gt;such rapid progress&lt;/em&gt;&lt;/strong&gt; in English this term.&lt;/li&gt;
      &lt;li&gt;I’ll remember &lt;strong&gt;&lt;em&gt;such delicious food&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;so-用法&quot;&gt;so 用法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;so + 形容词/副词
    &lt;ul&gt;
      &lt;li&gt;It’s &lt;strong&gt;&lt;em&gt;so cold&lt;/em&gt;&lt;/strong&gt; outside. We’d better wear warm clothes.&lt;/li&gt;
      &lt;li&gt;He spoke &lt;strong&gt;&lt;em&gt;so fast&lt;/em&gt;&lt;/strong&gt; that I couldn’t follow.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;so + 形容词 + a/an + 可数名词单数
    &lt;ul&gt;
      &lt;li&gt;He’s &lt;strong&gt;&lt;em&gt;so kind a man&lt;/em&gt;&lt;/strong&gt; that everybody here likes him.&lt;/li&gt;
      &lt;li&gt;It’s &lt;strong&gt;&lt;em&gt;so easy an exercise&lt;/em&gt;&lt;/strong&gt; that every one of us can do it.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;这种句式可以和 such + a/an + 形容词 + 可数名词单数换用：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I’ve never seen so amusing a film. = I’ve never seen such an amusing film.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;so + many/much/few/little + 可数名词复数/不可数名词
    &lt;ul&gt;
      &lt;li&gt;There are &lt;strong&gt;&lt;em&gt;so many visitors&lt;/em&gt;&lt;/strong&gt; in our school today.&lt;/li&gt;
      &lt;li&gt;I have eaten &lt;strong&gt;&lt;em&gt;so much food&lt;/em&gt;&lt;/strong&gt;. I don’t want to eat any more.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;so many 已成固定搭配，a lot of 虽相当于 many，但 a lot of 为名词性的，只能用 such 搭配。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I feel very happy that I have such a lot of friends.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">such 和 so 都可以表示程度，含有“如此、这/那样、这/那么”的意思，但它们在用法上有一定区别。</summary></entry><entry><title type="html">Dynamo: Amazon’s Highly Available Key-value Store</title><link href="http://localhost:4000/dynamo.html" rel="alternate" type="text/html" title="Dynamo: Amazon’s Highly Available Key-value Store" /><published>2022-01-18T00:00:00+08:00</published><updated>2022-01-18T00:00:00+08:00</updated><id>http://localhost:4000/dynamo</id><content type="html" xml:base="http://localhost:4000/dynamo.html">&lt;h1 id=&quot;1-abstract&quot;&gt;1-Abstract&lt;/h1&gt;

&lt;p&gt;Dynamo 是 Amazon 提出的&lt;strong&gt;高可用键值存储&lt;/strong&gt;系统。为了保证系统的高可用，&lt;em&gt;牺牲了一些特定场景下的一致性&lt;/em&gt;。Dynamo 使用了&lt;strong&gt;对象版本化（object versioning）&lt;/strong&gt;与&lt;strong&gt;应用协助解决冲突（application-assisted conflict resolution）&lt;/strong&gt;的机制。&lt;/p&gt;

&lt;h1 id=&quot;2-introduction&quot;&gt;2-Introduction&lt;/h1&gt;

&lt;p&gt;Amazon 的基础设施由数百万台设备组成，任何时刻都会有比例小但是数量不少的设备发生故障。因此，可以将故障看作是正常的，可预期的行为，&lt;em&gt;软件系统不应该因为硬件设备故障影响自身的可用性与性能&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;Dynamo 的目标是实现一个&lt;strong&gt;永远可用（always available）&lt;/strong&gt;的系统：即使服务器故障或者网络异常，用户也能往自己的购物车里添加商品。基于以下技术保证了高可用性与高扩展性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据通过&lt;strong&gt;一致性 Hash 进行分区与复制&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;通过&lt;strong&gt;对象版本化&lt;/strong&gt;实现一致性（最终一致性）&lt;/li&gt;
  &lt;li&gt;数据副本之间的一致性通过“&lt;strong&gt;类似仲裁的技术&lt;/strong&gt;”与“&lt;strong&gt;去中心化的副本同步协议&lt;/strong&gt;”保证&lt;/li&gt;
  &lt;li&gt;以 gossip 协议为基础的分布式&lt;strong&gt;故障检测与成员检测&lt;/strong&gt;协议&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dynamo 系统通过组合不同的技术实现一个高度可用（high-available）的系统，并证明了最终一致性存储系统可以用于生产环境，满足应用的高可用要求。&lt;/p&gt;

&lt;h1 id=&quot;3-background&quot;&gt;3-Background&lt;/h1&gt;

&lt;p&gt;Amazon 电商平台由几百个服务组成，有些服务是无状态的（如聚合其他服务响应的服务），有些服务是有状态的（如基于存储在数据仓库中的状态，执行业务逻辑并产生响应的服务）。传统上，服务状态使用关系型数据库存储；但是，对很多&lt;strong&gt;持久状态的存储&lt;/strong&gt;需求来说，关系型数据库有一些局限性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;该类型的服务大部分情况下只需要&lt;strong&gt;使用主键检索&lt;/strong&gt;，并不需要关系型数据库提供的复杂查询和管理功能&lt;/li&gt;
  &lt;li&gt;关系型数据库的复制功能受限，而且通常通过&lt;strong&gt;牺牲可用性来换取一致性&lt;/strong&gt;；水平扩展（scale-out）不足&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对关系型数据库的不足，Dynamo 能够做到高度可用，有定义清晰的一致性窗口（clearly defined consistency window），易用的水平扩展方案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dynamo 支持独立部署，不同的业务使用不同的 Dynamo 系统&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-1-system-assumptions-and-requirements&quot;&gt;3-1-&lt;strong&gt;System Assumptions and Requirements&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;对接入 Dynamo 的服务有以下假设：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查询模型（&lt;em&gt;Query Model&lt;/em&gt;）
    &lt;ol&gt;
      &lt;li&gt;通过&lt;em&gt;唯一 key&lt;/em&gt; 进行数据读写操作&lt;/li&gt;
      &lt;li&gt;任何读写操作都&lt;em&gt;不会跨多个数据单元&lt;/em&gt;（data item）&lt;/li&gt;
      &lt;li&gt;没有关系型 schema 需求&lt;/li&gt;
      &lt;li&gt;需要存储的&lt;em&gt;文件较小&lt;/em&gt;（&amp;lt; 1MB）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ACID 特性（&lt;em&gt;ACID Properties&lt;/em&gt;）
    &lt;ol&gt;
      &lt;li&gt;在数据库领域中，ACID 是保证事务可靠执行的保证；但是这些特性会牺牲系统的可用性。Dynamo 实现目标是：&lt;em&gt;允许通过牺牲一些一致性（C）提高可用性&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;Dynamo &lt;em&gt;不提供任何隔离保证&lt;/em&gt;，只允许单个key 的更新操作&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;效率（&lt;em&gt;Efficiency&lt;/em&gt;）
    &lt;ol&gt;
      &lt;li&gt;系统需要满足严格的 SLA（通过 TP999 衡量）；并允许业务自定义配置 Dynamo 以满足吞吐量 &amp;amp; 延迟的需求&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-2-design-considerations&quot;&gt;3-2-&lt;strong&gt;Design Considerations&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;为了达到强一致性，一般数据库会采用同步复制算法&lt;/em&gt;。这类算法在某些故障场景下牺牲了可用性，如当数据出现冲突，则暂时禁止对该数据的访问，直到冲突解决。&lt;/p&gt;

&lt;p&gt;分布式系统是无法同时满足 C（强一致性），A（高可用性），P（网络故障容忍）三个特性；因此，在不同的业务场景下需要选择不同的特性：是强一致性还是高可用性。&lt;/p&gt;

&lt;p&gt;在服务器与网络故障比较高的场景下，可以通过&lt;strong&gt;乐观复制&lt;/strong&gt;（optimistic replication）提高可用性：在后台通过异步同步将数据变更复制到其他节点，能够容忍并发更新与操作异常。不过这种方式虽然能够提高可用性，但是会导致数据冲突，需要检测并修复冲突。那么：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;什么时候解决冲突&lt;/li&gt;
  &lt;li&gt;由谁解决冲突&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dynamo 被设计为&lt;strong&gt;最终一致性数据仓库（eventually consistent data store）&lt;/strong&gt;，所有的数据变更最后都会同步到所有副本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;什么时候解决冲突&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;解决冲突的时机有两个：读时 &amp;amp; 写时。&lt;/p&gt;

    &lt;p&gt;传统数据库在写时解决冲突，可以使得读操作比较简单。这种方式在&lt;em&gt;系统不能访问大部分（或者全部）副本时，就会拒绝写&lt;/em&gt;。&lt;/p&gt;

    &lt;p&gt;Dynamo 期望保证&lt;strong&gt;永远可写&lt;/strong&gt;（always writeable），所以在&lt;em&gt;数据读取时解决冲突&lt;/em&gt;，以保证写操作不会被拒绝。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;谁解决冲突&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;冲突解决方也有两个：业务服务 &amp;amp; 数据库。&lt;/p&gt;

    &lt;p&gt;如果由数据库来解决，只能执行一些简单的策略，如最后写有效（last write wins）。&lt;/p&gt;

    &lt;p&gt;由于业务服务能够更了解数据的作用，可以更加&lt;em&gt;灵活地选择对用户体验最好的冲突解决算法&lt;/em&gt;，如合并冲突的版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他设计原则&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;增量扩展性（Incremental scalability）&lt;/strong&gt;：支持逐个节点扩容，并减小对系统的影响&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;对称性（Symmetry）&lt;/strong&gt;：&lt;em&gt;每个节点的职责应该是相同的&lt;/em&gt;；对称性简化了系统的运维&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;去中心化（Decentralization）&lt;/strong&gt;：去中心化是对称性的进一步扩展；系统应该是去中心化，点对点的，而不是集中控制；&lt;em&gt;去中心化能够使得系统更加简单，更具可扩展性 &amp;amp; 可用性&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;异构性（Heterogeneity）：负载的分布要与节点的承载能力成正比&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;传统复制型关系数据库将关注点都放在保证副本强一致性上；虽然强一致性可以&lt;strong&gt;给应用的写操作提供方便的编程模型&lt;/strong&gt;， 但&lt;em&gt;导致系统的扩展性和可用性非常受限，无法处理网络分裂的情况。&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-system-architecture&quot;&gt;4-System Architecture&lt;/h1&gt;

&lt;p&gt;Dynamo 使用的分布式系统技术有：&lt;strong&gt;分区&lt;/strong&gt;（partition），&lt;strong&gt;复制&lt;/strong&gt;（replication），&lt;strong&gt;版本化&lt;/strong&gt;（versioning），&lt;strong&gt;成员管理&lt;/strong&gt;（membership），&lt;strong&gt;故障处理&lt;/strong&gt;（failure handling），&lt;strong&gt;规模扩展&lt;/strong&gt;（scaling）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo/dynamo_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下表展示了这些技术的优势：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;问题&lt;/th&gt;
      &lt;th&gt;技术&lt;/th&gt;
      &lt;th&gt;优势&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;数据分区&lt;/td&gt;
      &lt;td&gt;一致性 Hash&lt;/td&gt;
      &lt;td&gt;增量可扩展性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;写操作高可用&lt;/td&gt;
      &lt;td&gt;读时协调（冲突解决）的向量时钟&lt;/td&gt;
      &lt;td&gt;版本大小与更新频率解耦&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;短时故障处理&lt;/td&gt;
      &lt;td&gt;宽松的选举和 hinted handoff&lt;/td&gt;
      &lt;td&gt;部分副本不可用时，仍然可以保证高可用性和持久性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;持久故障恢复&lt;/td&gt;
      &lt;td&gt;基于 Merkle tree 的逆熵&lt;/td&gt;
      &lt;td&gt;后台同步版本不一致的副本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;成员管理与故障检测&lt;/td&gt;
      &lt;td&gt;基于 Gossip 协议的成员管理协议和故障检测&lt;/td&gt;
      &lt;td&gt;保持了架构的对称性：无需一个中心组件（centralized registry）来存储成员和节点状态等信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;4-1-system-interface&quot;&gt;4-1 System Interface&lt;/h2&gt;

&lt;p&gt;Dynamo 系统提供两个简单的接口：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;get(key)&lt;/li&gt;
  &lt;li&gt;put(key)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get(key)&lt;/code&gt; 会&lt;em&gt;定位到存储系统中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt; 对应的所有对象副本&lt;/em&gt;，&lt;strong&gt;返回对象（&lt;/strong&gt;可能是单个对象，也可能是一个对象列表: 有冲突情况下，包括了所有版本），&lt;strong&gt;以及一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt;（ 上下文）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put(key)&lt;/code&gt; 确定对象应该存放的位置，然后写到相应的磁盘（put 请求会携带 context 上报）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt; 包含了系统中对象的元数据，例如&lt;strong&gt;对象的版本&lt;/strong&gt;，对调用方是不透明的（ opaque）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上下文信息是和对象存储在一起的，这样系统容易验证 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put&lt;/code&gt; 请求的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt; 是否合法&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Dynamo 将调用方提供的 key 和对象都视为不透明的字节序列（opaque array of bytes） 。它对 key 应用 MD5 Hash 得到一个 128bit 的 ID，并根据这个 ID 计算应该存储到哪些节点。&lt;/p&gt;

&lt;h2 id=&quot;4-2-partitioning-algorithm&quot;&gt;4-2 &lt;strong&gt;Partitioning Algorithm&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Dynamo 的一个核心需求是：支持数据&lt;strong&gt;增量扩展&lt;/strong&gt;（scale incrementally）。为了实现该目标，需要将数据分散到系统中的不同节点上。Dynamo 采取的方案是&lt;strong&gt;一致性 Hash&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在一致性哈希中，哈希函数的&lt;strong&gt;输出是一个固定的范围，&lt;/strong&gt;通常作为一个&lt;strong&gt;循环空间，或称环（ring）&lt;/strong&gt;。&lt;strong&gt;每个节点都会随机分配一个在这个循环空间内的值&lt;/strong&gt;，这个值代表了节点在这个环上的位置。&lt;/p&gt;

&lt;p&gt;如何确定一条数据对应的存储节点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对 key 进行哈希得到一个哈希值&lt;/li&gt;
  &lt;li&gt;在环上沿着顺时针方向找到第一个&lt;strong&gt;所带的值比这个哈希值更大的节点&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每个节点要负责环上从它自己到它的下一个节点之间的区域。&lt;strong&gt;一致性哈希的主要好处是 ：添加或删除节点只会影响相邻的节点，其他节点不受影响。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不过基础的一致性 Hash 算法有些问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给每个节点分配一个随机位置会导致数据与负载的非均匀分配&lt;/li&gt;
  &lt;li&gt;未考虑节点的异构（不同节点配置不同，对应的性能也不同）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dynamo 使用&lt;strong&gt;虚拟节点&lt;/strong&gt;（virtual node）进行优化：&lt;strong&gt;一个物理节点对应多个虚拟节点，每个虚拟节点分散到环上的不同位置&lt;/strong&gt;，能够有效进行负载的均匀分配。&lt;/p&gt;

&lt;p&gt;引用了虚拟节点之后：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点不可用时，其负载会均匀分散到其他可用节点上&lt;/li&gt;
  &lt;li&gt;新增节点会获得与其他节点大致相同的负载&lt;/li&gt;
  &lt;li&gt;一个物理节点对应的虚拟节点数目可以根据其实际性能来决定，可以充分考虑机器的异构性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-3-replication&quot;&gt;4-3 &lt;strong&gt;Replication&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;为了实现高可用性和持久性，Dynamo 将数据复制到 N 台机器上（N 可配）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个 key &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt;，会被分配一个 Coordinator（协调者）&lt;/strong&gt;节点。 Coordinator &lt;strong&gt;负责落到它管理的范围内的数据的复制&lt;/strong&gt;。Coordinator 除了自己存储一份之外，还会在环上顺时针方向的其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N-1&lt;/code&gt; 个节点复制一份副本。因此在系统中，每个节点要负责从它自己往后的一共 N 个节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo/dynamo_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在图中，K 不仅存储在节点 B 中，还存储在节点 C，D 中。由于每个节点会保存其前继节点中的数据，所以节点 D 中包含的 Key 范围为 (A, D]，C 的范围为 (A, C]。&lt;/p&gt;

&lt;p&gt;在 Dynamo 中有一个&lt;strong&gt;优先列表&lt;/strong&gt;（preference list）概念：&lt;em&gt;存储某个特定 key 的所有节点组成一个列表&lt;/em&gt;&lt;strong&gt;。对于给定的 key，每个节点都能决定哪些节点可以进入这个列表&lt;/strong&gt;。为了应对节点失效的情况，preference list 会包含&lt;strong&gt;超过&lt;/strong&gt; N 个节点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;every node in the system can determine which nodes should be in this list for any particular key. To account for node failures, preference list contains more than N nodes.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;由于引入了虚拟节点，存储一个 key 的 N 个节点，实际上对应的物理节点可能少于 N 个（例如，一个节点可能会占用环上的不止一个节点）。为了避免这个问题 ，preference list 在选择节点的时候会跳过一些位置，以&lt;strong&gt;保证 list 里面的节点都在不同的物理节点上&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;4-4-data-versioning&quot;&gt;4-4 &lt;strong&gt;Data Versioning&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Dynamo 提供&lt;strong&gt;最终一致性&lt;/strong&gt;，所有数据变更操作会在后台异步传递给其他副本。&lt;/p&gt;

&lt;p&gt;在这种情况下，当 put(key) 返回时，最新数据可能还没有复制到 preference list 中的所有副本。此时进行 get(key) 操作可能不会获取到最新的数据，那么之后的更新操作会在旧数据上进行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;异步更新在没有故障的情况下会有一个耗时上限，但是如果存在故障（如网络分区），所有副本的更新耗时可能会无限大&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Dynamo 为了保证&lt;strong&gt;始终可写&lt;/strong&gt;的特性，需要容忍这种不一致性，&lt;strong&gt;将不同更新结果都保留，并在之后的步骤中处理更新冲突&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;加入用户向购物车中添加商品 A，之后查询购物车为空并重新添加商品 B，此时 Dynamo 需要将 A，B 两个商品都保留并在之后解决冲突&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-4-1-how-to-fix-conflicts&quot;&gt;4-4-1 How to Fix Conflicts&lt;/h3&gt;

&lt;p&gt;为了实现该目标，&lt;strong&gt;&lt;em&gt;Dynamo 将每次更新结果都作为一个新的，不可变更的版本&lt;/em&gt;&lt;/strong&gt;，则系统中会&lt;strong&gt;同时存在多个不同的版本&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;大部分情况下，新版本都包含旧版本的数据，而且系统自己可以判断哪个是权威版本&lt;/strong&gt; （syntactic reconciliation）；但是，在发生故障并且存在并发更新的场景下，版本会发生&lt;strong&gt;分叉&lt;/strong&gt;（version branching），导致&lt;strong&gt;对象版本冲突&lt;/strong&gt;。系统本身无法处理这种情况，需要&lt;strong&gt;客户端介入&lt;/strong&gt;，将多个分支合并成一个。&lt;/p&gt;

&lt;p&gt;冲突的版本可能会有多个，并且每个版本都有自己的子历史版本，这些版本都需要系统来将其一致化。&lt;/p&gt;

&lt;h3 id=&quot;4-4-2-vector-clock&quot;&gt;4-4-2 Vector Clock&lt;/h3&gt;

&lt;p&gt;Dynamo 使用&lt;strong&gt;向量时钟&lt;/strong&gt;（vector clock）来&lt;strong&gt;跟踪同一对象不同版本之间的因果性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一个向量时钟就是一个 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(node, counter)&lt;/code&gt; 列表&lt;/strong&gt;，如 D [(node-1, 2), [node-2, 3], [node-3, 1]]。&lt;strong&gt;一个向量时钟关联了一个对象的所有版本&lt;/strong&gt;，可以通过其来判断对象的两个版本是否在并行的分支上，或者它们是否有因果关系。如果对象的第一个时钟上的所有 counter 都小于它的第二个时钟上的 counter，那第一个时钟就是第二的祖先，可以安全的删除；否则，这两个修改就是有冲突的，需要解决冲突。&lt;/p&gt;

&lt;p&gt;客户端更新对象时，&lt;strong&gt;必须要先指定基于哪个版本进行更新&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;执行 get(key) 操作获取 context 信息：包含了 vector clock&lt;/li&gt;
  &lt;li&gt;基于指定的版本进行更新：携带 context&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Dynamo 在收到客户端的读请求后，如果能够获取到多个版本，并且无法解决这些版本之间的冲突，那么 Dynamo 会返回所有的版本，并在 context 中携带各个版本对应的 vector clock 信息。&lt;strong&gt;客户端在收到多个版本之后，解决冲突，并基于指定版本更新，将多个分支重新合并为一个新分支&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo/dynamo_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图展示了 vector clock 的用法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端 A 创建一个新的对象，并且该 put 请求被节点 Sx 处理。Sx 增加该对象的序列号 1，并使用该序列号创建该对象的 vector clock。系统中此时存在对象 D1 及对应的 clock: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx, 1)]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;客户端 A 更新该对象，假设更新请求被同一个节点 Sx 处理，那么系统中新增另一个对象 D2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx, 2)]&lt;/code&gt;。由于 D2 继承自 D1，因此可以覆盖 D1。&lt;em&gt;Dynamo 异步复制数据，所以可能存在节点包含了 D1，但是并没有 D2&lt;/em&gt;。&lt;/li&gt;
  &lt;li&gt;客户端 A 再次更新该对象（会先读并获取 D2），并且更新请求被另一个节点 Sy 处理；那么系统中就会存在对象 D3 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx, 2), (Sy, 1)]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;客户端 B 读取了 D2 并尝试更新，并且该请求被另一个节点 Sz 处理；那么系统中就会存在对象 D4 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx2,  2),(Sx, 1)]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;现在 Dynamo 系统中存在多个版本的对象：D1, D2, D3, D4
    &lt;ol&gt;
      &lt;li&gt;如果一个节点知道了 D1 或 D2 的存在，那么当其接收到 D4 时，能够判断 D1 或 D2 被新的数据（D4）覆盖了，此时可以直接回收 D1, D2&lt;/li&gt;
      &lt;li&gt;如果一个节点知道 D3 的存在，那么当其收到 D4 时，会发现 D3, D4 是冲突的（没有因果关系）。&lt;em&gt;这两个版本都应该被保留，并且待客户端下次读的时候全部返回，交给客户端解决冲突&lt;/em&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;客户端读取到了 D3, D4，返回的 context 综合了 D3, D4 的 clock: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx, 2),(Sy, 1),(Sz, 1)]&lt;/code&gt;。如果客户端解决冲突并在节点 Sx 进行协调写操作，那么 Sx 会更新自己的序列号，生成的新对象 D5 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Sx, 3),(Sy, 1),(Sz, 1)]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;vector clock 存在一个问题：如果多个节点先后执行同一个对象的写操作，那么该对象的时钟向量就会变得很长。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般写操作只会被 preference list 中的前 N 个节点执行，长度可控&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;4-5-execution-of-get--and-put--operations&quot;&gt;4-5 Execution of Get () and Put () Operations&lt;/h2&gt;

&lt;p&gt;在 Dynamo 中，&lt;strong&gt;任意节点都可以处理任意 key 的 get() &amp;amp; put() 请求&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;操作请求路由有两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;由负载均衡器根据节点的负载选择一个节点进行请求&lt;/li&gt;
  &lt;li&gt;使用能够感知分区的客户端，将请求直接路由到 coordinator 节点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;负责处理读写请求的节点被称为 coordinator&lt;/strong&gt;。一般情况下 coordinator 是 preference list 中&lt;strong&gt;前 N 个节点中的第一个&lt;/strong&gt;（注意 list 中的节点数大于 N）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果请求是通过负载均衡器转发的，那么可能会被路由到任意一个节点上。此时，如果被路由的节点不是 preference list 中前 N 个节点的第一个节点，那么它不会处理该请求，而是将请求转发到 list 中第一个节点&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;读写操作需要 preference list 中前 N 个节点都处于健康状态&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果前 N 个节点均健康，则取前 N 个节点&lt;/li&gt;
  &lt;li&gt;如果前 N 个节点中存在不可用节点，则跳过，优先访问 list 中编号较小的节点&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-5-1-quorum-algrithom&quot;&gt;4-5-1 Quorum Algrithom&lt;/h3&gt;

&lt;p&gt;为了保证副本的一致性，Dynamo 使用了一种类似仲裁系统（quorum systems）的一致性协议。 这个协议有两个配置参数：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;：&lt;strong&gt;允许执行一次读操作所需的最少投票者&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt;：&lt;strong&gt;允许执行一次写操作所需的最少投票者&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;并且  &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R + W &amp;gt; N&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种情况下， get or put 的延迟由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;（或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt;）个&lt;strong&gt;副本中最慢的一个决 定&lt;/strong&gt;。因此，为了降低延迟，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt; 通常设置的比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; 小。&lt;/p&gt;

&lt;h3 id=&quot;4-5-2-get--and-put--operations&quot;&gt;4-5-2 Get () and Put () Operations&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Put() 操作流程&lt;/strong&gt; ：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;coordinator 收到 put() 请求后，创建新的 vector clock，并将其保存在本地&lt;/li&gt;
  &lt;li&gt;coordinator 将最新的版本对象&lt;em&gt;发送给 preference list 中前 N 个健康节点&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;前 N 个节点中如果有至少 W-1 个节点返回成功，则该 put() 请求成功&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Get() 操作流程&lt;/strong&gt; ：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;coordinator 收到 get() 请求后，向 preference list 中前 N 个健康节点查询该 key 对应的数据版本&lt;/li&gt;
  &lt;li&gt;coordinator 收到 R 个响应之后，将结果返回给客户端
    &lt;ol&gt;
      &lt;li&gt;如果 coordinator 获取到了多个版本，会将&lt;strong&gt;没有因果关系的版本返回给客户端&lt;/strong&gt;，客户端需要对该结果进行&lt;strong&gt;冲突解决&lt;/strong&gt;，合并成最新版本，然后&lt;strong&gt;将结果重新回写 Dynamo&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-6-handling-failures-hinted-handoff&quot;&gt;4-6 Handling Failures: Hinted Handoff&lt;/h2&gt;
&lt;p&gt;传统的仲裁算法无法保证 Dynamo 系统在节点失效或者网络分区的情况下仍然可用，持久性也会降低。&lt;/p&gt;

&lt;p&gt;因此，Dynamo 采用&lt;strong&gt;宽松的仲裁机制&lt;/strong&gt;（sloppy quorum）：&lt;strong&gt;所有读写操作在 preference list 的前 N 个健康节点执行&lt;/strong&gt;（&lt;em&gt;前 N 个健康节点不一定是前 N 个节点，如果遇到不健康的节点，会顺延&lt;/em&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo/dynamo_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在之前数据分区的例子中，N =3。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 A 节点临时不可用，那么本应该发送给 A 的更新请求会被发送到 D&lt;/li&gt;
  &lt;li&gt;发送到 D 的副本的元数据中会提示 (hint) 这个副本本应该发送给 A&lt;/li&gt;
  &lt;li&gt;该数据被 D 保存到本地一个独立的数据库中
    &lt;ul&gt;
      &lt;li&gt;D 有一个定时任务不断扫描，如果发现 A 重新变得可用了，就将数据发送给 A&lt;/li&gt;
      &lt;li&gt;成功发送回 A 之后，D 可以将该数据从本地数据库中删除；以&lt;strong&gt;保证系统内的副本数保持不变&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过 hinted handoff 机制，保证了&lt;strong&gt;在节点或者网络发生临时故障时，读写操作不会失败，提高了可用性与持久性&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过配置不同的 R 与 W，可以满足不同级别的可用性与持久性；W = 1 可用性最高，但是持久性较低&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;为了提高容灾等级，保证整个数据中心挂掉的情况下系统仍然可用，可以将 preference list 中的节点分散到不同的数据中心。&lt;/p&gt;

&lt;h2 id=&quot;4-7-handling-permanent-failures-replica-synchronization&quot;&gt;4-7 Handling Permanent Failures: Replica Synchronization&lt;/h2&gt;

&lt;p&gt;hinted handoff 机制在短时故障的场景下运行良好，但是对于长期故障的场景无法保证持久性：在 hinted 副本移交给本应该存储该副本的节点之前，该副本就不可用了，那么系统中的副本就会出现不一致的情况。&lt;/p&gt;

&lt;p&gt;为了保证不同副本之间的一致性，&lt;strong&gt;Dynamo 实现一种逆熵（副本同步）协议来保证副本之间是同步的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为了&lt;em&gt;快速检测副本之间的不一致性，以及最小转移的数据量&lt;/em&gt;，Dynamo 使用了 Merkle tree。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Merkle tree 是一个 Hash tree：叶子节点是 key 对应的 value 的 hash 值；父节点是子节点的 hash&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果两棵树的根节点 hash 值相同，那么这两棵树的叶子节点肯定相同，则这两棵树是一致的；否则这两棵树存在不一致的数据，需要继续比较其子节点的 hash 值，直到找到不一致的子树。&lt;/p&gt;

&lt;p&gt;Dynamo 系统的&lt;strong&gt;每个节点为每段 key range 维护了一个单独的 Merkle tree&lt;/strong&gt;。不同节点之间可以比较其维护的 key range 内的 key 是否一致。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;key range: 一致性 hash 环中每个节点维护的范围&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;这种方案的缺点是：&lt;em&gt;每当有节点加入或离开系统时，一些 key range 会变，因此对应的 tree 需要重新计算&lt;/em&gt;。&lt;/p&gt;

&lt;h2 id=&quot;4-8-membership-and-failure-detection&quot;&gt;4-8 Membership and Failure Detection&lt;/h2&gt;

&lt;h3 id=&quot;4-8-1-ring-membership&quot;&gt;4-8-1 Ring Membership&lt;/h3&gt;

&lt;p&gt;Dynamo 使用&lt;strong&gt;显示机制来向 hash ring 中增删节点&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通常情况下节点不可用持续的时间都比较短，一个节点的临时不可用不能说明这个节点永久离开了系统，因此不应该在节点不可用时立即进行 re-partiton，或者修复无法访问的副本&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;管理员通过命令行手动添加或者删除节点，负责处理该请求的节点&lt;strong&gt;将成员变动的信息持久化到本地，并通过 gossip-based 算法广播成员变动信息&lt;/strong&gt;，保证成员信息的一致性。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;每个节点周期性地随机选择另一个节点，这两个节点互相交换自己拥有的成员信息，维护成员信息的一致性&lt;/em&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;节点启动时，计算自己的 token 集合（一致性 hash ring 上的 token range）&lt;/li&gt;
  &lt;li&gt;将节点映射到 token 集合中（包含虚拟节点）&lt;/li&gt;
  &lt;li&gt;将映射关系持久化到本地&lt;/li&gt;
  &lt;li&gt;与其他节点交换自己维护的成员信息，从而不同节点保持一致&lt;/li&gt;
  &lt;li&gt;通过 gossip-based 协议多次交换后，每个节点都会知道其他节点负责的 token 范围&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;成员信息的交换，既能保证维护信息的一致性，也能够使得&lt;strong&gt;每个节点都可以将任意 key 的读写操作直接发送给正确的节点处理&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;4-8-2-external-discovery&quot;&gt;4-8-2 External Discovery&lt;/h3&gt;

&lt;p&gt;上述成员信息维护流程啃根会导致 Dynamo 在逻辑上的临时分裂：管理员添加 A 节点，A 维护了自己的 token 集合；之后管理员又将 B 添加到系统中，B 也维护了自己的 token 集合；但是 A，B 两个节点&lt;em&gt;无法感知对方的存在&lt;/em&gt;，就无法进行信息交换。&lt;/p&gt;

&lt;p&gt;为了避免逻辑分裂，可以通过&lt;strong&gt;外部机制配置一些 Dynamo 节点作为种子节点&lt;/strong&gt;：&lt;em&gt;所有节点都知道种子节点的存在，并和种子节点交换自己的信息，最终所有节点都会感知对方的存在，避免逻辑分裂的可能&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;种子节点只是一个普通的 Dynamo 节点，不过是提前配置在配置中心或者配置文件中&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-8-3-failure-detection&quot;&gt;4-8-3 Failure Detection&lt;/h3&gt;

&lt;p&gt;故障检测是一个&lt;strong&gt;纯本地概念&lt;/strong&gt;（pure local notion）的检测机制：只要节点 B 没有应答 A 的请求，那么 A 就认为 B 发生故障，不可访问。&lt;/p&gt;

&lt;p&gt;如果 A 认为 B 是故障的，那么可以选择与 B 拥有同一个 partition 的其他节点（preference list 中的其他节点）来处理请求，并定期检查 B 是否再次可用。&lt;/p&gt;

&lt;p&gt;故障检测的目的是为了&lt;em&gt;避免尝试与不可访问的节点持续通信&lt;/em&gt;，如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;get(), put() 操作访问的节点&lt;/li&gt;
  &lt;li&gt;转移 partition 和 临时副本(hinted replica) 时的目标节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在没有客户端请求的情况下，节点之间并不需要知道对方是否故障；在客户端持续请求下，不同节点间会持续交互，此时如果对方不可访问，当前节点也会立马知道。&lt;/p&gt;

&lt;h2 id=&quot;4-9-addingremoving-storage-nodes&quot;&gt;4-9 Adding/Removing Storage Nodes&lt;/h2&gt;

&lt;p&gt;当新节点 X 添加到系统中后，它会获得一些&lt;strong&gt;随机分散在 hash ring 上的 token 集合&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dynamo/dynamo_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如 X 加入 A, B 节点之间，X 就会负责&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(F, G], (G, A] and (A, X]&lt;/code&gt; 之间的 key。相应地，B, C, D 节点就不需要负责相应的 range 了。&lt;strong&gt;在收到 X 转移 key 的请求之后，B, C, D 会向 X 转移相应的 key&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;节点移除的分配顺序相反&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;通过这种方式，可以使得 key 在存储节点上均匀分布。同时，为了不重复转移 key range，需要在源节点与目标节点间添加确认机制。&lt;/p&gt;

&lt;h1 id=&quot;5-implementation&quot;&gt;5-Implementation&lt;/h1&gt;

&lt;p&gt;Dynamo 系统中的每个节点上有 3 个组件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;request coordination（请求协调）组件&lt;/li&gt;
  &lt;li&gt;成员验证 &amp;amp; 故障检测组件&lt;/li&gt;
  &lt;li&gt;本地持久化存储引擎&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-1-local-storage&quot;&gt;5-1 Local Storage&lt;/h2&gt;

&lt;p&gt;存储引擎组件设计为可插拔：&lt;strong&gt;为不同访问类型选择合适的存储引擎&lt;/strong&gt;。如 BDB 适合处理几十 KB 大小的对象，MySQL 适合处理更大的对象&lt;/p&gt;

&lt;h2 id=&quot;5-2-request-coordination&quot;&gt;5-2 Request Coordination&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Coordinator 构建在事件驱动的消息系统上，用于代替客户端执行读写请求&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读操作会从一个或者多个节点收集数据&lt;/li&gt;
  &lt;li&gt;写操作会向一个或者多个节点存储数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Coordinator 会&lt;strong&gt;为每个请求创建一个状态机&lt;/strong&gt;：包含了&lt;em&gt;识别 key 对应的节点，发送请求，等待响应，重试，处理响应，组合响应，返回给客户端&lt;/em&gt;等逻辑。&lt;/p&gt;

&lt;p&gt;每个状态机只会处理一个客户端请求，读操作流程为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;发送读请求给其他 Dynamo 节点&lt;/li&gt;
  &lt;li&gt;等待最少数量的响应
    &lt;ol&gt;
      &lt;li&gt;如果在一定时间内收到的响应数少于规定的，则认为请求失败&lt;/li&gt;
      &lt;li&gt;如果满足规定数量，则收集对象的所有版本，并确定返回版本&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;如果收到过期版本，则需要合并版本并回写给对应节点 —— 读修复(read repair)&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;生成上下文 context：包含版本向量时钟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;即使读操作的结果已经响应给客户端，&lt;strong&gt;状态机也会等待一段时间，用于接受剩余节点可能的有效响应&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;对于写操作，如果&lt;strong&gt;&lt;em&gt;总是选择 preference list 中的第一个健康节点作为 coordinator，可以完成写操作的序列化&lt;/em&gt;&lt;/strong&gt;，但是会导致负载不均衡（操作请求的 key 不一定是均匀分布的）。为了解决这个问题，&lt;strong&gt;preference list 中的前 N 个健康节点都可以作为 coordinator&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;并且，每个写操作请求前都会先进行一次读操作，所以&lt;strong&gt;写操作的 coordinator 可以选择前一次读操作返回最快的节点&lt;/strong&gt;（该信息存储在读操作的 context 中）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该策略同时提高了“读取刚写入数据”的概率&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;6-conclusions&quot;&gt;6-Conclusions&lt;/h1&gt;

&lt;p&gt;Dynamo 作为一个高可用，高可扩展的数据仓库，提供了期望的可用性和性能等级，可以正确地处理服务器故障、数据中心故障和网络分裂；支持增量扩展；允许&lt;strong&gt;客户端应用可以通过对 N、R 和 W 三个参数进行调优来达到期望的性能、可用性和持久性等级&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Dynamo 表明了&lt;strong&gt;最终一致性存储系统可以作为高可用应用（highly available applications）的一块基石。&lt;/strong&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">1-Abstract</summary></entry><entry><title type="html">现在完成时与一般过去时</title><link href="http://localhost:4000/present-progressive-and-past-tense.html" rel="alternate" type="text/html" title="现在完成时与一般过去时" /><published>2022-01-16T00:00:00+08:00</published><updated>2022-01-16T00:00:00+08:00</updated><id>http://localhost:4000/present-progressive-and-past-tense</id><content type="html" xml:base="http://localhost:4000/present-progressive-and-past-tense.html">&lt;p&gt;现在完成时与一般过去时是英语中用法极为灵活的两种时态，它们属于不同时间的两种时态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;现在完成时属于现在时态的范畴&lt;/li&gt;
  &lt;li&gt;一般过去时属于过去时态的范畴&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-构成形式不同&quot;&gt;1-构成形式不同&lt;/h2&gt;

&lt;p&gt;现在完成时的动词形式为：&lt;strong&gt;have (has) + 动词的过去分词&lt;/strong&gt;；一般过去时的动词形式为：&lt;strong&gt;动词的过去式&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一般过去时：Jack’s mother took him to school every day when he was in primary school.&lt;/li&gt;
  &lt;li&gt;现在完成时：Maria has never read any Chinese stories.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-强调对象不同&quot;&gt;2-强调对象不同&lt;/h2&gt;

&lt;p&gt;现在完成时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用来表示之前已发生或完成的动作或状态，其结果和现在有联系，现在完成时的&lt;strong&gt;&lt;em&gt;动作或状态发生在过去，但它的影响现在还存在&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;强调过去的事情对现在的影响，&lt;strong&gt;&lt;em&gt;强调的是影响&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般过去时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;表示过去的事实，不表示和现在的关系。&lt;/li&gt;
  &lt;li&gt;表示过去某时发生的动作或单纯叙述过去的事情，&lt;strong&gt;&lt;em&gt;强调动作&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Yesterday I went to the zoo.（仅说明昨天去了动物园，与现在无关）&lt;/li&gt;
  &lt;li&gt;Li Lei has read the book.（强调对现在的影响，那本书的内容已经了解）&lt;/li&gt;
  &lt;li&gt;Mr Green bought a new computer yesterday.（强调的是格林先生买新电脑的时间是昨天）&lt;/li&gt;
  &lt;li&gt;Mr Green has bought a new computer.（重点是格林先生现在有了一台新电脑）&lt;/li&gt;
  &lt;li&gt;I saw the film three days ago.（强调是三天前，而不是别的什么时候看的电影）&lt;/li&gt;
  &lt;li&gt;I have seen the film.（现在我仍记得电影的内容）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-时间状语不同&quot;&gt;3-时间状语不同&lt;/h2&gt;

&lt;p&gt;一般过去时常与 &lt;strong&gt;&lt;em&gt;具体的时间状语&lt;/em&gt;&lt;/strong&gt; 连用，而现在完成时通常与 &lt;strong&gt;&lt;em&gt;模糊的时间状语&lt;/em&gt;&lt;/strong&gt; 连用，或 &lt;strong&gt;&lt;em&gt;无时间状语&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一般过去时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Yesterday, Last week / month / year / night/ Monday, yesterday morning / afternoon / evening,
just now = a moment ago, …ago, the day before yesterday, 
in +（已过去的）某年/ 月, on +（已过去的）某天, at +（已过去的）几点钟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在完成时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;可以和带有 &lt;strong&gt;&lt;em&gt;since 或 for 等表示一段时间的状语&lt;/em&gt;&lt;/strong&gt; 连用, 表示动作或状态从某一时刻开始，一直持续到现在。&lt;/p&gt;

    &lt;p&gt;在与 for 及 since 引导的一段时间状语连用时，句子的谓语动词必须是&lt;strong&gt;&lt;em&gt;延续性动词&lt;/em&gt;&lt;/strong&gt;，短暂性动词不可和一段时间连用。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He has become a soldier for three years.（wrong）&lt;/li&gt;
      &lt;li&gt;He has been a soldier for three years. (right)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;往往与&lt;strong&gt;&lt;em&gt;表示不确定的过去时间状语&lt;/em&gt;&lt;/strong&gt;连用，如 &lt;strong&gt;already&lt;/strong&gt;(肯定句中)，&lt;strong&gt;yet&lt;/strong&gt;(否定，疑问，句末)，&lt;strong&gt;just&lt;/strong&gt;, &lt;strong&gt;before&lt;/strong&gt;, &lt;strong&gt;recently&lt;/strong&gt;, &lt;strong&gt;still&lt;/strong&gt;, &lt;strong&gt;lately&lt;/strong&gt;, &lt;strong&gt;never&lt;/strong&gt; 等
    &lt;ul&gt;
      &lt;li&gt;He has already obtained a scholarship.&lt;/li&gt;
      &lt;li&gt;I haven’t seen much of him recently (lately).&lt;/li&gt;
      &lt;li&gt;We have seen that film before.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;经常与&lt;strong&gt;&lt;em&gt;表示频率的时间状语&lt;/em&gt;&lt;/strong&gt;连用，如：&lt;strong&gt;often, sometimes, ever, never, twice, on several occasion&lt;/strong&gt; 等.
    &lt;ul&gt;
      &lt;li&gt;Have you ever been to Beijing?&lt;/li&gt;
      &lt;li&gt;I have never heard Bunny say anything against her.&lt;/li&gt;
      &lt;li&gt;George has met that gentleman on several occasions.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果上述关键词都没有出现的话，就看是描述一个过去的事实或动作，还是表示强调已经完成了的事件对现在产生的影响。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">现在完成时与一般过去时是英语中用法极为灵活的两种时态，它们属于不同时间的两种时态：</summary></entry><entry><title type="html">Linux Kernel: Processes</title><link href="http://localhost:4000/linux-kernel-4.html" rel="alternate" type="text/html" title="Linux Kernel: Processes" /><published>2021-11-28T00:00:00+08:00</published><updated>2021-11-28T00:00:00+08:00</updated><id>http://localhost:4000/linux-kernel-4</id><content type="html" xml:base="http://localhost:4000/linux-kernel-4.html">&lt;p&gt;进程被定义为&lt;strong&gt;程序执行的一个实例&lt;/strong&gt;。在 Linux 中，通常把进程称为任务（task）或者线程（thread）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果有 n 个用户同时运行 vim 命令，那么就会有 n 个独立的进程；尽管它们共享同一个可执行代码&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h1 id=&quot;1-进程--轻量级进程--线程&quot;&gt;1-进程 &amp;amp; 轻量级进程 &amp;amp; 线程&lt;/h1&gt;

&lt;p&gt;从内核角度来看，&lt;strong&gt;进程是系统资源（CPU 时间，内存等）分配的实体&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当一个进程创建时，几乎与父进程相同。子进程接受父进程地址空间的一个逻辑拷贝，并从进程创建系统调用的下一条指令开始执行与父进程相同的代码。尽管父子进程可以共享含有程序代码的页，但是它们有各自独立的数据拷贝（堆 &amp;amp; 栈），因此，子进程对一个内存单元的修改对父进程是不可见的（反之亦然）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;父子进程的地址空间采用 copy on write 机制&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;现代 Unix 系统支持多线程应用程序：一个进程由几个用户线程组成，&lt;strong&gt;每个线程都代表进程的一个执行流&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;大部分多线程应用程序都是基于 POSIX thread 标准库实现&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;从 Linux 内核来看，多线程应用程序仅仅是一个普通的进程。&lt;strong&gt;&lt;em&gt;多线程应用程序多个执行流的创建，处理，调度等都是在用户态进行的&lt;/em&gt;&lt;/strong&gt;。这种实现方式存在不足：假设一个应用进程中存在两个线程，A 线程在执行部分流程之后需要暂停执行，并等待 B 线程的执行结果。如果 A 线程只是简单的触发阻塞系统调用，试图将 CPU 交给 B，那么 B 线程也会被阻塞（它们同属于一个进程）。相反，A 线程必须使用比较复杂的非阻塞技术来确保进程仍然是可运行的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux 使用轻量级进程（lightweight process）来实现对多线程应用程序更好的支持&lt;/strong&gt;。两个轻量级进程基本上可以共享一些资源，如地址空间，打开的文件等。只要其中一个轻量级进程修改了共享资源，另一个就能立即查看这种修改。&lt;/p&gt;

&lt;p&gt;实现多线程应用程序的一个简单方式就是&lt;strong&gt;把轻量级进程与每个线程关联起来&lt;/strong&gt;。线程之间可以通过简单共享同一内存地址空间，同一打开文件集等来访问相同的应用程序数据结构集；同时，每个线程都可以由内核单独调度，以便阻塞一个线程的同时，另一个线程仍然是可运行的。&lt;/p&gt;

&lt;h1 id=&quot;2-进程描述符&quot;&gt;2-进程描述符&lt;/h1&gt;

&lt;p&gt;进程描述符包含了与进程相关的所有信息，类型为 task_struct。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_4/lk_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-1-进程状态&quot;&gt;2-1 进程状态&lt;/h2&gt;

&lt;p&gt;进程描述符中的 state 字段标识了进程当前所处的状态（某一时刻只能处于一种状态下）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可运行状态（TASK_RUNNING）
    &lt;ul&gt;
      &lt;li&gt;进程要么正在 CPU 上执行，要么准备执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可中断的等待状态（TASK_INTERRUPTIBLE）
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;进程被挂起（休眠），直到某个条件变成真&lt;/strong&gt;。产生一个硬件中断，释放进程正等待的系统资源或者传递一个信号都可以是唤醒进程的条件（进程的状态被重新置为 TASK_RUNNING）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不可中断的等待状态（TASK_UNINTERRUPTIBLE）
    &lt;ul&gt;
      &lt;li&gt;与可中断的等待状态蕾西，但是有一点不同，把信号传递到休眠进程并不能改变进程的状态（该状态只会在一些特定的情况下使用）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;暂停状态（TASK_STOPPED）
    &lt;ul&gt;
      &lt;li&gt;进程的执行被暂停：当进程收到 SIGSTOP, SIGTSTP, SIGTTIN or SIGTTOU 信号后，进入暂停状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;跟踪状态（TASK_TRACED）
    &lt;ul&gt;
      &lt;li&gt;进程的执行已由 debugger 程序暂停&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;僵死状态（TASK_ZOMBIE）
    &lt;ul&gt;
      &lt;li&gt;进程的执行被终止，但是父进程还没有发布 wait4() or waitpid() 系统调用来返回有关死亡进程的信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;僵死撤销状态（EXIT_DEAD）
    &lt;ul&gt;
      &lt;li&gt;最终状态：由于父进程刚发出 wait4() or waitpid() 系统调用，因而进程被系统删除&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-2-标识进程&quot;&gt;2-2 标识进程&lt;/h2&gt;

&lt;p&gt;一般来说，每个能够被独立调度的执行上下文都必须拥有它自己的进程描述符。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;即使是轻量级进程也有 task_struct 结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;进程与进程描述符之间一一对应，因此&lt;strong&gt;常用 32 位的进程描述符地址（线性地址）标识一个进程&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;进程描述符指针指向该地址&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此外，Unix 操作系统还使用&lt;strong&gt;进程标识符 processID（PID）&lt;/strong&gt;来标识进程，PID 存放在进程描述符的 pid 字段中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PID 被顺序编号，并且被循环使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux 把不同的 PID 与系统中的每个进程或者轻量级进程相关联；同时 Unix 希望同一组中的线程有共同的 PID（一个多线程应用程序的所有线程拥有相同的 PID）。因此，Linux 引入线程组的方式，一个线程组的所有线程使用和该线程组的领头线程（thread group leader）相同的 PID，即该组中的第一个轻量级进程的 PID，被存放在进程描述符中的 tgid 字段中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个多线程应用的所有线程共享同一个 PID&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2-2-1-进程描述符处理&quot;&gt;2-2-1 进程描述符处理&lt;/h3&gt;

&lt;p&gt;内核把进程描述符存放在动态内存中，而不是分配给内核的内存区。对每个进程，Linux 都把两个不同的数据结构紧凑地存放在一个单独为进程分配的存储区域内：1. 与进程描述符相关的小数据结构 thread_info，线程描述符; 2. 内核态的进程堆栈。这块存储区域通常占据两个页框。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_4/lk_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;分别通过 task 与 thread_info 字段使 thread_info 结构与 task_struct 结构互相关联&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2-2-2-进程链表&quot;&gt;2-2-2 进程链表&lt;/h3&gt;

&lt;p&gt;进程链表是一个双向链表，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_4/lk_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程双向链表把所有的进程描述符链接起来&lt;/strong&gt;；每个 task_struct 结构都包含一个 list_head类型的 tasks 字段，该类型的 pre &amp;amp; next 字段分别指向前面和后面的 task_struct 元素。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;进程链表的头是 init_task 描述符，它是 0 进程的进程描述符&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2-2-3-task_running-状态的进程链表&quot;&gt;2-2-3 TASK_RUNNING 状态的进程链表&lt;/h3&gt;

&lt;p&gt;当内核试图切换新的进程在 CPU 上运行时，必须只考虑可运行进程（即处在 TASK_RUNNING 状态的进程）。&lt;/p&gt;

&lt;p&gt;早期的 Linux 版本把所有可运行的进程都放在同一个运行队列中，导致维护链表中的进程按照优先级排序开销过大。Linux 2.6 实现的运行队列期望调度程序能够在&lt;strong&gt;固定的时间内选出最佳可运行的进程&lt;/strong&gt;（与队列中可运行的进程数无关）。&lt;/p&gt;

&lt;p&gt;为了实现该目的，建立多个可运行进程链表，&lt;strong&gt;每种进程优先权对应一个不同的链表&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一共有 140 个不同的队列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-3-进程间的关系&quot;&gt;2-3 进程间的关系&lt;/h2&gt;

&lt;p&gt;程序创建的进程具有父子关系，一个父进程的多个子进程之间具有兄弟关系。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;进程 0 和进程 1 是由内核创建的，进程 1 （init）是所有进程的祖先&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_4/lk_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进程之间还存在其他关系：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个进程可能是一个进程组或者登录会话的领头进程&lt;/li&gt;
  &lt;li&gt;也可能是一个线程组的领头进程&lt;/li&gt;
  &lt;li&gt;也可能跟踪其他进程的执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-4-如何组织进程&quot;&gt;2-4 如何组织进程&lt;/h2&gt;

&lt;p&gt;Linux 对不同状态的进程有不同的组织方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;运行队列链表把处于 TASK_RUNNING 状态的所有进程组织在一起&lt;/li&gt;
  &lt;li&gt;没有为 TASK_STOPPED, EXIT_ZOMBIE 和 EXIT_DEAD 状态的进程专门建立链表：对这些状态的进程访问比较简单&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;根据不同的特殊事件把处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 状态的进程细分为很多类别，每一类都对应一个特殊的事件&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-4-1-等待队列&quot;&gt;2-4-1 等待队列&lt;/h3&gt;

&lt;p&gt;进程必须经常等待某些事件的发生，例如，等待一个磁盘操作的终止，等待释放系统资源或者等待事件经过固定的间隔；等待队列实现了在事件上的&lt;strong&gt;条件等待：希望等待特定事件的进程把自己放进合适的等待队列中，并放弃控制权。因此，等待队列表示一组休眠的进程，当某一条件变成真时，由内核唤醒它们&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;等待队列在中断处理，进程同步及定时方面由很大作用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;等待队列也是由双向链表实现，其元素包括指向进程描述符的指针。每个等待队列都有一个等待队列头(wait queue head)，而等待队列头是一个类型为 wait_queue_head_t 的数据结构：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__wait_queue_head&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;spinlock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 自旋锁&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 双向链表：等待进程链表的头&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等待队列是由中断处理程序和一些内核函数修改的，因此必须对其双向链表进行保护以避免并发带来的异常。同步操作是通过等待队列头中的自旋锁实现的。&lt;/p&gt;

&lt;p&gt;等待队列链表中的元素类型为 wait_queue_t:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__wait_queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 进程描述符&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wait_queue_func_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等待队列中的每个元素代表一个休眠的进程，该进程等待某一事件的发生；进程描述符地址存放在 task 字段中；task_list 字段表示等待相同事件的进程链表；func 字段表示进程应该用什么方式唤醒。&lt;/p&gt;

&lt;p&gt;等待队列中的进程有两种类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;互斥进程（flags = 1）：由内核有选择地唤醒
    &lt;ul&gt;
      &lt;li&gt;如等待访问临界区资源的进程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;非互斥进程（flags = 0）：总是在内核事件发生时唤醒，即一次会唤醒全部非互斥进程
    &lt;ul&gt;
      &lt;li&gt;比如等待磁盘传输结束的一组进程，一旦磁盘传输完成，所有等待进程都会被唤醒&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-4-2-等待队列的操作&quot;&gt;2-4-2 等待队列的操作&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过调用特定函数（add_wait_queue(), add_wait_queue_exclusive() 等）可以把进程添加到等待队列或者从等待队列中移除（remove_wait_queue()）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;需要等待某个条件的进程可以调用以下函数将自己添加到等待队列中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;sleep_on()：该函数把当前进程的状态设置为 TASK_UNINTERRUPTIBLE，并把它插入到特定的等待队列。之后，它调用调度程序，而调度程序重新开始另一个程序的执行。当休眠的进程被唤醒时，调度程序重新开始执行 sleep_on() 函数，把该进程从等待队列中删除&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sleep_on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_queue_head_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wait_queue_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;init_waitqueue_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;current_state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TASK_UNINTERRUPTIBLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;add_wait_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//插入等待队列的头部&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 调用调度程序执行其他进程&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;remove_wait_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 被唤醒后重新执行&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;interruptible_sleep_on()：与 sleep_on() 函数一样，只不过是把进程的状态设置为 TASK_INTERRUPTIBLE；因此，&lt;em&gt;接受一个信号就可以唤醒当前进程&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sleep_on_timeout() &amp;amp; interruptible_sleep_on_timeout() 与上面的函数类似，但是允许调用者定义一个时间间隔，&lt;em&gt;过了这个时间间隔之后，进程将由内核唤醒&lt;/em&gt;。为了实现该功能，这两个方法调用的时 schedule_timeout() 函数而不是 schedule() 函数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prepare_to_wait(), prepare_to_wait_exclusive() 和 finish_wait() 函数提供了另一种途径使得当前进程在一个等待队列中休眠；典型用法如下：&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;prepare_to_wait_exclusive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TASK_INTERRUPTIBLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;finish_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 进程被唤醒后从该处执行&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;wait_event() &amp;amp; wait_event_interruptible() 使得调用进程在等待队列上休眠，直到修改了给定条件为止&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内核通过调用以下函数将等待队列中的进程唤醒并把状态设置为 TASK_RUNNING&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;wake_up()：扫描等待队列中的所有进程，并通过 func 字段试图唤醒进程。该函数总是先唤醒非互斥进程，再唤醒互斥进程：非互斥进程位于双向链表的开始位置&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wake_up&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_queue_head_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;sturct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wait_queue_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;list_for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TASK_INTERRUBPIBLE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TASK_UNITERRUPRIBLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;wake_up_all() &amp;amp; wake_up_nr() 等方法&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;一个等待队列中同时包含互斥进程与非互斥进程的情况很罕见&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-5-进程资源限制&quot;&gt;2-5 进程资源限制&lt;/h2&gt;

&lt;p&gt;每个进程都有一组相关的进程资源限制（resource limit），限制指定了进程能够使用的系统资源数量。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RLIMIT_AS: 进程地址空间的最大数（字节为单位）&lt;/li&gt;
  &lt;li&gt;RLIMIT_RSS: 进程所拥有的页框最大数&lt;/li&gt;
  &lt;li&gt;RLIMIT_CPU: 进程使用 CPU 的最长时间（秒为单位）&lt;/li&gt;
  &lt;li&gt;RLIMIT_DATA: 堆大小的最大值&lt;/li&gt;
  &lt;li&gt;RLIMIT_STACK: 栈大小的最大值（字节为单位）&lt;/li&gt;
  &lt;li&gt;RLIMIT_NOFILE: 打开文件描述符的最大值&lt;/li&gt;
  &lt;li&gt;RLIMIT_SIGPENDING: 进程挂起信号的最大数&lt;/li&gt;
  &lt;li&gt;RLIMIT_NPROC: 用户能够拥有的进程最大数&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-进程切换&quot;&gt;3-进程切换&lt;/h1&gt;

&lt;p&gt;为了控制进程的执行，内核必须能够挂起正在 CPU 上运行的进程，并恢复以前挂起的摸个进程的执行；这种行为被称为&lt;strong&gt;进程切换&lt;/strong&gt;（process switch）或者上下文切换（context switch）。&lt;/p&gt;

&lt;h2 id=&quot;3-1-硬件上下文&quot;&gt;3-1 硬件上下文&lt;/h2&gt;

&lt;p&gt;每个进程可以拥有自己的地址空间，但是所有进程需要共享 CPU 寄存器。因此，在进程恢复运行之前，需要确保每个寄存器装入了挂起进程的值；这组数据被称为硬件上下文（hardware context）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;硬件上下文是进程可执行上下文的子集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 Linux 中，进程硬件上下文的一部分存放在 TSS 段（Task State Segment，任务状态段），而剩余部分存放在内核态堆栈中。&lt;/p&gt;

&lt;p&gt;进程切换只发生在内核态。在执行进程切换之前，用户态进程使用的所有寄存器内容已保存在内核态堆栈上。&lt;/p&gt;

&lt;h2 id=&quot;3-2-执行进程切换&quot;&gt;3-2 执行进程切换&lt;/h2&gt;

&lt;p&gt;进程切换只能发生在 schedule() 函数中；每个进程切换由两步组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;切换页全局目录以安装一个新的地址空间&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;切换内核态堆栈和硬件上下文&lt;/strong&gt;（硬件上下文提供了内核执行新进程所需要的素有信息，包含 CPU 寄存器）&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-创建进程&quot;&gt;4-创建进程&lt;/h1&gt;

&lt;p&gt;传统的 Unix 操作系统以统一的方式对待所有进程：子进程复制父进程所拥有的资源。这种效率比较低，因为子进程需要拷贝父进程所有的地址空间，实际上，子进程几乎不必读或者修改父进程所拥有的资源；在很多情况下，子进程立即调用 execve()，并清除父进程拷贝过来的地址空间。&lt;/p&gt;

&lt;p&gt;现代 Unix 内核通过引入三种不同的机制解决这个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;写时复制（copy on write）技术允许父子进程读取相同的物理页&lt;/strong&gt;。只要两者中有一个试图写一个物理页，内核就把这个页的内容拷贝到一个新的物理页，并把这个新的物理页分配给正在写的进程。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;轻量级进程允许父子进程共享每进程在内核的很多数据结构&lt;/strong&gt;，如页表（用户态地址空间），打开的文件表及信号处理。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;vfork() 系统调用创建的进程能共享其父进程的内存地址空间&lt;/strong&gt;。为了防止父进程重写子进程所需要的数据，阻塞父进程的执行，直到子进程退出或执行一个新的程序为止。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-1-相关系统调用&quot;&gt;4-1 相关系统调用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;clone(): 轻量级进程是由 clone() 函数创建&lt;/li&gt;
  &lt;li&gt;传统的 fork() 调用是用 clone() 实现的，不过对于一些标志都清除&lt;/li&gt;
  &lt;li&gt;vfork() 也是用 clone 实现，也是一些参数的不同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-2-内核线程&quot;&gt;4-2 内核线程&lt;/h2&gt;

&lt;p&gt;一些系统进程只运行在内核态，所以现代操作系统把它们的函数委托给&lt;strong&gt;内核线程&lt;/strong&gt;（kernel thread）。内核线程用于执行一些周期性的任务：刷新磁盘高速缓存，交换出不用的页框，维护网络连接等。内核线程不受不必要的用户态上下文的拖累；在以下方面不同于普通进程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;*内核线程只运行在内核态*&lt;/strong&gt;，而普通进程既可以运行在用户态，也可以运行在内核态&lt;/li&gt;
  &lt;li&gt;因为只运行在内核态，所以只使用大于 PAGE_OFFSET 的线性地址空间。而普通进程不管是处于用户态还是内核态，可以使用 4GB 的线性地址空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-1-进程-0&quot;&gt;4-2-1 进程 0&lt;/h3&gt;

&lt;p&gt;所有进程的祖先叫做进程 0，它是在 Linux 的初始化阶段从无到有创建的一个内核线程。&lt;/p&gt;

&lt;h3 id=&quot;4-2-2-进程-1&quot;&gt;4-2-2 进程 1&lt;/h3&gt;

&lt;p&gt;由进程 0 创建的内核线程执行 init() 函数，init() 依次完成内核初始化。&lt;/p&gt;

&lt;h1 id=&quot;5-撤销进程&quot;&gt;5-撤销进程&lt;/h1&gt;

&lt;p&gt;进程终止一般是调用 exit() 函数，用于释放所分配的资源。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;exit_group(): 终止整个线程组，即基于多线程的应用&lt;/li&gt;
  &lt;li&gt;exit(): 终止某个线程&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="Operating-System" /><summary type="html">进程被定义为程序执行的一个实例。在 Linux 中，通常把进程称为任务（task）或者线程（thread）。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/linux_kernel/chapter_4/lk_1.png" /><media:content medium="image" url="http://localhost:4000/linux_kernel/chapter_4/lk_1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>