<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-17T17:31:53+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Find a needle in haystack</title><subtitle></subtitle><author><name>kkzhang</name></author><entry><title type="html">编程珠玑: 算法设计技术</title><link href="http://localhost:4000/programming-pearls-8.html" rel="alternate" type="text/html" title="编程珠玑: 算法设计技术" /><published>2022-06-19T00:00:00+08:00</published><updated>2022-06-19T00:00:00+08:00</updated><id>http://localhost:4000/programming-pearls-8</id><content type="html" xml:base="http://localhost:4000/programming-pearls-8.html">&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;：具有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 个浮点数的向量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;：输入向量的任意连续子向量的最大和。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：输入向量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 为 [31, -41, 59, 26, -53, 58, 97, -93, -23, 84]，那么该程序输出为 x[2…6] 的总和。&lt;/p&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;当所有数都是正数时，问题比较简单，此时最大子向量就是整个输入向量。&lt;/p&gt;

&lt;p&gt;当输入向量中含有负数时，是否应该包含某个负数并期望旁边的正数会弥补它呢？&lt;/p&gt;

&lt;p&gt;为了使问题定义更加完整，假设所有的输入都是负数时，最大子向量为空向量，总和为 0.&lt;/p&gt;

&lt;h2 id=&quot;on3-算法&quot;&gt;O(n^3) 算法&lt;/h2&gt;

&lt;p&gt;该问题最直接的解法是对所有满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 ≤ i ≤ j &amp;lt; n&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(i, j)&lt;/code&gt; 整数对进行迭代。对每个整数对，都需要计算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[i, j]&lt;/code&gt; 的总和，并判断此时该和是否是迄今为止最大的和。&lt;/p&gt;

&lt;p&gt;代码比较简单，但是运行速度很慢。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// sum is sum of x[i...j]&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;on2-算法&quot;&gt;O(n^2) 算法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;我们注意到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[i...j]&lt;/code&gt; 的总和与前面已经计算出的总和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[i...j-1]&lt;/code&gt; 相关，利用该关系可以得到第一个平方算法。&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 	&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// sum is sum of x[i...j]&lt;/span&gt;
 	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一种平方算法是提前计算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[0...i]&lt;/code&gt; 各个数累加的和。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cumarr[i]&lt;/code&gt; 表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[0...i]&lt;/code&gt; 中各个数的累加和，则 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x[i..j]&lt;/code&gt; 的累加和可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cumarr[j] - cumarr[i-1]&lt;/code&gt; 得到。&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;cumarr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 	&lt;span class=&quot;n&quot;&gt;cumarr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cumarr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cumarr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;cumarr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// sum is sum of x[i...j]&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;分治算法onlogn&quot;&gt;分治算法：O(nlogn)&lt;/h2&gt;

&lt;p&gt;前面讨论的算法考虑了所有的子向量，并计算每个子向量中的所有数的和。由于存在 O(n^2) 个子向量，因此至少需要 O(n^2) 的运行时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分治法原理&lt;/strong&gt;：&lt;em&gt;要解决规模为 n 的问题，可以递归地解决两个规模近似为 n/2 的子问题，然后对它们的答案进行合并可以得到整个问题的答案&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;在本问题中，我们将大小为 n 的向量分解为两个大小近似的子向量 a, b，之后递归地找出 a, b 中的最大子向量 ma, mb。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;整个向量的最大子向量为 ma：子向量在 a 中&lt;/li&gt;
  &lt;li&gt;整个向量的最大子向量为 mb：子向量在 b 中&lt;/li&gt;
  &lt;li&gt;整个向量的最大子向量为 mc：子向量跨越 a, b 之间的边界&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// zero elements&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// one element&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// find max crossing to left&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lmax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;lmax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// find max crossing to right&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;rmax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;rmax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lmax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;扫描算法on&quot;&gt;扫描算法：O(n)&lt;/h2&gt;

&lt;p&gt;扫描算法是从数组的最左端（x[0]）开始扫描，一直到最右端（x[n-1]），并记下所遇到的总和最大的子向量。&lt;/p&gt;

&lt;p&gt;假设已经解决了 x[0…i-1] 的问题，如何将其扩展为包含 x[i] 的问题？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;类似分治算法原理：前 i 个元素中，最大总和的子向量要么在前 i-1 个元素中（maxsofar），要么其结束位置为 i（maxendinghere）&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt; &lt;/th&gt;
          &lt;th&gt;maxsofar&lt;/th&gt;
          &lt;th&gt; &lt;/th&gt;
          &lt;th&gt;maxendinghere&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;i&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;maxendinghere&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// maxendinghere 一开始为结束位置为 x-1 的最大子向量的和，此处将其更新为结束位置为 i 的最大子向量的和&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 如果加上 x[i] 之后仍然为正值，那么 maxendinghere 则加上 x[i]；否则将 maxendinghere 设置为 0（空向量）&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;maxendinghere&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxendinghere&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxsofar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxendinghere&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;上述几个算法给出了几个重要的算法设计技术：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保存状态，避免重复计算：动态规划&lt;/li&gt;
  &lt;li&gt;分治算法&lt;/li&gt;
  &lt;li&gt;扫描算法&lt;/li&gt;
  &lt;li&gt;将信息预处理至数据结构中&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="algrithom" /><summary type="html">问题描述</summary></entry><entry><title type="html">编程珠玑: 编程小事</title><link href="http://localhost:4000/programming-pearls-5.html" rel="alternate" type="text/html" title="编程珠玑: 编程小事" /><published>2022-06-11T00:00:00+08:00</published><updated>2022-06-11T00:00:00+08:00</updated><id>http://localhost:4000/programming-pearls-5</id><content type="html" xml:base="http://localhost:4000/programming-pearls-5.html">&lt;h3 id=&quot;脚手架&quot;&gt;脚手架&lt;/h3&gt;

&lt;p&gt;使用脚手架更方便地访问函数；最简单的脚手架是命令行技术&lt;/p&gt;

&lt;h3 id=&quot;编码&quot;&gt;编码&lt;/h3&gt;

&lt;p&gt;首先使用伪代码构建程序框架，然后将伪代码翻译成要实现的语言&lt;/p&gt;

&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;在脚手架中对组件进行测试；通过脚手架对程序进行自动化测试&lt;/p&gt;

&lt;h3 id=&quot;调试&quot;&gt;调试&lt;/h3&gt;

&lt;p&gt;不管是脚手架还是真实运行环境，调试工作总是很困难的&lt;/p&gt;

&lt;h3 id=&quot;计时&quot;&gt;计时&lt;/h3&gt;

&lt;p&gt;对程序执行时间进行计时，确保程序能够达到我们预期的性能&lt;/p&gt;

&lt;h3 id=&quot;断言的艺术&quot;&gt;断言的艺术&lt;/h3&gt;

&lt;p&gt;断言既可以知道程序的代码开发，也可以用来判断程序的正确性。我们可以将断言插入代码中，以确保程序运行时的行为与我们的理解一致&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="algrithom" /><summary type="html">脚手架</summary></entry><entry><title type="html">编程珠玑: 程序性能分析</title><link href="http://localhost:4000/programming-pearls-6-copy.html" rel="alternate" type="text/html" title="编程珠玑: 程序性能分析" /><published>2022-06-11T00:00:00+08:00</published><updated>2022-06-11T00:00:00+08:00</updated><id>http://localhost:4000/programming-pearls-6%20copy</id><content type="html" xml:base="http://localhost:4000/programming-pearls-6-copy.html">&lt;h2 id=&quot;设计层面&quot;&gt;设计层面&lt;/h2&gt;

&lt;p&gt;为了提高系统性能，可以在多个层面进行设计。&lt;/p&gt;

&lt;h3 id=&quot;问题定义&quot;&gt;问题定义&lt;/h3&gt;

&lt;p&gt;良好的问题定义可以避免对问题需求的过高估计。问题定义与程序效率之间具有复杂的相互影响。&lt;/p&gt;

&lt;h3 id=&quot;系统结构&quot;&gt;系统结构&lt;/h3&gt;

&lt;p&gt;将大型系统分解成多个模块&lt;/p&gt;

&lt;h3 id=&quot;算法和数据结构&quot;&gt;算法和数据结构&lt;/h3&gt;

&lt;p&gt;对于模块性能提升的关键是表示数据的结构和操作这些数据的算法&lt;/p&gt;

&lt;h3 id=&quot;代码调优&quot;&gt;代码调优&lt;/h3&gt;

&lt;p&gt;与系统无关的代码调优&lt;/p&gt;

&lt;h3 id=&quot;系统软件&quot;&gt;系统软件&lt;/h3&gt;

&lt;p&gt;改变系统所基于的软件；同时考虑与系统相关的代码调优&lt;/p&gt;

&lt;h3 id=&quot;硬件&quot;&gt;硬件&lt;/h3&gt;

&lt;p&gt;更快的硬件可以提高系统的性能&lt;/p&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;当性能问题无法回避时，对于不同的性能目标可以从不同的设计层面进行考虑。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;如果仅需要较小的性能提升，就对效果最佳的层面进行改进&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;首先考虑所有可能的设计层面，然后选择“性价比”最高的那个：较小投入可以获得较大的加速系数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;em&gt;如果需要较大的性能提升，需要对多个层面进行改进&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;需要从各个不同方向对问题进行深入研究。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="algrithom" /><summary type="html">设计层面</summary></entry><entry><title type="html">Lion 设计与实现</title><link href="http://localhost:4000/lion-design-and-implements.html" rel="alternate" type="text/html" title="Lion 设计与实现" /><published>2022-05-28T00:00:00+08:00</published><updated>2022-05-28T00:00:00+08:00</updated><id>http://localhost:4000/lion-design-and-implements</id><content type="html" xml:base="http://localhost:4000/lion-design-and-implements.html">&lt;blockquote&gt;
  &lt;p&gt;本文是在美团内部面向其他团队的分享&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h1&gt;

&lt;h2 id=&quot;1-1-功能介绍&quot;&gt;1-1 功能介绍&lt;/h2&gt;

&lt;p&gt;Lion 是一个面向分布式系统的配置中心，采用中心化数据管理，通过 C/S 架构实现配置的统一管理和实时推送。&lt;/p&gt;

&lt;p&gt;应用程序使用 Lion 可实现配置与代码分离、配置变更推送、历史版本管理、灰度发布等功能。通过集中化的在线配置管理，应用可以实现秒级配置变更，并且保证所有节点配置的最终一致性。除此之外，Lion 还提供操作日志查看、灰度发布、配置审核等高级功能。&lt;/p&gt;

&lt;h2 id=&quot;1-2-sla-指标&quot;&gt;1-2 SLA 指标&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指标&lt;/th&gt;
      &lt;th&gt;目标&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;推送成功率&lt;/td&gt;
      &lt;td&gt;99.9%&lt;/td&gt;
      &lt;td&gt;配置修改成功后（5s内）所有客户端成功获取到最新配置的比例&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;推送时效性&lt;/td&gt;
      &lt;td&gt;&amp;lt;5s&lt;/td&gt;
      &lt;td&gt;配置从修改成功到客户端获取到新配置的时间&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当配置进行一次成功变更之后，&lt;strong&gt;Lion 只能保证最终一致性&lt;/strong&gt;，即所有 Client 最终都能获取到最新配置，&lt;strong&gt;不能保证强一致性&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;1-2-服务端性能指标&quot;&gt;1-2 服务端性能指标&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指标&lt;/th&gt;
      &lt;th&gt;数据&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;单机/集群写性能(8C8G)&lt;/td&gt;
      &lt;td&gt;700QPS/2500QPS&lt;/td&gt;
      &lt;td&gt;HTTP Open API&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;单机读性能(8C8G, RT &amp;lt; 100ms)&lt;/td&gt;
      &lt;td&gt;7000QPS&lt;/td&gt;
      &lt;td&gt;HTTP Open API&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;单机最优连接数(8C/16G)&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;服务端长轮询连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;北上同步延迟（1700QPS）&lt;/td&gt;
      &lt;td&gt;TP999&amp;lt;500ms&lt;/td&gt;
      &lt;td&gt;数据在一侧数据中心发生变更后，同步到另一侧的延迟&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;2-系统设计&quot;&gt;2-系统设计&lt;/h1&gt;

&lt;h2 id=&quot;2-1-整体架构&quot;&gt;2-1 整体架构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Lion 系统采用异地多活架构：北京 &amp;amp; 上海各部署一套数据中心，支持双写，通过自研同步组件（Consistency）保证两个数据中心间数据一致性。业务配置存储主要使用 MySQL, Redis 作为存储介质（ZK 即将下线）。&lt;/p&gt;

&lt;p&gt;用户可以通过管理端（Console）与 HTTP 接口（API）进行配置变更与查询操作，同时 Lion 也支持多语言的 SDK（Java，Node，C++，Golang），便于业务服务进行配置获取与变更监听操作。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模块名称&lt;/th&gt;
      &lt;th&gt;主要功能&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-config&lt;/td&gt;
      &lt;td&gt;用于 client 获取配置与监听配置变更&lt;/td&gt;
      &lt;td&gt;client 与 config 使用长轮询通信; config 集群北上多机房部署，支持多集群&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-consistency&lt;/td&gt;
      &lt;td&gt;不同数据中心间数据同步; 同一数据中心，不同存储介质数据同步&lt;/td&gt;
      &lt;td&gt;北上双集群部署&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-meta&lt;/td&gt;
      &lt;td&gt;实现 config, consistency 服务发现功能 consistency 同步数据分区策略控制; 用于 client 获取相关元数据：config 节点列表，黑白名单项目等&lt;/td&gt;
      &lt;td&gt;弱依赖 mns 实现节点注册发现功能，在 mns 不可用时降级到自研健康检测策略&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-client&lt;/td&gt;
      &lt;td&gt;与 config 服务交互实现配置获取/监听功能&lt;/td&gt;
      &lt;td&gt;定时从 meta 获取可用 config 节点列表，并通过长轮询访问 config 服务端; config 服务不可用时，从本地文件获取配置（可能是过期数据）; 支持多语言 sdk: java, node, go, c++&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-api&lt;/td&gt;
      &lt;td&gt;提供 http open api：用于业务方通过 http 实现配置的变更与查询&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-console&lt;/td&gt;
      &lt;td&gt;管理端交互，提供配置增删改查功能&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;2-1-配置获取与推送&quot;&gt;2-1 配置获取与推送&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Client 在获取配置时，加载策略依次为：&lt;strong&gt;1. 内存缓存，2. Lion 远程服务端，3. 本地持久化文件&lt;/strong&gt;。在从服务端某个节点加载失败时，会及时切换到其他可用节点，直到超时；之后会降级到本地文件（可能仍是上次获取到的旧值）。&lt;/p&gt;

&lt;p&gt;Config 服务端在收到 Client 获取配置的请求后，依次从：&lt;strong&gt;1. 内存缓存，2. Redis，3. DB&lt;/strong&gt; 中加载配置。配置加载成功之后，需要比较 Client 携带的配置版本号（c_version）与服务端加载到的配置版本号（s_version）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 c_verison == 0，则说明 Client 首次获取该配置，此时直接返回服务端配置&lt;/li&gt;
  &lt;li&gt;如果 c_version != 0 且 c_version &amp;lt; s_version，则说明该配置在 Client 上次加载之后又更新过，此时需要将最新配置返回&lt;/li&gt;
  &lt;li&gt;如果 c_version != 0 且 c_version &amp;gt;= s_version，则说明 Client 本地配置已经是最新值，此时请求被 hang 住，直到该配置被更新或者请求超时（100s）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-2-一致性保障&quot;&gt;2-2 一致性保障&lt;/h2&gt;

&lt;p&gt;Lion 配置存储分为北京/上海两个数据中心，每个数据中心分别有 DB, Redis, ZK(即将下线) 。为了实现异地多活，需要保证北上数据的一致性。&lt;/p&gt;

&lt;p&gt;Lion 采取的是最终一致性，一致性保障由 Consistency 模块维护，整体可以分为两个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;不同数据中心间的一致性&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;同一数据中心内不同存储介质的一致性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-2-1-同步模型&quot;&gt;2-2-1 同步模型&lt;/h3&gt;

&lt;p&gt;为了实现数据最终一致性，lion 对每次配置变更都会记录一条 log，被称为同步日志（sync log）。该 log 模型基本如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;key&lt;/th&gt;
      &lt;th&gt;release_key&lt;/th&gt;
      &lt;th&gt;local_db_status&lt;/th&gt;
      &lt;th&gt;remote_db_status&lt;/th&gt;
      &lt;th&gt;zk_status&lt;/th&gt;
      &lt;th&gt;redis_status&lt;/th&gt;
      &lt;th&gt;status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;配置唯一标识&lt;/td&gt;
      &lt;td&gt;配置变更唯一标识&lt;/td&gt;
      &lt;td&gt;同侧 db 状态：0 未同步，1 同步成功&lt;/td&gt;
      &lt;td&gt;异地 db 状态:0 未同步，1 同步成功&lt;/td&gt;
      &lt;td&gt;同侧 zk 状态：0 未同步，1 同步成功&lt;/td&gt;
      &lt;td&gt;同侧 redis 状态:0 未同步，1 同步成功&lt;/td&gt;
      &lt;td&gt;本次变更同步状态: 0 未加载，1 已加载未同步，2 同步成功&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;status 字段用于标识同步流程是否全部成功，如果同步失败，则会重试直到同步成功。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;不管是通过 http api 接口还是管理端变更配置，只会更新同侧的 db，并不会同步更新同侧数据中心内的 zk, redis（提高接口性能）。每次配置变更产生的 log 为：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;local_db&lt;/th&gt;
      &lt;th&gt;remote_db&lt;/th&gt;
      &lt;th&gt;zk&lt;/th&gt;
      &lt;th&gt;redis&lt;/th&gt;
      &lt;th&gt;status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;2-2-2-同步流程&quot;&gt;2-2-2 同步流程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同步流程步骤分为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;log 加载&lt;/strong&gt;：将未同步完成的日志从 db 中加载到内存队列中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;异地同步&lt;/strong&gt;：优先将 log 批量同步到异地；异地同步成功后将 log hash 到内存队列中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地同步&lt;/strong&gt;：将 log 顺序同步到本地 db, redis, zk 中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;结合 log 中各个同步状态进一步分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;本地 db 同步&lt;/strong&gt;：如果本地 db 未同步，则首先同步 db。如果同步成功，则 log.local_db = 1。（对 log 产生侧来说，local_db 默认 1，即默认不同步）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;异地同步&lt;/strong&gt;：该流程为异步操作，仅仅是&lt;em&gt;将 log 发送到异地并被接收，并在稍后将配置回写到 db, redis, zk&lt;/em&gt;。如果同步成功，则 log.remote_db = 1.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地 redis 同步&lt;/strong&gt;：如果同步成功，则 log.local_redis = 1.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地 zk 同步&lt;/strong&gt;：如果同步成功，则 log.local_zk = 1.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-可用性&quot;&gt;3-可用性&lt;/h2&gt;

&lt;p&gt;承诺 Lion 服务的可用性不低于 99.99%。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模块名称&lt;/th&gt;
      &lt;th&gt;集群分布&lt;/th&gt;
      &lt;th&gt;外部依赖&lt;/th&gt;
      &lt;th&gt;内部依赖&lt;/th&gt;
      &lt;th&gt;RTO&lt;/th&gt;
      &lt;th&gt;故障时主动切换 SLA&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-consistency&lt;/td&gt;
      &lt;td&gt;两地多机房&lt;/td&gt;
      &lt;td&gt;MySQL、S3、专线（弱）、DNS（弱）&lt;/td&gt;
      &lt;td&gt;lion-meta&lt;/td&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;0s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-api&lt;/td&gt;
      &lt;td&gt;两地多机房&lt;/td&gt;
      &lt;td&gt;MySQL、S3、Redis（弱）&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;0s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-config&lt;/td&gt;
      &lt;td&gt;两地多机房&lt;/td&gt;
      &lt;td&gt;MySQL、S3、Redis（弱）&lt;/td&gt;
      &lt;td&gt;lion-meta&lt;/td&gt;
      &lt;td&gt;120s&lt;/td&gt;
      &lt;td&gt;0s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-console&lt;/td&gt;
      &lt;td&gt;两地多机房&lt;/td&gt;
      &lt;td&gt;MySQL&lt;/td&gt;
      &lt;td&gt;lion-api&lt;/td&gt;
      &lt;td&gt;60s&lt;/td&gt;
      &lt;td&gt;0s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-meta&lt;/td&gt;
      &lt;td&gt;两地多机房&lt;/td&gt;
      &lt;td&gt;MySQL、MNS（弱）&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;60s&lt;/td&gt;
      &lt;td&gt;0s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lion-client&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;DNS&lt;/td&gt;
      &lt;td&gt;lion-config、lion-meta（弱）&lt;/td&gt;
      &lt;td&gt;T_{断连感知}=120s&lt;/td&gt;
      &lt;td&gt;3s (timeout)+3s * (0~N) (N:异常 Config 数目)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;config 服务北上两地多机房部署，支持弹性伸缩：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于异常 config 节点，meta 会及时剔除，保证下发给 client 节点列表的可用性&lt;/li&gt;
  &lt;li&gt;client 在请求 config 服务端获取配置时，优先访问同地域节点；同地域无可用节点时，访问异地节点&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果所有 config 节点均不可用，则降级到本地持久化文件&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;config 服务加载配置时，强依赖 db，s3(文件配置)，弱依赖 redis：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;redis 不可用时，对配置获取 &amp;amp; 推送没有影响&lt;/li&gt;
  &lt;li&gt;db，s3 不可用时，client 无法获取到最新配置（通过 config 内存缓存可以获取到旧配置）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;consistency 服务北上两地多机房部署，支持弹性伸缩：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步 log 加载强依赖 db，db 不可用时，同步任务无法执行&lt;/li&gt;
  &lt;li&gt;consistency 节点异常时，meta 会及时剔除，并更新同步策略（尽可能降低节点变更对同步延迟的影响）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-隔离性&quot;&gt;4-隔离性&lt;/h2&gt;

&lt;p&gt;配置隔离可以从两个方面来看：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;配置获取&lt;/strong&gt;：客户端通过长轮询访问 lion-config 获取目标配置&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;配置同步&lt;/strong&gt;：配置变更在北上两地/同一数据中心内保持一致&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-1-配置获取&quot;&gt;4-1 配置获取&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;config 服务支持多集群，不同集群管理特定业务配置。对于一些配置容量大/稳定性要求高的业务，会拆分出独立集群，其他业务共享默认集群。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;config 集群&lt;/th&gt;
      &lt;th&gt;集群所属项目&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;zebra&lt;/td&gt;
      &lt;td&gt;{ds, group-ds}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;buffalo&lt;/td&gt;
      &lt;td&gt;{buffalo-reader-task，buffalo-client，buffalo-writer-task}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;waf&lt;/td&gt;
      &lt;td&gt;{com.sankuai.sec.waf.manage}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;default&lt;/td&gt;
      &lt;td&gt;{others}&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;各个集群&lt;strong&gt;配置管理相互独立，业务流量隔离&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;buffalo 配置获取只会访问 buffalo 集群，同时 buffalo 集群只管理 buffalo 相关的配置&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;不过，各个 config 集群依赖的底层存储（redis, db）仍共用一个集群&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-2-配置同步&quot;&gt;4-2 配置同步&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/lion/lion_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于不同业务对推送延迟的敏感程度不同，因此我们将配置同步分为两种：1. 普通配置，2. 高优先级配置；这两种配置同步流程相互隔离。&lt;/p&gt;

&lt;p&gt;通过将不同配置的同步流程隔离，使得普通配置的堆积并不会对高优先级配置的同步流程产生影响。&lt;/p&gt;

&lt;h3 id=&quot;4-2-1-局限&quot;&gt;4-2-1 局限&lt;/h3&gt;

&lt;p&gt;不管是配置同步还是配置推送，目前都是在业务逻辑层进行隔离，在底层存储方面，所有业务共享一套存储。因此，目前针对业务隔离仍存在一定的局限性，如 db 集群异常时，所有业务方都会受到影响。&lt;/p&gt;

&lt;p&gt;不过，鉴于当前单集群存储容量在中短期内仍能支撑业务增长，并且存储层的可用性也能满足 Lion 的需求，因此短期内仍会保持现有隔离方案。&lt;/p&gt;

&lt;h2 id=&quot;5-可观测性&quot;&gt;5-可观测性&lt;/h2&gt;

&lt;h3 id=&quot;5-1-推送链路&quot;&gt;5-1 推送链路&lt;/h3&gt;

&lt;p&gt;对于每次配置变更的推送情况，Lion 提供了推送链路的功能帮助用户排查配置的推送情况，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;推动成功率，推送延迟，每台机器的推送详情等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过，该功能对 lion-client 版本有所要求（&amp;gt;=0.8.15.4），目前覆盖率 &amp;gt;80%（各版本分布情况）.&lt;/p&gt;

&lt;h3 id=&quot;5-2-数据同步&quot;&gt;5-2 数据同步&lt;/h3&gt;

&lt;p&gt;对于配置同步，有两个关键指标：1. 同步延迟，2. 同步成功率。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步延迟的大小与配置大小，配置的变更频率，同步批次大小，同步任务间隔等有关。经过测试，对于小配置（&amp;lt;1KB），在 1700 QPS 下延迟 TP999&amp;lt;500ms，最大延迟 1.8s。&lt;/li&gt;
  &lt;li&gt;通过一致性大盘可以看到，数据一致性 &amp;gt;99.99%&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-faq&quot;&gt;6-FAQ&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;业务在接入 lion 时，会按照 key 的粒度编码获取配置，如果业务方代码中获取引用了大量 key，是否会导致不同 key 每次都通过 http 访问 config 服务端是否导致耗时增大？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;如果同一个项目调用了多个 key（&amp;gt;5），那么配置获取粒度会由 key 升级为项目/分组，也就是说会从 config 服务端一次获取整个项目/分组的配置；这样当访问其他 key 时，只需要从本地内存缓存即可获取，减小了配置获取耗时。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;如果 lion 服务端均不可用，对业务方有何影响？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;从配置获取来说，在服务端完全不可用时会降级到本地持久化文件，可能会获取到已经失效的配置，并且不会感知到最新的配置变更&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;除了服务端内部一致性，如何保证客户端与服务端间的数据一致性？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;增量同步：客户端通过长轮询周期性地与服务端通信，请求信息携带了当前客户端配置的最新版本号，服务端通过比较版本号来判断客户端的配置是否过期，如果过期则更新客户端&lt;/li&gt;
      &lt;li&gt;全量同步：客户端定时全量同步本地配置，此时直接从服务端获取全量配置并更新本地过期配置&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;北上数据同步时，如何保证同一条 log 不会被重复同步?&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;log 通过 status 区分同步状态；同步任务只会加载 status = 0 的记录，确保同一条 log 不会被重复加载&lt;/li&gt;
      &lt;li&gt;log 被加载后会进行分区，保证不同 consistency 节点不会同步相同的 log&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;如何保证配置变更一定会被同步成功？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;有三种同步机制：1. log 创建后被立即同步；2. 同步失败后会进行有补扫任务进行再次同步（50次）；3. 北上定时检测机制，对于不一致的数据会重新触发同步流程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;北上同步时，如何解决数据冲突？&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;冲突解决方式为：最后写胜出（lrw），以最新版本为主。不过，两地同时写入的概率较低。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;在上海侧的一次变更，需要多长时间才能推送到北京侧业务机器?&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;北上同步延迟 TP999 &amp;lt; 500ms，我们承诺 99.9% 的配置会在 5s 内会全量推送到所有机器（具体每次配置变更推送延迟可以查看：Lion 推送链路）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;7-未来规划&quot;&gt;7-未来规划&lt;/h1&gt;

&lt;p&gt;中短期来看，Lion 规划主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提升用户体验：丰富多语言客户端功能，提升MWS易用性&lt;/li&gt;
  &lt;li&gt;提升系统可观测性：增强配置链路跟踪能力，提升监控能力，&lt;/li&gt;
  &lt;li&gt;提升容灾能力&lt;/li&gt;
  &lt;li&gt;提升系统效率：对齐业界同类系统，提高系统支撑能力、提升系统效率&lt;/li&gt;
  &lt;li&gt;提升平台化能力：增强存储及流量隔离，增强集群监控、运营统计，开放集群拆分&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">本文是在美团内部面向其他团队的分享</summary></entry><entry><title type="html">Linux Kernel: The Virtual Filesystem</title><link href="http://localhost:4000/linux-kernel-virtual-filesystem.html" rel="alternate" type="text/html" title="Linux Kernel: The Virtual Filesystem" /><published>2022-05-21T00:00:00+08:00</published><updated>2022-05-21T00:00:00+08:00</updated><id>http://localhost:4000/linux-kernel-virtual-filesystem</id><content type="html" xml:base="http://localhost:4000/linux-kernel-virtual-filesystem.html">&lt;p&gt;通过所谓的&lt;strong&gt;虚拟文件系统&lt;/strong&gt;的概念，Linux 系统能够支持多种文件系统类型。虚拟文件系统所隐含的思想是把表示多种不同类型的文件系统的共同信息存放在内核中，对文件系统的读写调用，内核都能将其替换成支持本地 Linux 文件系统或者其他文件系统的实际函数。&lt;/p&gt;

&lt;h1 id=&quot;1-虚拟文件系统的作用&quot;&gt;1-虚拟文件系统的作用&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;虚拟文件系统&lt;/strong&gt;（Virtual FileSystem）也被称为&lt;strong&gt;&lt;em&gt;虚拟文件系统转换&lt;/em&gt;&lt;/strong&gt;（Virtual FileSystem Switch），是一个&lt;strong&gt;&lt;em&gt;内核软件层&lt;/em&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;em&gt;用来处理与 Unix 标准文件系统相关的所有系统调用&lt;/em&gt;&lt;/strong&gt;；能够为各个文件系统提供一个通用的接口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VFS 是用户程序与文件系统实现之间的抽象层&lt;/strong&gt;。例如用户输入以下 shell 命令&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# /floppy 是 ms-dos 文件系统，而 /tmp 是 ext2 文件系统&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; /floppy/test /tmp/test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cp&lt;/code&gt; 程序并不需要操作目录的具体文件系统类型，相反，cp 程序与 VFS 交互。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;a 描述了 VFS 的层次，b 表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cp&lt;/code&gt; 应用程序的实现&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;VFS 支持的文件系统可以划分为三种类型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;磁盘文件系统&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;用于管理本地磁盘分区。比较知名的基于磁盘的文件系统有：Linux 使用的文件系统，Unix 家族文件系统，微软公司文件系统等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;网络文件系统&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这些文件系统允许访问属于其他网络计算机的文件系统所包含的文件，常见的有 NFS，Coda，AFS 等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;特殊文件系统&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这些文件系统不管理本地或者远程磁盘空间。如 /proc 文件系统就是一种典型的特殊文件系统&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Unix 目录简易了一棵根目录为 ’/’ 的树，根目录包含在&lt;em&gt;根文件系统&lt;/em&gt;（root filesystem）中。在 Linux 中，&lt;em&gt;根文件系统通常为 Ext2 or Ext3 类型，其他所有的文件系统都可以被“安装”在跟文件系统的子目录中&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当一个文件系统被安装在某个目录上时，在父文件系统中的目录内容不再是可访问的&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-1-通用文件模型&quot;&gt;1-1 通用文件模型&lt;/h2&gt;

&lt;p&gt;VFS 的主要思想在于引入了一个&lt;strong&gt;通用的文件模型&lt;/strong&gt;（common file model），该模型能够表示所有支持的文件系统。&lt;/p&gt;

&lt;p&gt;对于每个具体的文件系统，需要将其物理组织结构转换为虚拟文件系统的通用文件模型。Linux 内核对于每个文件操作必须使用一个指针，指向要访问的具体文件系统的适当函数。&lt;/p&gt;

&lt;p&gt;通用文件模型由以下对象类型组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;超级块对象&lt;/strong&gt;（superblock object）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;用于存放已安装文件系统的有关信息&lt;/em&gt;。对于基于磁盘的文件系统，该类对象通常对应于存放在磁盘上的文件系统控制块（filesystem control block）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;索引节点对象&lt;/strong&gt;（inode object）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;用于存放具体文件的一般信息&lt;/em&gt;。对于基于磁盘的文件系统，该类对象通常对应于存放在磁盘上的文件控制块（file control block）。&lt;em&gt;每个索引节点对象都有一个索引节点号，该索引节点号唯一标识文件系统中的文件&lt;/em&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;文件对象&lt;/strong&gt;（file object）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;用于存放打开的文件与进程之间进行交互的有关信息&lt;/em&gt;。这类信息仅当进程访问文件期间存在于内核内存中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;目录项对象&lt;/strong&gt;（dentry object）&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;用于存放目录项（也就是文件的特地名称）与对应文件进行链接的有关信息&lt;/em&gt;。每个磁盘文件系统都以自己的方式将该类信息存放在磁盘上。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下图简单说明进程怎样与文件进行交互：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;三个不同的进程打开同一个文件，其中两个进程使用硬链接&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;每个进程都有自己的文件对象，但是只需要两个目录项对象（每个硬链接对应一个目录项对象）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;这两个目录项对象指向同一个索引节点对象&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;该索引节点对象标识超级块对象以及普通的磁盘文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了提高系统性能，最近最常用的目录项对象被存放在&lt;strong&gt;&lt;em&gt;目录项高速缓存&lt;/em&gt;&lt;/strong&gt;（dentry cache）的磁盘高速缓存（disk cache）中，以提高从文件路径名到最后一个路径分量的索引节点的转换效率。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般来说，磁盘高速缓存属于软机制，允许内核将原本存放在磁盘上的某些信息保存在 RAM 中，以加速对这些数据的访问&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-2-vfs-所处理的系统调用&quot;&gt;1-2 VFS 所处理的系统调用&lt;/h2&gt;

&lt;p&gt;下图列出了 VFS 处理的系统调用，涉及文件系统，普通文件，目录文件，符号链接文件等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;VFS 属于内核层，处理应用程序的系统调用&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_12/lk_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select() poll()&lt;/code&gt;：等待一组文件描述符上发生的事情&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read() write() readv() writev() sendfile()&lt;/code&gt;：进行文件 IO 操作&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap() mmap2()&lt;/code&gt;：处理文件内存映射&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;VFS 是应用程序与具体文件系统之间的一层。不过，&lt;strong&gt;&lt;em&gt;在某些情况下一个文件操作可能由 VFS 本身执行，不需要调用底层函数&lt;/em&gt;&lt;/strong&gt;。例如，当进程关闭打开的文件时，并不需要涉及磁盘上相应文件，因此 VFS 只需要释放对应的文件对象即可。&lt;/p&gt;

&lt;p&gt;从某种意义上来说，VFS 可以被看作普通的文件系统，在必要时依赖某种具体的文件系统。&lt;/p&gt;

&lt;h1 id=&quot;2-vfs-的数据结构&quot;&gt;2-VFS 的数据结构&lt;/h1&gt;</content><author><name>kkzhang</name></author><category term="Operating-System" /><summary type="html">通过所谓的虚拟文件系统的概念，Linux 系统能够支持多种文件系统类型。虚拟文件系统所隐含的思想是把表示多种不同类型的文件系统的共同信息存放在内核中，对文件系统的读写调用，内核都能将其替换成支持本地 Linux 文件系统或者其他文件系统的实际函数。</summary></entry><entry><title type="html">Linux Kernel: Signals</title><link href="http://localhost:4000/linux-kernel-signals.html" rel="alternate" type="text/html" title="Linux Kernel: Signals" /><published>2022-04-23T00:00:00+08:00</published><updated>2022-04-23T00:00:00+08:00</updated><id>http://localhost:4000/linux-kernel-signals</id><content type="html" xml:base="http://localhost:4000/linux-kernel-signals.html">&lt;p&gt;信号最早在 Unix 系统中被引入，&lt;strong&gt;用于在用户态进程间通信；内核也用信号通知进程系统所发生的事件&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&quot;1-信号的作用&quot;&gt;1-信号的作用&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;信号（signal）&lt;/strong&gt;是很短的消息，&lt;strong&gt;可以被发送到一个进程或者一组进程&lt;/strong&gt;。发送给进程的唯一信息通常是一个数，以此来标识信号。&lt;/p&gt;

&lt;p&gt;使用信号有两个目的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;让进程知道已经发生了一个特定的事件&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;强迫进程执行其自己代码中的信号处理程序&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;这两个目的并不互斥&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是 Linux 中前 31 个&lt;strong&gt;常规信号（regular signal）&lt;/strong&gt;。除了常规信号，POSIX 标准还引入了新的信号，被称为&lt;strong&gt;实时信号（real-time signal）&lt;/strong&gt;：在 Linux 中的编码范围为 32~64。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实时信号必须排队以便发送的多个信号能够被接收到&lt;/li&gt;
  &lt;li&gt;同种类型的常规信号并不排队：如果一个常规信号被连续发送多次，那么只有其中一个信号能够发送到接收进程&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux 内核并不使用实时信号，但还是通过几个特定的系统调用完全实现了 POSIX 标准&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;许多系统调用允许应用进程发送信号，并决定应用进程如何响应所接收到的信号&lt;/strong&gt;。下图是一些与信号相关的重要系统调用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;信号的一个比较重要的特点：&lt;strong&gt;信号可以随时被发送给状态不可预知的进程&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;发送给非运行进程的信号必须由内核保存，直到进程恢复执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阻塞一个信号要求信号的传递拖延，直到阻塞解除&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;使得信号产生一段时间之后才能对其传递这一问题变得更加严重&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内核将信号传递分为两个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;信号产生&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;内核更新目标进程的数据结构以表示一个新信号已被发送&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;信号传递&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;内核强迫目标进程对信号做出反应：要么&lt;em&gt;改变目标进程的执行状态&lt;/em&gt;，要么&lt;em&gt;开始执行一个特定的信号处理程序&lt;/em&gt;，要么两者都是&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;每个产生的信号至多被传递一次&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;信号是可消费资源，一旦已经被传递出去，那么进程描述符中有关这个信号的所有信息都被取消&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;挂起信号（pending signal）&lt;/strong&gt;：已经产生但还没有被传递的信号。&lt;em&gt;任何时候，一个进程仅存在给定类型的一个挂起信号，同一进程同种类型的其他信号不会被排队，只是简单地丢弃&lt;/em&gt;。但是，实时信号有所不同：同种类型的挂起信号可以有多个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;挂起信号（pending signal）&lt;/strong&gt;：已经产生但还没有被传递的信号。&lt;em&gt;任何时候，一个进程仅存在给定类型的一个挂起信号，同一进程同种类型的其他信号不会被排队，只是简单地丢弃&lt;/em&gt;。但是，实时信号有所不同：同种类型的挂起信号可以有多个。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;信号可以保留不可预知的挂起时间&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;为了实现信号，内核需要做到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;记住每个进程阻塞哪些信号&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当从内核态切换到用户态时，对每一个进程都需要检查是否有一个信号已到达&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;几乎发生在每个定时中断中（每毫秒）&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;确定是否可以忽略信号：当且仅当以下条件都满足时可以忽略信号：
    &lt;ul&gt;
      &lt;li&gt;目标进程没有被另一个进程跟踪&lt;/li&gt;
      &lt;li&gt;信号没有被目标进程阻塞&lt;/li&gt;
      &lt;li&gt;信号被目标进程忽略&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;处理信号：信号可能在进程运行期间的任意时刻请求把进程切换到一个信号处理函数，并在该函数返回后恢复原来执行的上下文&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-1-传递信号之前的操作&quot;&gt;1-1 传递信号之前的操作&lt;/h2&gt;

&lt;p&gt;进程可以对信号做出如下应答：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;显示地忽略信号&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;执行与信号相关的缺省操作&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;由内核定义的缺省操作有：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Terminate&lt;/em&gt;&lt;/strong&gt;：进程被终止（kill）&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Dump&lt;/em&gt;&lt;/strong&gt;：进程被终止，并且如何可能的话，创建包含进程执行上下文的核心转储文件&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Ignore&lt;/em&gt;&lt;/strong&gt;：信号被忽略&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Stop&lt;/em&gt;&lt;/strong&gt;：进程被停止，将进程设置为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TASK_STOPPED&lt;/code&gt; 状态&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;&lt;em&gt;Continue&lt;/em&gt;&lt;/strong&gt;：如果进程被停止（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TASK_STOPPED&lt;/code&gt;），则将其设置为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TASK_RUNNING&lt;/code&gt; 状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;通过调用相应的信号处理函数捕获信号&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意的是，对信号的阻塞与忽略是不同的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果信号被阻塞，则不会被传递，直到信号解除阻塞之后才传递该信号&lt;/li&gt;
  &lt;li&gt;被忽略的信号总是被传递，只不过没有进一步的操作而已&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; &amp;amp; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt; 信号不可以被显示地忽略，捕获或者阻塞，通常必须执行它们的缺省操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;允许有适当特权的用户通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt; 终止并停止任何进程（除了进程 0 &amp;amp; 1），不管程序采取怎样的防御措施&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-2-posix-信号与多线程应用&quot;&gt;1-2 POSIX 信号与多线程应用&lt;/h2&gt;

&lt;p&gt;POSIX 标准对多线程应用的信号处理有一些严格的要求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;信号处理程序必须在多线程应用的所有线程之间共享&lt;/li&gt;
  &lt;li&gt;每个发送给多线程应用的信号仅传送给一个线程，这个线程是由内核在从不会阻塞该信号的线程中任意挑选的&lt;/li&gt;
  &lt;li&gt;如果向多线程应用发送一个致命信号，那么内核将杀死该应用的所有线程，而不仅仅是杀死接收信号的那个线程&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了实现 POSIX 标准，Linux 把多线程应用实现为一组属于同一个线程组的轻量级进程&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果一个挂起信号被发送给某个特定进程，那么这个信号是私有的；如果发送给整个进程组，则其是共享的。&lt;/p&gt;

&lt;h2 id=&quot;1-3-与信号相关的数据结构&quot;&gt;1-3 与信号相关的数据结构&lt;/h2&gt;

&lt;p&gt;与信号相关的数据结构如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;task_struct: 进程描述符&lt;/li&gt;
  &lt;li&gt;signal_sturct: 信号描述符&lt;/li&gt;
  &lt;li&gt;sighand_struct: 信号处理程序描述符&lt;/li&gt;
  &lt;li&gt;shared_pending: 共享挂起信号队列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中进程描述符中与信号处理相关的字段如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pending: 私有挂起信号队列&lt;/li&gt;
  &lt;li&gt;signal: 信号描述符指针&lt;/li&gt;
  &lt;li&gt;block: 存放进程当前所屏蔽的信号&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-3-1-信号描述符与信号处理程序描述符&quot;&gt;1-3-1 信号描述符与信号处理程序描述符&lt;/h3&gt;

&lt;p&gt;进程描述符的 signal 字段指向&lt;strong&gt;信号描述符（signal descriptor）&lt;/strong&gt;：用来跟踪共享挂起信号。&lt;/p&gt;

&lt;p&gt;信号描述符被属于同一线程组的所有进程共享，即被调用 clone() 系统调用创建的所有进程共享。&lt;/p&gt;

&lt;p&gt;信号描述符中的相关字段：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了信号描述符，每个进程还引用一个&lt;strong&gt;信号处理程序描述符（signal handler descroptor）&lt;/strong&gt;：用来描述每个信号必须怎样被线程组处理。&lt;/p&gt;

&lt;p&gt;信号处理程序描述符相关字段：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 POSIX 多线程应用中，&lt;strong&gt;线程组中的所有轻量级进程都引用相同的信号描述符与信号处理程序描述符&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1-3-2-挂起信号队列&quot;&gt;1-3-2 挂起信号队列&lt;/h3&gt;

&lt;p&gt;为了跟踪进程当前的挂起信号，内核把两个挂起信号队列与每个进程相关联：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;共享挂起信号队列&lt;/strong&gt;：&lt;em&gt;&lt;strong&gt;信号描述符&lt;/strong&gt;的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shared_pending&lt;/code&gt; 字段，存放整个&lt;strong&gt;进程组&lt;/strong&gt;的挂起信号&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;私有挂起信号队列&lt;/strong&gt;：&lt;em&gt;&lt;strong&gt;进程描述符&lt;/strong&gt;的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pending&lt;/code&gt; 字段，存放&lt;strong&gt;特定进程&lt;/strong&gt;（轻量级进程）的挂起信号&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;挂起信号队列由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigpending&lt;/code&gt; 数据结构组成：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigpending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 包含 sigqueue 数据结构的双向链表头&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;sigset_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 指定挂起信号的位掩码&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 结构如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;siginfo_t&lt;/code&gt; 字段存放特定信号的信息，其中包含：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;si_signo&lt;/code&gt;: 信号编号&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;si_errno&lt;/code&gt;: 引起信号产生指令的出错码&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;si_code&lt;/code&gt;: 信号发送者代码&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;上图是比较重要的信号发送者代码：SI_KERNEL 一般内核函数；SI_TIMER 定时器到期；SI_ASYNCIO 异步 IO 完成。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2-产生信号&quot;&gt;2-产生信号&lt;/h1&gt;

&lt;p&gt;很多内核函数都会产生信号：完成信号处理的第一步，即&lt;strong&gt;根据需要更新一个或者多个进程的描述符&lt;/strong&gt;。但是，&lt;strong&gt;&lt;em&gt;并不直接执行第二步信号的传递操作，而是可能根据信号的类型和目标进程的状态唤醒一些进程，并促使这些进程接收信号&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当发送给&lt;em&gt;某个进程&lt;/em&gt;信号时，该信号可能来自内核，可能来自另一个进程。内核通过对以下内核函数调用而产生信号：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上述所有内核函数在结束时都调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;specific_send_sig_info()&lt;/code&gt; 函数&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;同样，发送给&lt;em&gt;整个进程组&lt;/em&gt;时，该信号可能来自内核，也可能来自另一个进程。内核通过调用为线程组产生信号的内核函数产生这类信号：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-1-specific_send_sig_info-函数&quot;&gt;2-1 specific_send_sig_info() 函数&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;specific_send_sig_info()&lt;/code&gt; 函数用于向指定进程发送信号，主要参数有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sig&lt;/code&gt;：信号编号&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;info&lt;/code&gt;：要么是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;siginfo_t&lt;/code&gt; 表的地址，要么是三个特殊值中的一个
    &lt;ul&gt;
      &lt;li&gt;0：信号是由用户态进程发送的&lt;/li&gt;
      &lt;li&gt;1： 信号是由内核发送的&lt;/li&gt;
      &lt;li&gt;2： 由内核发送的 SIGSTOP or SIGKILL 信号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;：指向目标进程描述符的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该函数执行以下步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查进程是否忽略信号。当以下条件全部满足时，信号就会被忽略：
    &lt;ul&gt;
      &lt;li&gt;进程没有被跟踪（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t→ptrace&lt;/code&gt;）&lt;/li&gt;
      &lt;li&gt;信号没有被阻塞&lt;/li&gt;
      &lt;li&gt;显示忽略信号（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t→singhand→action[sig-1]&lt;/code&gt;），或者隐含地忽略信号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;检查信号是否是非实时的（sig&amp;lt;32），并且进程的私有挂起信号队列上是否已经有另一个相同的挂起信号，如果存在，则不需要做任何事，直接返回 0&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send_signal()&lt;/code&gt; 函数把该信号添加到进程的（私有）挂起信号集合中&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send_signal()&lt;/code&gt; 函数成功调用，并且信号不被阻塞，则调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal_wake_up()&lt;/code&gt; 函数通知进程有新的挂起信号&lt;/li&gt;
  &lt;li&gt;函数返回，此时已成功产生信号&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-2-signal_wake_up-函数&quot;&gt;2-2 signal_wake_up() 函数&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal_wake_up()&lt;/code&gt; 函数执行以下步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t→thread_info→flags&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIF_SIGPENDING&lt;/code&gt; 标志置位&lt;/li&gt;
  &lt;li&gt;如果进程处于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TASK_INTERUPTIBLE&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TASK_STOPPED&lt;/code&gt; 状态，而且信号是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt;，则调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_to_wake_up()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_to_wake_up()&lt;/code&gt; 返回 0，则说明进程是可运行的。此时，会检查进程是否在另一个 CPU 上运行，则向那个 CPU 发送一个处理器间中断，以强制当前进程的重新调度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;因为从调度函数返回时，每个进程都检查是否存在挂起信号，因此处理器间中断保证了目标进程能够很快注意到新的挂起信号&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;2-3-send_signal-函数&quot;&gt;2-3 send_signal() 函数&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send_signal()&lt;/code&gt; 函数在挂起信号队列中插入一个新元素。函数执行步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;info&lt;/code&gt; 的值是 2，则该信号是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGKILL&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGSTOP&lt;/code&gt;，此时内核强制执行与这些信号相关的操作，不需要把信号添加到挂起队列中（流程结束）&lt;/li&gt;
  &lt;li&gt;递增进程拥有者挂起信号的数量&lt;/li&gt;
  &lt;li&gt;在挂起信号队列 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signals&lt;/code&gt; 增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 数据结构&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 结构中填充 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;siginfo_t&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;把队列位掩码中与信号相对应的位置为 1&lt;/li&gt;
  &lt;li&gt;如果第 5 步成功，则说明信号已经被成功追加到挂起信号队列中；如果失败，则不再向信号挂起队列中增加元素，可能是有太多的挂起信号，或者没有可以分配给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigqueue&lt;/code&gt; 数据结构的空闲空间，或者信号已经由内核强制立即发送&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有些情况，即使挂起队列没有空间存放相应挂起信号，目标进程也要能接收信号；如内核必须保证 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill()&lt;/code&gt; 系统调用能够成功执行。&lt;/p&gt;

&lt;h2 id=&quot;2-4-group_send_sig_info-函数&quot;&gt;2-4 group_send_sig_info() 函数&lt;/h2&gt;

&lt;p&gt;该函数用于向整个进程组发送信号。&lt;/p&gt;

&lt;h1 id=&quot;3-传递信号&quot;&gt;3-传递信号&lt;/h1&gt;

&lt;p&gt;假设内核已经注意到信号的到来，并调用上述函数为接收此信号的进程准备相关信息。但是，如果该进程此时并没有在 CPU 上运行，内核则会延迟传递信号的任务。那么，为了确保进程的挂起信号能够被处理，内核应该如何操作？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;内核在允许进程恢复用户态下的执行之前，检查进程 TIF_SIGPENDING 标志。每当内核处理完一个中断或者异常时，就检查是否存在挂起信号&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内核调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_signal()&lt;/code&gt; 函数处理非阻塞的信号（通常是在 CPU 要返回到用户态时才调用该函数）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_signal()&lt;/code&gt; 函数重复调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dequeue_signal()&lt;/code&gt; 函数，直到私有挂起队列与共享挂起信号队列中都没有非阻塞的挂起信号时，循环结束&lt;/li&gt;
  &lt;li&gt;对于要处理的信号可以执行三种操作：忽略信号，执行缺省操作，执行信号处理程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-1-执行信号的缺省操作&quot;&gt;3-1 执行信号的缺省操作&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;对于缺省操作为 Ignore 的信号直接忽略&lt;/li&gt;
  &lt;li&gt;对于缺省操作为 Stop 的信号可能停止线程组中的所有进程：把进程状态都置为 TASK_STOPPED，并调用 schedule() 函数&lt;/li&gt;
  &lt;li&gt;缺省操作为 Dump 的信号会在进程的工作目录中创建一个转储文件&lt;/li&gt;
  &lt;li&gt;缺省操作为 Terminate 的信号会 kill 线程组&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-2-捕获信号&quot;&gt;3-2 捕获信号&lt;/h2&gt;

&lt;p&gt;如果信号有一个专门的处理程序，那么 do_signal() 函数必须强迫该处理程序执行。&lt;/p&gt;

&lt;p&gt;信号处理程序是用户态进程定义的函数，并包含在用户态的代码段中。do_signal() 函数运行在内核态，而信号处理程序运行在用户态。针对这种情况，Linux 采用的方法是&lt;strong&gt;把保存在内核态堆栈中的硬件上下文拷贝到当前进程的用户态堆栈中&lt;/strong&gt;。&lt;strong&gt;用户态进程在信号处理程序终止时，自动调用 sigreturn() 系统调用将硬件上下文拷贝回内核态堆栈中，并恢复用户态堆栈中原来的内容&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;捕获信号的执行流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_11/lk_14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个非阻塞信号发送给进程&lt;/li&gt;
  &lt;li&gt;当中断或者异常发生时，内核切换到内核态，在返回到用户态前，内核执行 do_signal() 函数，该函数依次处理信号和建立用户态堆栈&lt;/li&gt;
  &lt;li&gt;当进程切换回用户态时，开始执行信号处理程序&lt;/li&gt;
  &lt;li&gt;处理程序终止时，调用 sigreturn() 系统调用，恢复内核态与用户态堆栈信息&lt;/li&gt;
  &lt;li&gt;系统调用结束时，用户态进程恢复正常执行&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-与信号处理相关的系统调用&quot;&gt;4-与信号处理相关的系统调用&lt;/h1&gt;

&lt;p&gt;用户态进程可以发送和接收信号，可以通过一些系统调用来完成。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill()&lt;/code&gt;：能够发送任何信号&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tkill()&lt;/code&gt; &amp;amp; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tgkill()&lt;/code&gt;：向线程组中指定进程发送信号&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigpending()&lt;/code&gt;：允许进程检查挂起的阻塞信号集合&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sigsuspend()&lt;/code&gt;：把进程置为 TASK_INTERRUPTIBLE 状态&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="Operating-System" /><summary type="html">信号最早在 Unix 系统中被引入，用于在用户态进程间通信；内核也用信号通知进程系统所发生的事件。</summary></entry><entry><title type="html">Linux Kernel: System Calls</title><link href="http://localhost:4000/linux-kernel-system-calls.html" rel="alternate" type="text/html" title="Linux Kernel: System Calls" /><published>2022-04-21T00:00:00+08:00</published><updated>2022-04-21T00:00:00+08:00</updated><id>http://localhost:4000/linux-kernel-system-calls</id><content type="html" xml:base="http://localhost:4000/linux-kernel-system-calls.html">&lt;p&gt;操作系统为用户态进程与硬件设备（如 CPU，磁盘，打印机等）进行交互提供了一组接口。这种方式有以下优点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编程更加容易：用户不需要学习底层硬件设备编程&lt;/li&gt;
  &lt;li&gt;提高了系统安全性：内核在满足某个请求之前，可以检查该请求的正确性&lt;/li&gt;
  &lt;li&gt;使程序更具可移植性：只要内核提供的接口相同，那么在任意内核上都可以正确编译 &amp;amp; 执行程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Unix 系统通过向内核发出系统调用（system call）实现了用户态进程与硬件设备之间的大部分接口。&lt;/p&gt;

&lt;h1 id=&quot;1-posix-api-与系统调用&quot;&gt;1-POSIX API 与系统调用&lt;/h1&gt;

&lt;p&gt;API 只是一个函数定义，说明了如何获得一个给定的服务；而&lt;strong&gt;系统调用是通过软中断向内核态发出一个明确的请求&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;libc 标准库定义的一些 API 引用了封装例程（wrapper routine），封装例程的目的就是为了发布系统调用。通常，&lt;strong&gt;每个系统调用对应一个封装例程，而封装例程定义了应用程序使用的 API&lt;/strong&gt;。但是反过来，&lt;strong&gt;一个 API 没必要对应一个特定的系统调用&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;API 可能直接提供用户态的服务；一个 API 实现可能调用多个系统调用；不同的 API 可能调用了同一个系统调用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;POSIX API 标准只是针对 API，而不针对系统调用。从用户角度来看，API 与系统调用没有差别（可能函数名，参数等有所不同）；而从内核开发者的角度看，&lt;em&gt;系统调用属于内核，而用户态的库函数不属于内核&lt;/em&gt;。&lt;/p&gt;

&lt;h1 id=&quot;2-系统调用处理程序及服务例程&quot;&gt;2-系统调用处理程序及服务例程&lt;/h1&gt;

&lt;p&gt;当用户态进程调用一个系统调用时，CPU 切换到内核态并开始执行一个内核函数；而系统调用最终会跳转到&lt;strong&gt;系统调用处理程序（system call handler）&lt;/strong&gt;的汇编语言语言函数。&lt;/p&gt;

&lt;p&gt;每个系统调用都被一个&lt;strong&gt;系统调用号（system call number）&lt;/strong&gt;标识，因此进程在进行系统调用时需要传递该参数以识别所需的系统调用。&lt;/p&gt;

&lt;p&gt;系统调用处理程序与其他异常处理程序的结构类似，执行以下操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;在内核态保存大多数寄存器的内容&lt;/strong&gt;（汇编语言编写，所有系统调用通用操作）&lt;/li&gt;
  &lt;li&gt;调用名为&lt;strong&gt;系统调用服务例程（system call service routine）&lt;/strong&gt;的相应 C 函数来&lt;strong&gt;处理系统调用&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;退出系统调用处理程序：&lt;strong&gt;用保存在内核栈中的值加载寄存器&lt;/strong&gt;，CPU 从内核态切换回用户态（汇编语言实现，所有系统调用通用操作）&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般来说，xyz() 系统调用对应的系统调用服务例程的名字通常为 sys_xyz()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/linux_kernel/chapter_10/lk_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图展示了应用程序，封装例程，系统调用处理程序，系统调用服务例程之间的调用关系。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYSCALL&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYSEXIT&lt;/code&gt; 是汇编语言指令，分别把 CPU 从用户态切换到内核态和从内核态切换到用户态。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;内核中有一个&lt;strong&gt;系统调用分派表（dispatch table）&lt;/strong&gt;用于将系统调用号与相应的服务例程关联起来。&lt;/p&gt;

&lt;h1 id=&quot;3-进入和退出系统调用&quot;&gt;3-进入和退出系统调用&lt;/h1&gt;

&lt;p&gt;用户态进程有两种方式调用系统调用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int $0x80&lt;/code&gt; 汇编指令&lt;/li&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter&lt;/code&gt; 汇编指令&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内核也有两种方式从系统调用退出，从而使 CPU 切回用户态：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iret&lt;/code&gt; 汇编指令&lt;/li&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysexit&lt;/code&gt; 汇编指令&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-1-通过-int-0x80-指令发出系统调用&quot;&gt;3-1 通过 int $0x80 指令发出系统调用&lt;/h2&gt;

&lt;p&gt;当用户态进程发出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int $0x80&lt;/code&gt; 指令时，CPU 切换到内核态并开始从地址 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call&lt;/code&gt; 处（如上图）开始执行指令。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call()&lt;/code&gt; 函数首先将系统调用号与所有可能用到的 CPU 寄存器保存到相应的栈中&lt;/li&gt;
  &lt;li&gt;该函数在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebx&lt;/code&gt; 中存放当前进程的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info&lt;/code&gt; 数据结构的地址&lt;/li&gt;
  &lt;li&gt;检查 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info&lt;/code&gt; 结构中的相关字段&lt;/li&gt;
  &lt;li&gt;对用户态进程传入的系统调用号进行有效性判断&lt;/li&gt;
  &lt;li&gt;调用系统调用号对应的服务例程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当系统调用服务例程结束时，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call()&lt;/code&gt; 从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eax&lt;/code&gt; 寄存器获得服务例程的返回值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call()&lt;/code&gt; 关闭本地中断并检查当前进程的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info&lt;/code&gt; 结构中的相关标志（为了在返回用户态之前处理相关工作）&lt;/li&gt;
  &lt;li&gt;跳转到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;restore_all&lt;/code&gt; 标记处恢复保存在内核栈中的寄存器的值，并执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iret&lt;/code&gt; 汇编指令开始重新执行用户态进程&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-2-通过-sysenter-指令发出系统调用&quot;&gt;3-2 通过 sysenter 指令发出系统调用&lt;/h2&gt;

&lt;p&gt;汇编指令 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 需要执行几个一致性与安全检查，速度相对较慢；而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter&lt;/code&gt; 指令被称为快速系统调用，提供了一种从用户态快速切换到内核态的方法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;标准库中的封装例程把系统调用号装入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eax&lt;/code&gt; 寄存器，并调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__kernel_vsyscall()&lt;/code&gt; 函数&lt;/li&gt;
  &lt;li&gt;函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__kernel_vsyscall()&lt;/code&gt; 把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp, edx, ecx&lt;/code&gt; 内容保存到用户态堆栈中（系统调用处理程序将使用这些寄存器），同时把用户栈指针拷贝到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp&lt;/code&gt; 中，之后执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter&lt;/code&gt; 指令&lt;/li&gt;
  &lt;li&gt;CPU 从用户态切换到内核态，内核开始执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter_entry()&lt;/code&gt; 函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当系统调用服务例程结束时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter_entry()&lt;/code&gt; 函数执行与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call()&lt;/code&gt; 函数相同的操作。&lt;/p&gt;

&lt;h1 id=&quot;4-参数传递&quot;&gt;4-参数传递&lt;/h1&gt;

&lt;p&gt;与普通函数类似，系统调用也需要传参，可能是实际的值，可能是用户态进程地址空间的变量。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每个系统调用至少包含系统调用号参数&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;普通函数的传参是把参数值写入程序栈（用户态或者内核态）实现的；而系统调用是一种横跨内核态与用户态的特殊函数，所以既不能使用用户态栈，也不能使用内核态栈。&lt;strong&gt;在发出系统调用之前，系统调用参数被写入 CPU 寄存器，之后在调用系统调用服务例程之前，内核再把存放在 CPU 中的参数拷贝到内核态堆栈中&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为什么不直接将参数从用户态栈拷贝到内核态栈？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同时操作两个栈比较复杂&lt;/li&gt;
  &lt;li&gt;寄存器的使用使得系统调用处理程序的结构与其他异常处理程序的结构类似&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了使用寄存器传递参数，对参数有些限制：参数长度不能超过寄存器的长度（32 位）；参数不能超过 6 个。&lt;/p&gt;

&lt;p&gt;用于存放系统调用号与系统调用参数的寄存器分别为：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eax&lt;/code&gt;(系统调用号),  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebx, ecx, edx, esi, ebp&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysenter_entry()&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system_call()&lt;/code&gt; 会把这些寄存器的值保存在内核堆栈中。&lt;/p&gt;

&lt;h2 id=&quot;4-1-验证参数&quot;&gt;4-1 验证参数&lt;/h2&gt;

&lt;p&gt;在内核满足用户请求之前，需要检查所有系统调用参数。尤其对于表示地址的参数，内核必须检查该地址是否在进程的地址空间之内：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;验证该线性地址是否属于进程的地址空间&lt;/li&gt;
  &lt;li&gt;验证该线性地址是否小于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PAGE_OFFSET&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-2-访问进程地址空间&quot;&gt;4-2 访问进程地址空间&lt;/h2&gt;

&lt;p&gt;系统调用服务例程需要频繁读写进程地址空间的数据。Linux 通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_user()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put_user()&lt;/code&gt; 宏来使得访问更加容易：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_user()&lt;/code&gt;: 从一个地址读取 1, 2 或 4 个连续字节&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put_user()&lt;/code&gt;: 把这几种大小的内容写入一个地址中&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5-内核封装例程&quot;&gt;5-内核封装例程&lt;/h1&gt;

&lt;p&gt;尽管系统调用主要由用户态进程使用，但是也可以被内核线程调用，内核线程不能使用库函数（库函数属于用户态）。为了简化相应封装例程的声明，LInux 定义了 7 个从 _syscall0 到 _syscall6 的一组宏，每个宏对应着系统调用所用的参数个数。&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="Operating-System" /><summary type="html">操作系统为用户态进程与硬件设备（如 CPU，磁盘，打印机等）进行交互提供了一组接口。这种方式有以下优点：</summary></entry><entry><title type="html">非谓语动词</title><link href="http://localhost:4000/non-predicate-verb.html" rel="alternate" type="text/html" title="非谓语动词" /><published>2022-04-04T00:00:00+08:00</published><updated>2022-04-04T00:00:00+08:00</updated><id>http://localhost:4000/non-predicate-verb</id><content type="html" xml:base="http://localhost:4000/non-predicate-verb.html">&lt;h1 id=&quot;1-什么是非谓语动词&quot;&gt;1-什么是非谓语动词&lt;/h1&gt;
&lt;h2 id=&quot;1-1-介绍&quot;&gt;1-1-介绍&lt;/h2&gt;

&lt;p&gt;非谓语动词，又叫非限定动词。非谓语动词是指在句子中不是谓语的动词，主要包括&lt;strong&gt;&lt;em&gt;不定式、动名词和分词（现在分词和过去分词）&lt;/em&gt;&lt;/strong&gt;，即动词的非谓语形式。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;动名词与现在分词虽然表现形式相同，但是起到的作用是有所区别的。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;动名词只具有名词词性，在句子中做主语或者宾语。现在分词具有动词词性（与 be 动词连用补足），形容词词性（作定语），副词词性（作状语）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;非谓语动词除了不能独立作谓语外，可以承担句子的其他成分。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;非谓语动词中需要记住的口诀：&lt;strong&gt;&lt;em&gt;主动进行现在分词，被动完成过去分词，不定式表将来&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;需要注意的是，非谓语动词本身不能表示现在，过去，和将来。&lt;strong&gt;&lt;em&gt;非谓语动词表示进行，将来和完成时是相对于谓语动作来说的&lt;/em&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;和谓语动作同时发生表示进行&lt;/li&gt;
  &lt;li&gt;发生在谓语动作之后表示将来&lt;/li&gt;
  &lt;li&gt;发生在谓语动作之前表示完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-1-不定式&quot;&gt;1-1-1 不定式&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;基本形式&lt;/th&gt;
      &lt;th&gt;被动式&lt;/th&gt;
      &lt;th&gt;进行式&lt;/th&gt;
      &lt;th&gt;完成式&lt;/th&gt;
      &lt;th&gt;完成被动式&lt;/th&gt;
      &lt;th&gt;完成进行式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;to do&lt;/td&gt;
      &lt;td&gt;to be done&lt;/td&gt;
      &lt;td&gt;to be doing&lt;/td&gt;
      &lt;td&gt;to have done&lt;/td&gt;
      &lt;td&gt;to have been done&lt;/td&gt;
      &lt;td&gt;to have been doing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示主动，并且一般表示将来&lt;/td&gt;
      &lt;td&gt;表示被动，并且一般表示将来&lt;/td&gt;
      &lt;td&gt;表示主动和进行&lt;/td&gt;
      &lt;td&gt;表示主动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成进行&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;The teacher told us to do morning exercises.(to do)&lt;/li&gt;
  &lt;li&gt;The car to be bought is for his sister. (to be done)&lt;/li&gt;
  &lt;li&gt;She pretended to be reading when the teacher came into the classroom. (to be doing)&lt;/li&gt;
  &lt;li&gt;The thief is said to have escaped. (to have done)&lt;/li&gt;
  &lt;li&gt;The thief is said to have been arrested. (to have been done)&lt;/li&gt;
  &lt;li&gt;She is said to have been working in the factory over the last 20 years. (to have been doing)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-2-动名词&quot;&gt;1-1-2 动名词&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;基本形式&lt;/th&gt;
      &lt;th&gt;被动式&lt;/th&gt;
      &lt;th&gt;完成式&lt;/th&gt;
      &lt;th&gt;完成被动式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;doing&lt;/td&gt;
      &lt;td&gt;being done&lt;/td&gt;
      &lt;td&gt;having done&lt;/td&gt;
      &lt;td&gt;having been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示主动&lt;/td&gt;
      &lt;td&gt;表示被动&lt;/td&gt;
      &lt;td&gt;表示主动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Travelling in space by ordinary people will be common in the future. (doing)&lt;/li&gt;
  &lt;li&gt;Freddy and his band could go nowhere without being followed by their fans. (being done)&lt;/li&gt;
  &lt;li&gt;I have no idea of his having done such a thing against you. (having done)&lt;/li&gt;
  &lt;li&gt;Many customers complain of having been given short weight at that shop. (having been done)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-3-现在分词&quot;&gt;1-1-3 现在分词&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;基本形式&lt;/th&gt;
      &lt;th&gt;被动式&lt;/th&gt;
      &lt;th&gt;完成式&lt;/th&gt;
      &lt;th&gt;完成被动式&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;doing&lt;/td&gt;
      &lt;td&gt;being done&lt;/td&gt;
      &lt;td&gt;having done&lt;/td&gt;
      &lt;td&gt;having been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示主动和进行&lt;/td&gt;
      &lt;td&gt;表示被动和进行&lt;/td&gt;
      &lt;td&gt;表示主动和完成&lt;/td&gt;
      &lt;td&gt;表示被动和完成&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;He sat there，reading a newspaper. (doing)&lt;/li&gt;
  &lt;li&gt;The area being studied may be rich in coal. (being done)&lt;/li&gt;
  &lt;li&gt;Having finished my homework，I began to watch TV. (having done)&lt;/li&gt;
  &lt;li&gt;Having been told many times，she still can’t remember it. (having been done)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-1-4-过去分词&quot;&gt;1-1-4 过去分词&lt;/h3&gt;

&lt;p&gt;过去分词只有一种形式：done.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;及物动词的过去分词作表语，&lt;strong&gt;&lt;em&gt;与句子的主语是被动关系&lt;/em&gt;&lt;/strong&gt;，表示主语的状态。既表示被动，又强调已完成。
    &lt;ul&gt;
      &lt;li&gt;The cup is broken.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不及物动词的过去分词作表语，&lt;strong&gt;&lt;em&gt;与句子的主语是主动关系&lt;/em&gt;&lt;/strong&gt;，表示主语的状态，同样强调动作的完成。
    &lt;ul&gt;
      &lt;li&gt;He is retired.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;2-动词不定式&quot;&gt;2-动词不定式&lt;/h1&gt;
&lt;h2 id=&quot;2-1-介绍&quot;&gt;2-1-介绍&lt;/h2&gt;

&lt;p&gt;动词不定式是一种非谓语动词形式，其结构为 &lt;strong&gt;to do&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中 to 不是介词，而是动词不定式的符号，称为小品词&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;动词不定式没有人称和数的变化，但有时态和语态的变化。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;动词不定式和其后面的名词等构成不定式短语&lt;/em&gt;，在句子中可以&lt;strong&gt;用作主语、表语、宾语、定语、状语、补足语、独立成分或与疑问词等连用&lt;/strong&gt; 。&lt;/p&gt;

&lt;h2 id=&quot;2-2-时态--语态&quot;&gt;2-2-时态 &amp;amp; 语态&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;不定式&lt;/th&gt;
      &lt;th&gt;主动语态&lt;/th&gt;
      &lt;th&gt;被动语态&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;一般式&lt;/td&gt;
      &lt;td&gt;to do&lt;/td&gt;
      &lt;td&gt;to be done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;进行式&lt;/td&gt;
      &lt;td&gt;to be doing&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成式&lt;/td&gt;
      &lt;td&gt;to have done&lt;/td&gt;
      &lt;td&gt;to have been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成进行式&lt;/td&gt;
      &lt;td&gt;to have been doing&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;They pretended not to see us.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;不定式的一般式表示与谓语动词动作 &lt;strong&gt;&lt;em&gt;几乎同时发生&lt;/em&gt;&lt;/strong&gt; 或者 &lt;strong&gt;&lt;em&gt;发生在谓语动词动作之后&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;He pretended to be sleeping.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;不定式的进行式表示&lt;strong&gt;&lt;em&gt;在谓语动词动作发生的同时,不定式的动作也正在进行&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;She pretended to have known it before.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;完成式表示不定式动作&lt;strong&gt;&lt;em&gt;发生在谓语动作之前&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We’re happy to have been working with you.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;完成进行式表示&lt;strong&gt;&lt;em&gt;谓语动作发生之前,不定式的动作一直在进行而且可能之后也继续&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-3-用法&quot;&gt;2-3-用法&lt;/h2&gt;

&lt;h3 id=&quot;2-3-1-主语&quot;&gt;2-3-1 主语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;To be a doctor is hard. &lt;/li&gt;
  &lt;li&gt;To learn English well is not easy.  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;单个不定式作主语时，谓语动词用单数&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;动词不定式（短语）作主语时，为了避免句子的头重脚轻，可以&lt;strong&gt;用 “it” 作形式主语，而把真正的主语即动词不定式（短语）放在句子的后部&lt;/strong&gt;。如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It is not easy to learn English well.&lt;/li&gt;
  &lt;li&gt;It is important for students to use English every day.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-2-宾语&quot;&gt;2-3-2 宾语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;动词不定式当宾语的格式为：vt + to do.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;动词不定式（短语）可以放在一些动词后面用作宾语，能以动词不定式作宾语的动词有：begin, start, want, forget, remember, learn, like, hate, love, ask , decide, expect, want, hope, wish, offer, fail, plan, learn, pretend, refuse, manage, help, agree, promise, prefer, mean 等等&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;I want to tell you a story.&lt;/li&gt;
  &lt;li&gt;They begin to work at eight every morning.&lt;/li&gt;
  &lt;li&gt;Don’t forget to lock the door.&lt;/li&gt;
  &lt;li&gt;Would you like to go and have a picnic with us tomorrow?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果 and 连接两个动词不定式，&lt;em&gt;第二个动词不定式一般省 “to”&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He wants to go and have a swim with us.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;若作宾语的动词不定式（短语）很长，可用 it 作形式宾语&lt;/strong&gt;（与形式主语类似）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I find it interesting to learn English with you.&lt;/li&gt;
  &lt;li&gt;He found it hard to catch up with others.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-3-3-表语&quot;&gt;2-3-3 表语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;表语，属于主语补足语，语法名词，是指说明主语的身份、性质、品性、特征和状态的词或从句。表语常由名词、形容词、介词短语、动名词、不定式、副词来充当，它&lt;em&gt;常位于系动词之后&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;不定式表示目的
    &lt;ul&gt;
      &lt;li&gt;The purpose of education is to develop a fine personality in children.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示事态发展的结果、预期的结果、不幸的命运
    &lt;ul&gt;
      &lt;li&gt;He was to perish in a shipwreck and to leave a wife and two children.&lt;/li&gt;
      &lt;li&gt;You are to die at ninety-eight.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用于第一人称疑问句，表示征求意见
    &lt;ul&gt;
      &lt;li&gt;What am I to say if they ask me the question?&lt;/li&gt;
      &lt;li&gt;What am I to do if I have no money?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示“同意、安排、命令、决定、劝告、意愿、禁止”等
    &lt;ul&gt;
      &lt;li&gt;They are to marry next week.&lt;/li&gt;
      &lt;li&gt;Children are not to smoke.&lt;/li&gt;
      &lt;li&gt;You must be patient and persistent if you are to succeed.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;不定式作表语，可用主动形式表示被动意义&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;She is to blame.&lt;/li&gt;
      &lt;li&gt;Something is still to find out.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-4-定语&quot;&gt;2-3-4 定语&lt;/h3&gt;

&lt;p&gt;动词不定式作定语，&lt;em&gt;放在所修饰的名词或代词后&lt;/em&gt;。与所修饰名词有如下关系:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;主谓关系&lt;/p&gt;

    &lt;p&gt;不定式作定语表示主谓关系，指的是中心词是不定式的逻辑主语&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;He is not a man to tell a lie.&lt;/li&gt;
      &lt;li&gt;See if you can get the car to start.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动宾关系&lt;/p&gt;

    &lt;p&gt;不定式作定语表示动宾关系，指的是中心词是不定式的逻辑宾语&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;We have a lot of work to do.&lt;/li&gt;
      &lt;li&gt;I have some clothes to wash.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;当不定式与所修饰的中心词有动宾关系时，不定式的动词需为及物动词，若是不及物动词，不定式后需加上适当的介词。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I need a pen to write with.&lt;/li&gt;
      &lt;li&gt;Give me some paper to write on.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同位关系&lt;/p&gt;

    &lt;p&gt;不定式做定语表示同位关系，指的是不定式是中心词的内容，两者具有同位关系&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I have a wish to go to college.&lt;/li&gt;
      &lt;li&gt;I had a dream to fly in the sky like a bird.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有时不表示任何特别关系&lt;/p&gt;

    &lt;p&gt;有时不定式与被修饰的名词不存在主谓、动宾、同位关系的，此时被修饰的名词多是些抽象名词&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;We have no need to be afraid of them!&lt;/li&gt;
      &lt;li&gt;The dog found out the way to open the door.&lt;/li&gt;
      &lt;li&gt;I am sure of his ability to cope with this.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-5-状语&quot;&gt;2-3-5 状语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;状语的作用：状语说明地点、时间、原因、目的、结果、条件、方向、程度、方式和伴随状语等。状语一般由副词、介词短语、分词和分词短语、不定式或相当于副词的词或短语来担当。其位置一般放在句首，但也可放在句末或句中。状语是一种用来修饰动词，形容词，副词或全句的词，说明时间，地点，程度，方式等概念。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;表示目的&lt;/p&gt;

    &lt;p&gt;不定式用作目的状语时，常常翻译成”为了”，”目的是”。&lt;/p&gt;

    &lt;p&gt;不定式用作目的状语&lt;strong&gt;&lt;em&gt;常放在句首和句末&lt;/em&gt;&lt;/strong&gt;。一般说来，用于句首属于强调性用法，即强调动词的目的。&lt;/p&gt;

    &lt;p&gt;有时为了&lt;strong&gt;&lt;em&gt;特别强调目的状语，可以在不定式之前加上 in order 或 so as，即构成 in order to do sth.和 so as to do sth. 结构&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;To finish my work, I worked overtime late into the night last Friday.&lt;/li&gt;
      &lt;li&gt;He worked day and night to get the money.&lt;/li&gt;
      &lt;li&gt;She sold her hair to buy the watch chain.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;注意不定式放句首时，逻辑主语与句子主语要一致。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;wrong: To save money, every means has been tried.&lt;/li&gt;
      &lt;li&gt;right: To save money, he has tried every means.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表示结果&lt;/p&gt;

    &lt;p&gt;不定式作结果状语只限于下面几个词：&lt;strong&gt;&lt;em&gt;learn（得知），find（发现），see（看见），hear（听见），to be told（被告知），make（使得&lt;/em&gt;&lt;/strong&gt;）等。&lt;/p&gt;

    &lt;p&gt;only + 不定式常表示出乎意料的结果。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I hurried to the library only to find it is closed.&lt;/li&gt;
      &lt;li&gt;He arrived late only to find the train had gone.&lt;/li&gt;
      &lt;li&gt;I visited him only to find him out.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表示原因&lt;/p&gt;

    &lt;p&gt;不定式作原因状语主要&lt;strong&gt;&lt;em&gt;用于表示情绪与心理状态的动词或形容词&lt;/em&gt;&lt;/strong&gt;，表示人对某事某物的反应如何，常译作“因……而……”。&lt;/p&gt;

    &lt;p&gt;常见的这类形容词有 able（有能力的），afraid（害怕的），cruel（残忍的），possible（可能的），proud（自豪的），unable（没能力的），useless（没用的），willing（愿意的）等。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;I am so glad to hear the news .&lt;/li&gt;
      &lt;li&gt;They were very sad to hear the news.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;表示程度&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;It’s too dark for us to see anything.&lt;/li&gt;
      &lt;li&gt;The question is simple for him to answer.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-6-宾语补足语&quot;&gt;2-3-6 宾语补足语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;宾语补足语指有些及物动词，接了宾语意义仍不完整，还需要有一个其他的句子成分，来补充说明宾语的意义、状态等，简称宾补。
宾语和它的补足语构成复合宾语。而复合宾语的第一部分通常由名词或代词充当，第二部分表示第一部分的名词或代词发出的动作或身份、特征等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在复合宾语中，动词不定式可充当宾语补足语，如下动词常跟这种复合宾语: want, wish, ask, tell, order, beg, permit, help, advise, persuade, allow, prepare, cause, force, call on, wait for, invite…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Father will not allow us to play on the street.&lt;/li&gt;
  &lt;li&gt;We believe him to be guilty.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，介词有时也与这种复合宾语连用:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;With a lot of work to do, he didn’t go to the cinema.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;有些动词如 make, let, see, watch, hear, feel, have 等与不带有 to 的不定式连用，但改为被动语态时，不定式要加 to&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I saw him cross the road.&lt;/li&gt;
  &lt;li&gt;He was seen to cross the road.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-动名词&quot;&gt;3-动名词&lt;/h1&gt;
&lt;h2 id=&quot;3-1-介绍&quot;&gt;3-1-介绍&lt;/h2&gt;

&lt;p&gt;动名词是由动词变化而来，一方面保留着动词的某些特征，具有动词的某些变化形式，用以表达名词所不能表达的较为复杂的意念；另一方面动名词在句子的用法及功能与名词类同: 在句子中可以作主语、宾语、表语、定语，它也可以被副词修饰或者用来支配宾语。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;既有动词的变化形式，又具有名词的用法&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-2-用法&quot;&gt;3-2-用法&lt;/h2&gt;

&lt;h3 id=&quot;3-2-1-主语&quot;&gt;3-2-1 主语&lt;/h3&gt;

&lt;p&gt;动名词做主语，&lt;strong&gt;谓语动词用单数&lt;/strong&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;直接位于句首做主语&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Swimming is a good sport in summer.&lt;/li&gt;
      &lt;li&gt;Fighting broke out between the South and the North.&lt;/li&gt;
      &lt;li&gt;Breathing became difficult at that altitude.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;用 it 作形式主语&lt;/strong&gt;，把&lt;strong&gt;动名词&lt;/strong&gt;(真实主语)&lt;strong&gt;置于句尾作后置主语&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;动名词做主语时，不太常用 it 作先行主语，多见于某些形容词及名词之后。常见的能用于这种结构的形容词还有：good，better，wonderful, enjoyable，interesting，foolish，difficult，useless，senseless，worthwhile，等。但是 important，essential，necessary 等形容词不能用于上述结构。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;It is no use waiting for him any longer.&lt;/li&gt;
      &lt;li&gt;It is no good learning without practice.&lt;/li&gt;
      &lt;li&gt;It is dangerous using this method to measure the speed of light.&lt;/li&gt;
      &lt;li&gt;It is worthwhile consulting your tutor about it again.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用于 “&lt;strong&gt;There be” 结构&lt;/strong&gt;中
    &lt;ul&gt;
      &lt;li&gt;There is no saying when he’ll come. 很难说他何时回来&lt;/li&gt;
      &lt;li&gt;There is no joking about such matters.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用于&lt;strong&gt;布告形式的省略结构&lt;/strong&gt;中
    &lt;ul&gt;
      &lt;li&gt;No smoking. =  Smoking is not allowed here.&lt;/li&gt;
      &lt;li&gt;No parking.  = parking is not allowed here.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动名词的复合结构作主语&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;当动名词有自己的逻辑主语时，常可以在前面加上一个&lt;strong&gt;名词或代词的所有格&lt;/strong&gt;，构成动名词的复合结构(此时，名词或代词的所有格做动名词的逻辑主语)。&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;His coming to help was a great encouragement to us.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-2-定语&quot;&gt;3-2-2 定语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;动名词一般为名词性，很少做定语，不过在&lt;strong&gt;&lt;em&gt;一些特殊的情况下可以用来表示所修饰名词的用途&lt;/em&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;sleeping bag&lt;/li&gt;
      &lt;li&gt;walking stick&lt;/li&gt;
      &lt;li&gt;drinking water&lt;/li&gt;
      &lt;li&gt;swimming pool&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有些动名词已经转化成了形容词，常用作定语修饰物，表示“令人……的”，如 exciting, shocking, puzzling, confusing, disappointing, discouraging, boring, tiring, moving, touching, interesting, satisfying, frightening, amazing 等
    &lt;ul&gt;
      &lt;li&gt;That must be a terrifying experience.&lt;/li&gt;
      &lt;li&gt;The experiment was an amazing success.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-3-宾语&quot;&gt;3-2-3 宾语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;一些动词后用动名词作宾语，如 finish 完成，enjoy享受，mind介意，suggest建议，practise练习，admit 承认，advise 建议，allow 允许，appreciate 感激，avoid 避免，consider 考虑，delay 推迟，deny 否认，discuss 讨论，dislike 不喜欢，enjoy 喜爱，escape 逃脱，excuse 原谅，fancy 设想， forbid 禁止，forgive 原谅，imagine 想像，keep 保持，mention 提及，mind 介意 miss 没赶上，pardon 原谅，permit 允许， prevent 阻止，risk 冒险，understand 理解
    &lt;ul&gt;
      &lt;li&gt;I admit breaking the window.&lt;/li&gt;
      &lt;li&gt;Try to imagine being on the moon.&lt;/li&gt;
      &lt;li&gt;He tried to escape being punished.&lt;/li&gt;
      &lt;li&gt;You shouldn’t keep thinking about it.&lt;/li&gt;
      &lt;li&gt;Would you mind going with her?&lt;/li&gt;
      &lt;li&gt;I can’t understand neglecting children like that.&lt;/li&gt;
      &lt;li&gt;We only missed seeing each other by five minutes.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有些动词短语后跟动名词作宾语，如 insist on, be worth，give up，object/objection to，put off，keep on，insist on，leave off，look forward to，think of, can’t help, be/get used to, spend…in ,can’t stand，feel like 等
    &lt;ul&gt;
      &lt;li&gt;Do you feel like going out for dinner with me tonight?&lt;/li&gt;
      &lt;li&gt;Chinese people are looking forward to holding the 27th Olympic games.&lt;/li&gt;
      &lt;li&gt;I am used to going to bed late and getting up late.&lt;/li&gt;
      &lt;li&gt;The professor was quite used to students’ being late for his lecture.&lt;/li&gt;
      &lt;li&gt;He put off making a decision till he had more information.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-4-表语&quot;&gt;3-2-4 表语&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;动名词作表语时句子&lt;strong&gt;主语常是表示无生命的事物名词或 what 引导的名词性从句&lt;/strong&gt;。表语动名词与主语通常是对等的关系，表示主语的内容，&lt;strong&gt;主语、表语可互换位置&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果句中的主语和表语同为动词时，要注意保持两个动词在形式上的一致。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;Your task is cleaning the windows. = Cleaning the windows is your task.&lt;/li&gt;
      &lt;li&gt;What I hate most is being laughed at. = Being laughed at is what I hate most.&lt;/li&gt;
      &lt;li&gt;The most popular pastime is playing chess. = Playing chess is the most popular pastime.&lt;/li&gt;
      &lt;li&gt;The only thing that interests her is working. = Working is the only thing that interests her.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-现在分词&quot;&gt;4-现在分词&lt;/h1&gt;
&lt;h2 id=&quot;4-1-介绍&quot;&gt;4-1-介绍&lt;/h2&gt;

&lt;p&gt;分词分为现在分词与过去分词，均是非谓语动词。分词在句子中不能单独充当谓语，不过可以充当其他成分：定语，表语，补语，状语，并且&lt;strong&gt;&lt;em&gt;分词具有动词性质&lt;/em&gt;&lt;/strong&gt;，因此是类动词的一种。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;动名词只具有名词词性&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;现在分词一方面&lt;strong&gt;&lt;em&gt;具有动词特性，可以拥有自己的宾语与状语&lt;/em&gt;&lt;/strong&gt;；另一方面&lt;strong&gt;&lt;em&gt;具有形容词与副词的特性，可以充当定语，表语，补语，状语&lt;/em&gt;&lt;/strong&gt;。现在分词可以表示主动或者正在进行的动作。&lt;/p&gt;

&lt;h2 id=&quot;4-2-时态与语态&quot;&gt;4-2-时态与语态&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;时态&lt;/th&gt;
      &lt;th&gt;主动语态&lt;/th&gt;
      &lt;th&gt;被动语态&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;一般式&lt;/td&gt;
      &lt;td&gt;doing&lt;/td&gt;
      &lt;td&gt;being done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;完成式&lt;/td&gt;
      &lt;td&gt;having done&lt;/td&gt;
      &lt;td&gt;having been done&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;否定式&lt;/td&gt;
      &lt;td&gt;-ing 前加 not&lt;/td&gt;
      &lt;td&gt;-ing 前加 not&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;现在分词的&lt;strong&gt;一般式通常表示其动作与谓语动词同时发生；完成式表示其动作在谓语动词的动作发生之前完成；被动式表示其逻辑主语为现在分词动作的承受者&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;She sat there reading a novel.&lt;/li&gt;
  &lt;li&gt;Having finished her homework, the little girl began to watch TV.&lt;/li&gt;
  &lt;li&gt;The building being built is our library.&lt;/li&gt;
  &lt;li&gt;Having been warned by the teacher, the students didn’t make such mistakes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-3-用法&quot;&gt;4-3-用法&lt;/h2&gt;

&lt;h3 id=&quot;4-3-1-定语&quot;&gt;4-3-1 定语&lt;/h3&gt;

&lt;p&gt;现在分词作定语，表示&lt;em&gt;正在进行的或主动的动作，也可以说明被修饰词的性质和特征&lt;/em&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;现在分词单独做定语，通常放在所修饰词之前
    &lt;ul&gt;
      &lt;li&gt;The sleeping boy is Tom.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;现在分词短语作定语，通常放在所修饰词的后面，类似于定语从句
    &lt;ul&gt;
      &lt;li&gt;Tell the children playing outside not to make noise.&lt;/li&gt;
      &lt;li&gt;Tell the children who are playing outside not to make noise.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-2-表语&quot;&gt;4-3-2 表语&lt;/h3&gt;

&lt;p&gt;现在分词作表语，通常表示主语的特征。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The story is moving.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-3-3-宾语补足语&quot;&gt;4-3-3 宾语补足语&lt;/h3&gt;

&lt;p&gt;现在分词作宾语补足语，表示正在进行的或主动进行的动作，与&lt;strong&gt;&lt;em&gt;前边的宾语有逻辑上的“主表“或”主谓“关系&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We all found his equipment interesting. (主表关系)&lt;/li&gt;
  &lt;li&gt;I saw Mary going upstairs then. (主谓关系)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-3-4-状语&quot;&gt;4-3-4 状语&lt;/h3&gt;

&lt;p&gt;现在分词作状语时，可作时间、条件、结果、原因和伴随状语，表示正在进行的或主动的动作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;分词的逻辑主语就是主句的主语，因此要注意人称、时态和语态的一致性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;作原因状语，相当于原因状语从句
    &lt;ul&gt;
      &lt;li&gt;Being ill, Mary didn’t come to school yesterday.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作时间状语，相当于时间状语从句
    &lt;ul&gt;
      &lt;li&gt;Seeing their teacher coming, the students stopped talking.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作条件状语，相当于条件状语从句
    &lt;ul&gt;
      &lt;li&gt;Working harder, you’ll be No. 1 in your class.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作让步状语，相当于让步状语从句
    &lt;ul&gt;
      &lt;li&gt;Weighing almost two hundred pounds, the stone was moved by him alone.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作结果状语，相当于结果状语从句
    &lt;ul&gt;
      &lt;li&gt;He died, leaving nothing but debts.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作伴随状语，相当于伴随状语从句
    &lt;ul&gt;
      &lt;li&gt;Look at the people lying on the beach.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作方式状语，相当于伴随状语从句
    &lt;ul&gt;
      &lt;li&gt;Please answer the question using another way.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-5-独立成分&quot;&gt;4-3-5 独立成分&lt;/h3&gt;

&lt;p&gt;现在分词作独立成分，即独立主格。常见形式有：generally speaking(一般来说), Judging form/by (由…判断)。&lt;/p&gt;

&lt;p&gt;独立主格没有主语和谓语，只有逻辑上的主语，因此，它在句法上不是句子，而是一个独立于句子成分外的独特结构形式。&lt;/p&gt;

&lt;p&gt;独立主格结构可置于句首或者句尾，用逗号与主句隔开；形式为：&lt;strong&gt;名词/名词短语/代词 + 不定式/ing分词/ed分词/形容词/副词/介词短语（名词前也可以加with）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;独立主格结构主要用于描绘性文字中，其作用相当于一个状语从句，常用来表示时间、原因、条件、行为方式或伴随情况等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;表示时间
    &lt;ul&gt;
      &lt;li&gt;The meeting being over, all of us went home.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示条件
    &lt;ul&gt;
      &lt;li&gt;The condition being favorable, he may succeed.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示原因
    &lt;ul&gt;
      &lt;li&gt;There being no taxis, we had to walk.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示伴随情况
    &lt;ul&gt;
      &lt;li&gt;Almost all metals are good conductors, silver being the best of all.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示补充说明
    &lt;ul&gt;
      &lt;li&gt;We redoubled our efforts, each man working like two.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-什么是非谓语动词 1-1-介绍</summary></entry><entry><title type="html">Distributed Systems</title><link href="http://localhost:4000/distributed-systems.html" rel="alternate" type="text/html" title="Distributed Systems" /><published>2022-03-07T00:00:00+08:00</published><updated>2022-03-07T00:00:00+08:00</updated><id>http://localhost:4000/distributed-systems</id><content type="html" xml:base="http://localhost:4000/distributed-systems.html">&lt;blockquote&gt;
  &lt;p&gt;翻译自 DDIA 作者 Martin Kleppmann 分布式系统课程：&lt;a href=&quot;https://www.youtube.com/watch?v=UEAMfLPZZhE&amp;amp;list=PLeKd45zvjcDFUEv_ohr_HdUFe97RItdiB&quot;&gt;视频&lt;/a&gt;; &lt;a href=&quot;https://www.cl.cam.ac.uk/teaching/2122/ConcDisSys/dist-sys-notes.pdf&quot;&gt;课件&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;1-introduction&quot;&gt;1-Introduction&lt;/h1&gt;

&lt;p&gt;运行在同一个进程中的多个线程共享同一个地址空间，因此单台计算机上的并发也被称为“共享内存并发”（shared-memory concurrency）。在这种模式下，很容易将数据从一个线程传递到另一个线程：比如指针（pointer），变量（variable）。&lt;/p&gt;

&lt;p&gt;在分布式系统中，上述场景就有所不同了。分布式系统中虽然仍存在并发（不同的计算机可以并发执行同一个应用程序），但这些计算机通常不会共享内存（每个计算机都有自己的地址空间，访问自己的内存），此时节点之间只能通过网络进行通信（network）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在一些超级计算机和科研系统中存在有限形式的共享内存模型，比如 RDMA（remote directly memory access）技术可以使得不同计算机通过网络互相访问内存；数据库（database）在某种程度上也可以被看作是共享内存模型，只不过与常见的字节寻址模型不同。总体来说，大部分分布式系统都是基于消息传递（message-passing）。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;分布式系统中的每个节点被称为 Node。Node 含义比较广泛，可以是任何通信计算设备：如桌面计算机，数据中心的服务器，移动设备，网联车，传感器等。&lt;/p&gt;

&lt;p&gt;关于分布式系统，Lamport 给出的定义是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a system in which the failure of a computer you didn’t even know existed can render your own computer unusable.&lt;/li&gt;
  &lt;li&gt;multiple computers communicating via a network&lt;/li&gt;
  &lt;li&gt;trying to achieve some task together&lt;/li&gt;
  &lt;li&gt;Consists of “nodes” (computer, phone, car, robot, . . . )&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-1-about-distributed-systems&quot;&gt;1-1 About distributed systems&lt;/h2&gt;

&lt;p&gt;为什么要使用分布式系统？有以下原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一些应用本质上就是分布式的（intrinsically distributed）：比如手机之间发送短信，该过程不可避免地要求不同手机间通过网络交互&lt;/li&gt;
  &lt;li&gt;提高可靠性（more reliably）：如果系统中只有一个节点，该节点可能会故障，偶尔需要重启，那么系统就继续提供服务。但是如果系统中存在多个节点，当某个节点重启时，其他节点能够继续提供服务。所以，分布式系统要比单点系统更可靠。&lt;/li&gt;
  &lt;li&gt;提升系统性能（performance）：假设一个服务被世界各地的用户访问，如果该服务是单点系统，那么总有一些地区的用户会觉得服务响应很慢，体验很差。如果该服务是分布式系统，可以将系统节点分布在世界各地，通过将用户路由到最近的节点以提高访问速度。&lt;/li&gt;
  &lt;li&gt;提升系统处理能力（solve bigger problems）：随着数据规模增大，处理任务增多，单节点可能无法承载，或者处理速度很慢。通过将任务分散到不同的节点，以提高系统整体处理能力。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然而，分布式系统也存在不足：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;网络异常（network failure）：网络异常时，节点间将无法正常通信&lt;/li&gt;
  &lt;li&gt;节点自身异常（node failure）：节点可能会崩溃（crash），运行过慢，或者由于软件硬件方面的异常导致不符合预期。如果我们想要实现故障转移，我们首先需要能够检测（detect）到故障确实发生了；而准确检测故障并不是一件容易的事&lt;/li&gt;
  &lt;li&gt;网络故障及节点异常经常会发生，系统需要能够处理这些异常&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在单点系统中，如果出现硬件异常，通常我们不会期望服务仍能正常运行，因此不会对这些异常在软件层面做额外的处理。但是在分布式系统中，我们需要容忍部分节点异常：一些节点不可用时，其他节点能够继续提供服务。&lt;/p&gt;

&lt;p&gt;我们把系统组件故障称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fault&lt;/code&gt;，分布式系统需要能够容忍部分组件故障（ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fault tolerance&lt;/code&gt;）：尽管存在故障，整个系统仍然能够正常运行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不过，故障处理通常比较难&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-2-distributed-systems-and-computer-networking&quot;&gt;1-2 Distributed systems and computer networking&lt;/h2&gt;

&lt;p&gt;学习分布式系统，通常需要对硬件进行抽象。&lt;/p&gt;

&lt;p&gt;我们假设节点间通过某种方式通信，而不关心消息如何被编码，通过何种方式发送等物理层表现方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从分布式系统的角度看，我们只需要关注通信延迟（latency）与带宽（boundwith）即可。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;延迟：消息发送到接收的间隔&lt;/li&gt;
  &lt;li&gt;带宽：单位时间内能够被传输的数据量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分布式系统建立在基础设施之上，更专注于如何进行节点之间的协调，以共同完成任务。分布式系统算法主要关于节点发送什么消息，及节点如何处理收到的消息。&lt;/p&gt;

&lt;p&gt;浏览器访问网页是一个我们经常使用的分布式系统例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该例子中的节点有两种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;server：网络站点提供服务&lt;/li&gt;
  &lt;li&gt;client: 浏览器用于展示从站点加载的内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;加载网页时，浏览器发送 HTTP request message 到合适的 server 节点；收到请求后，server 返回携带网页内容的 response message（可能是 HTML 文档，图片，视频等）。&lt;/p&gt;

&lt;p&gt;HTTP 协议运行在 TCP 协议之上：当 HTTP 报文较大时，TCP 将 HTTP request 内容切分为适当大小的报文，对于接收到的 response 报文段会重新拼接。HTTP 允许多个 request &amp;amp; response 复用同一个 TCP 链接。&lt;/p&gt;

&lt;p&gt;网络通信协议有很多细节，然而当我们从分布式系统的角度观察时，具体细节并不重要：&lt;strong&gt;我们只需要把 request &amp;amp; response 分别看作一条消息，忽略底层网络实现&lt;/strong&gt;，使得事情变得更简单（独立于底层网络）。&lt;/p&gt;

&lt;h2 id=&quot;1-3-example-remote-procedure-calls-rpc&quot;&gt;1-3 Example: Remote Procedure Calls (RPC)&lt;/h2&gt;

&lt;p&gt;使用信用卡进行网络购物是另一个分布式系统的例子。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当我们进行购物付款时，就会通过网络给专门处理信用卡支付的服务发送请求&lt;/li&gt;
  &lt;li&gt;付款服务反过来会与发行信用卡的银行进行通信，以确保该信用卡能够完成支付&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在线购物的支付服务实现的代码可能如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Online shop handling customer's card details
Card card = new Card();
card.setCardNumber(&quot;1234 5678 8765 4321&quot;);
card.setExpiryDate(&quot;10/2024&quot;);
card.setCVC(&quot;123&quot;);

Result result = paymentsService.processPayment(card,
   3.99, Currency.GBP);
if (result.isSuccess()) {
   fulfilOrder();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processPayment&lt;/code&gt; 方法调用看起来与本地调用的其他方法类似，不过实际上是向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PaymentService&lt;/code&gt; 发送了一个网络请求并等待响应。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processPayment&lt;/code&gt; 方法需要与发行信用卡的银行进行交互，实现逻辑并不在本地，而是在其他节点。&lt;/p&gt;

&lt;p&gt;这种交互方式（一个节点的代码看起来是调用另一个节点的方法）被称为 &lt;strong&gt;Remote Procedure Call（RPC）&lt;/strong&gt;。在 Java 中，也被称为 Remote Method Invocation（RMI）。实现 RPC 的软件被称为 RPC Framework，或者 Middleware。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;并不是所有的中间件都基于 RPC 通信，还存在其他通信模型&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;当一个服务想要调用运行在其他节点上的方法时，&lt;strong&gt;RPC 框架会在 Client 本地创建 stub 来代替目标方法&lt;/strong&gt;。该 stub 的方法签名与真正的方法签名相同，但是并不真正执行方法，而是&lt;em&gt;将方法参数编码成特定的消息，并将该消息发送到远程节点，请求调用对应方法&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;方法参数编码的过程被称为 marshall；存在多种编码格式，比如 JSON&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;从 RPC Client 发送消息到 RPC Server 可能会使用不同的网络协议（如果使用 HTTP 协议，则被称为 Web Service）。在 Server 端，RPC 框架会解码收到的消息，并通过解析出的方法参数调用目标方法。当调用方法返回时，返回结果同样会被编码成消息发送给 Client。Client 收到后会解码并通过 stub 返回给调用方。因此，对 stub 的调用方来说，方法看起来是在本地执行并返回。&lt;/p&gt;

&lt;p&gt;对应在线支付的执行流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不过，由于网络或者节点可能会出现故障，RPC 实现时有许多问题需要考虑。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法调用期间，服务崩溃&lt;/li&gt;
  &lt;li&gt;消息传递过程中丢失了&lt;/li&gt;
  &lt;li&gt;消息延迟过大&lt;/li&gt;
  &lt;li&gt;调用出现问题时，能否进行安全重试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当 RPC Client 发送请求后却没有收到响应，Client 并不能确定 Server 是否收到消息。此时应该如何处理？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Client 可以进行重试，但是可能会导致请求被执行多次（如多次支付）；并且，我们也无法保证重试的消息能够成功被成功接收&lt;/li&gt;
  &lt;li&gt;Client 也不能长时间等待响应。因此，在实践中，Client 通常在超时之后放弃此次请求&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在过去几十年，RPC 发展了很多变体，包括面向对象的中间件（如 CORBA）。如今最常见的 RPC 形式是&lt;strong&gt;通过 HTTP 发送 JSON 格式数据&lt;/strong&gt;。这种基于 HTTP 的 API 设计原则被称为&lt;strong&gt;表示状态传输（Representational state transfer）或者 REST&lt;/strong&gt;，遵守该设计原则的 API 被认为 RESTful。具体协议包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;资源（resources）通过 URL 表示&lt;/li&gt;
  &lt;li&gt;使用标准方法类型的 HTTP 请求来更新资源状态（state），如 POST, PUT&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;REST 的兴起得益于运行在浏览器上的 JavaScript 代码可以很容易发送该请求。不过，虽然 RESTful API 或者其他以 HTTP 为基础的 RPC 是面向 Web 的，但是也可以用于其他类型的 Client 或者 Server-to-Server 的交互。&lt;/p&gt;

&lt;p&gt;Server-to-Server 交互场景在大型企业服务上比较常见：企业服务由于过大且复杂，以至于单台机器无法运行，因此常被拆分为多个服务。每个服务被不同的团队开发 &amp;amp; 管理，不同的服务可能使用不同的开发语言；RPC 框架实现了不同服务之间的交互。&lt;/p&gt;

&lt;p&gt;当相互通信的服务使用不同的开发语言时，RPC 框架需要能够转化数据类型，使得被调用方能够理解调用方的请求参数；对于返回值也是同样的。&lt;/p&gt;

&lt;p&gt;常见的解决方案是使用 Interface Definition Language（IDL）提供与编程语言无关的 RPC 方法签名。通过 IDL 可以自动生成 marshall &amp;amp; unmarshall 代码，同时可以生成与语言无关的 Server stubs &amp;amp; Client stubs。下面是 gRPC 的 IDL 示例：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message PaymentRequest {
	message Card {
		required string cardNumber = 1;
		optional int32 expiryMonth = 2;
		optional int32 expiryYear = 3;
	}
	
	required Card card = 1;
	required int64 amount = 2;
}

message PaymentStatus { 
	required bool success = 1;
	optional string errorMessage = 2;
}

// service
service PaymentService {
	rpc ProcessPayment(PaymentRequest) returns (PaymentStatus) {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-models-of-distributed-systems&quot;&gt;2-Models of distributed systems&lt;/h1&gt;

&lt;p&gt;系统模型是对系统中 nodes &amp;amp; network 行为的假设及属性的抽象。为了阐述通用的系统模型，先引用两个经典的模型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The Two Generals Problem&lt;/li&gt;
  &lt;li&gt;The Byzantine Generals Problem&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-1-the-two-generals-problem&quot;&gt;2-1 The two generals problem&lt;/h2&gt;

&lt;p&gt;问题描述：假设有两个将军，每人领导一个军队，并且这两个将军都想占领同一座城市。城市的防御很坚固，如果每次只有一个军队进攻，那么会进攻失败；如果两个军队同时进攻，则能够成功占领城市。因此，这两个将军需要协调他们的进攻计划。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目标：只有在军队 2 进攻的情况下，军队 1 才会发起进攻&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;不过，由于这两个军队之间存在一定的距离，彼此间通信只能依靠信使。信使需要通过由城市控制的区域，并且有时候会被捕获，那么消息就无法成功送达。对于发送方来说，&lt;strong&gt;&lt;em&gt;除非发送方收到接收方的明确回复，否则也不确定之前发送的消息是否成功被接收&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果一方没有收到消息，可能是对方确实没有发送消息，也可能是对方发送的所有消息都被截获了。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如何使这两个将军就进攻计划达成一致？对每个将军来说，有两种选择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;承诺在任何情况下都发起进攻&lt;/strong&gt;，即使没有收到对方的明确回复&lt;/p&gt;

    &lt;p&gt;这种情况下，发起进攻的将军可能会冒险独自进攻&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;直到收到对方明确回复才会发起进攻，否则就一直等待&lt;/p&gt;

    &lt;p&gt;这种情况相当于将问题抛给了对方：接收方需要决定是否等待回复消息的确认，还是回复之后就发起进攻（也可能会独自进攻）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;无法达成共识：只能通过消息传递来获取信息&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;两将军的问题在于，不管双方交换了多少次消息，也无法确定对方一定能同时进攻。对于分布式系统来说，&lt;strong&gt;一个节点无法准确判断另一个节点的状态；不过通过消息传递的方式，可以得到一些信息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;上面介绍的在线商店支付流程可以看作是两将军问题的例子：在线商店服务与信用卡支付服务之间通过 RPC 进行消息传递，并且消息可能会丢失；尽管如此，商店只有在商品被支付成功的情况下才会发货，支付服务只有在商品被发货才会进行扣款。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目标：只有商品被支付成功的情况下，在线商店才会发送货物&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;不过，实际上该流程与两将军问题有点不同：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;支付服务在任何情况下都可以先进行扣款操作，如果在线商店始终无法发送货物，可以再进行退款操作。由于&lt;strong&gt;支付操作可以撤回&lt;/strong&gt;，使得在两将军中的问题可以解决。&lt;/li&gt;
  &lt;li&gt;即使由于网络等问题导致在线商店服务暂时无法确定支付状态，可以在连接恢复之后再主动查询确定交易状态。发送方可以稍后再次确认之前的消息送达情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-2-the-byzantine-generals-problem&quot;&gt;2-2 The Byzantine generals problem&lt;/h2&gt;

&lt;p&gt;问题描述：拜占庭将军问题的设定与两将军问题类似。假设多个军队（可以是 3 个以上）需要占领一座城市，不同军队之间仍然通过信使进行通信，只不过此时消息总是能够被成功送达。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在拜占庭将军问题中，有些将军可能是叛徒：他们可能会故意误导及迷惑其他将军。我们把叛徒称为 “malicious”，其他将军称为 “honest”。&lt;/p&gt;

&lt;p&gt;malicious 可能有以下行为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将军 3 分别从将军 1 &amp;amp; 将军 2 收到两条矛盾的消息
    &lt;ul&gt;
      &lt;li&gt;将军 1 声明要进攻&lt;/li&gt;
      &lt;li&gt;将军 2 声明将军 1 想要撤退&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将军 3 无法确定将军 2 是否在撒谎
    &lt;ul&gt;
      &lt;li&gt;第一种场景，将军 2 在撒谎&lt;/li&gt;
      &lt;li&gt;第二种场景，由于将军 1 先后声明了两个矛盾的消息，此时将军 2 并没有撒谎&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;honest 并不知道哪些是 malicious，但是 malicious 之间可以秘密串通协调他们的行动。拜占庭将军问题的目标是需要确保&lt;strong&gt;所有的 honest 对计划达成一致&lt;/strong&gt;：不管是进攻还是撤退。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据设定，我们无法确定 malicious 的行动，所能做的只有让 honest 达成一致&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;然而由于 malicious 的存在及不可预测的通信延迟，使得上述目标很难实现；只有在 malicious 的数目严格少于 1/3 时，拜占庭问题才能得到解决。如果系统中存在 3*f+1 个节点，那么 malicious 数目不能多于 f。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过引入密码学会使得拜占庭将军问题变得相对简单，但是问题仍然存在，例如数字签名：将军 2 需要向将军 3 证明将军 1 的声明。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;那么拜占庭将军问题是否具有实际意义？&lt;/p&gt;

&lt;p&gt;在实际的分布式系统中，通常涉及比较复杂的信任关系。比如，消费者需要信任在线商店真的会发送订单中的商品，尽管消费者在商品无法送达或者其他原因向银行提出异议。但是如果在线商店允许消费者在不支付的情况下就可以下单，这种情况下可能会被欺诈者利用，因此在线商店会假设消费者是潜在的 malicious。另一方面，在线商店的多个服务同属一个数据中心，它们内部间基本互相信任，但是支付服务并不完全信任在线商店服务，因为其他人可能会设立欺诈性的商店或者使用被盗信用卡（不过在线商店服务通常信任支付服务）。最后，我们期望消费者，在线商店，支付服务就任何订单达成一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;拜占庭将军问题可以看作是复杂信任关系的简化&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在一些分布式系统中，会明确处理存在 malicious 节点的可能性，这类系统被称为 &lt;strong&gt;Byzantine fault tolerant&lt;/strong&gt;。近些年来，该观点在区块链及加密货币中逐渐流行起来：即使系统的一些参与者试图欺骗或破坏系统，系统也能提供明确的保证。&lt;/p&gt;

&lt;h2 id=&quot;2-3-describing-nodes-and-network-behavior&quot;&gt;2-3 Describing nodes and network behavior&lt;/h2&gt;

&lt;p&gt;当设计分布式算法时，system model 是对可能发生故障的假设。上文描述了两种 system model：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Two generals problem: a model of networks&lt;/li&gt;
  &lt;li&gt;Byzantine generals problem: a model of node behavior&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 system model 中传递的消息被捕获可能因为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Network behavior：消息丢失等&lt;/li&gt;
  &lt;li&gt;Node behavior：节点崩溃等&lt;/li&gt;
  &lt;li&gt;Timing behavior：延迟等&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-3-1-network-behavior&quot;&gt;2-3-1 Network behavior&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;不存在完全可靠的网络&lt;/strong&gt;：即使是在精心设计且有冗余连接的网络中。
大多数分布式算法都假设网络在一对节点间提供双向通信服务，被称为&lt;strong&gt;点对点通信（point-to-point）&lt;/strong&gt;或者&lt;strong&gt;单播通信（unicast）&lt;/strong&gt;。在真实的网络中有时确实提供&lt;strong&gt;广播（broadcast）&lt;/strong&gt;或&lt;strong&gt;多播（multicast）&lt;/strong&gt;通信（&lt;em&gt;一个数据包同时发送给多个接收者&lt;/em&gt;）。不过，通常来说，假设只存在单播（unicast）是一个比较好的网络模型。&lt;/p&gt;

&lt;p&gt;接下来我们可以假设网络的可靠性，大部分算法假设如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Reliable&lt;/strong&gt; (perfect) links
只有在消息被发送时，才会收到消息。不过，消息可能会被重排序。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fair-loss&lt;/strong&gt; links
消息可能会丢失，重复或重排序。如果继续重试，消息最终会被成功发送。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Arbitrary&lt;/strong&gt; links (active adversary)
存在 malicious 节点干扰信息传递（窃听，篡改，丢弃，伪造，重放等）。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;网络分区&lt;/strong&gt;（network partition）：一些连接长时间丢弃或延迟所有消息&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;我们可以将上述某些类型的网络转换为其他类型，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如当前网络类型为 Fair-loss link，通过持续发送丢失的消息直到被成功接收，及在接收方过滤重复的消息，可以将 Fair-loss link 类型转换为 Reliable link 类型。&lt;/p&gt;

&lt;p&gt;Fair-loss 类型意味着网络分区（network partition）只会持续一段时间，并不是永久故障；所以消息最终一定会被接收。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不过，网络分区期间发送的消息只能等到故障恢复之后才能被接收，而故障的时间可能比较长&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;之前提到的 TCP 协议在网络数据包层面提供了重试及重复数据过滤的机制，不过 TCP 通常配置了超时时间，在重试了一个确定的时间之后就会放弃重试（一般为 1min）。因此为了应对较长时间的网络分区（network partition），需要在 TCP 之上额外实现一套重试及重复数据过滤机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary 类型是互联网通信的准确模型&lt;/strong&gt;：每当你通过互联网进行通信时（可能是通过咖啡店的 wifi），网络运营商可以任意操作 &amp;amp; 干扰你的网络数据包。操作网络流量的人也被称为 active adversary。不过，通过使用加密技术&lt;strong&gt;&lt;em&gt;几乎（almost）&lt;/em&gt;&lt;/strong&gt;可以将 Arbitrary 类型的网络转换为 Fair-loss 类型。&lt;strong&gt;TLS&lt;/strong&gt;（Transport Layer Security）协议可以防止 active adversary 进行窃听，篡改，伪造，重放流量等操作。不过，TLS 唯一不能阻止 active adversary 进行丢弃（dropping/blocking）网络包操作。所以，只有在 active adversary 永远不会进行 block 操作时，才能将 Arbitrary 类型的网络转换为 Fair-loss 类型。&lt;/p&gt;

&lt;p&gt;Reliable 类型的网络看起来并不是不可实现：&lt;strong&gt;一般来说，只要我们在网络分区期间等待一段时间后进行重试，所有消息都能被成功接收&lt;/strong&gt;。不过，我们也需要考虑消息发送者在重试期间崩溃（crash）的情况，这种情况下消息会永远丢失（permanently lost）。&lt;/p&gt;

&lt;h3 id=&quot;2-3-2-node-behavior&quot;&gt;2-3-2 Node behavior&lt;/h3&gt;

&lt;p&gt;假设每个节点运行模型的算法都为下面的一种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Crash-stop&lt;/strong&gt; (fail-stop)
如果节点在任意时刻崩溃，则出现故障。崩溃之后，节点永久性地停止运行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Crash-recovery&lt;/strong&gt; (fail-recovery)
节点可能在任意时刻崩溃，导致内存数据会丢失，不过持久化到磁盘上的数据并不会丢失。节点可能在一段时间后重新恢复运行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Byzantine&lt;/strong&gt; (fail-arbitrary)
如果节点偏离运行的算法，则出现故障（A node is faulty if it deviates from the algorithm）。故障节点的表现可能有：崩溃或者一些恶意行为。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;不存在故障的节点被称为正常节点（A node that is not faulty is called “correct”）。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在 &lt;strong&gt;Crash-stop&lt;/strong&gt; 模型中，我们假设节点崩溃之后，永远不会恢复。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于无法恢复的硬件故障来说，这是一种合理的模型（reasonable）&lt;/li&gt;
  &lt;li&gt;对于软件崩溃，Crash-stop 模型看起来不太符合，因为在节点重启之后，将会恢复。尽管如此，一些算法为了简化问题，仍然将其看作 Crash-stop 模型。在这种情况下，崩溃后恢复的节点被认为是重新加入系统中的新节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 &lt;strong&gt;Crash-recovery&lt;/strong&gt; 模型中，允许节点崩溃后重启并恢复运行。当节点崩溃重启时，假设内存中的数据全部丢失，但是持久化到磁盘上的数据都会被保存下来。&lt;strong&gt;&lt;em&gt;该模型对节点崩溃后恢复所需要的时间并没有设定，因此崩溃后的节点可能永远都不会恢复&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Byzantine&lt;/strong&gt; 模型是最常见的节点行为模型：正如拜占庭将军问题中的描述，&lt;em&gt;故障节点也许不仅仅是崩溃，也可能以任何方式偏离指定的算法，包括一些恶意行为&lt;/em&gt;。节点服务实现中的错误（bug）也可以归类为拜占庭故障。不过，如果所有节点运行同样的软件，那么这些节点就会有同样的 bug。因此，任何基于拜占庭故障节点数少于 1/3 的算法都无法容忍此类 bug。因此，当涉及到偏离指定算法时，我们通常称为拜占庭问题，而不是 bug。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原则上，我们可以尝试使用同一算法的几种不同的实现，不过这并不是比较实际的选择。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在 network behavior 的介绍中，通过使用特定的协议可以将一种网络模型转换为另一种。不过，在 node behavior 中并不适用；比如，为 Crash-recovery 模型设计的算法与 Byzantine 模型有很大不同。&lt;/p&gt;

&lt;h3 id=&quot;2-3-3-synchrony-timing-assumptions&quot;&gt;2-3-3 Synchrony (timing) assumptions&lt;/h3&gt;

&lt;p&gt;对于同步（计时）模型的假设如下所示：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Synchronous&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;消息延迟不会大于已知的上限。节点以已知的速度执行算法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Partially synchronous&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;系统在某些有限（但未知）的时间内是异步的，否则是同步的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Asynchronous&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;消息延迟时间不定。节点可以在任意时间暂停执行。完全没有时间保证。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;上述术语在其他上下文中具有不同的含义。如，在 RPC &amp;amp; IO 操作中，synchronous 表示调用方会被阻塞直到操作完成；asynchronous 表示调用方在发出请求后继续执行，而不需要等待操作完成&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Synchronous&lt;/strong&gt; 模型是指&lt;strong&gt;&lt;em&gt;通过网络发送的消息延迟永远不会大于已知的最大延迟，并且节点总是以可预测的速度执行&lt;/em&gt;&lt;/strong&gt;。Synchronous 系统的假设会使得分布式计算问题变得简单，并且由于大部分时间（most of time）节点及网络都表现良好，因此该假设大部分情况下没有问题。&lt;/p&gt;

&lt;p&gt;然而，大部分时间表现良好并不代表一直如此。如果系统在某段时间内违反了有界延迟与有界执行速度的假设，那么为 Synchronous 模型设计的算法就会崩溃。在实际系统中，网络延迟与执行速度由于各种原因会导致差异比较大。&lt;/p&gt;

&lt;p&gt;另一个极端的假设是 &lt;strong&gt;Asynchronous&lt;/strong&gt; 模型（不对延迟做任何假设）：&lt;strong&gt;&lt;em&gt;消息在网络中的延迟可以是任意的，不同节点执行速度的差异是任意的&lt;/em&gt;&lt;/strong&gt;（如允许某个节点在其他节点正常运行的时候暂停执行）。为 Asynchronous 模型设计的算法通常非常健壮，因为可以不受任何临时网络中断或延迟峰值的影响。&lt;/p&gt;

&lt;p&gt;不过，Asynchronous 模型并不能解决分布式系统中的全部问题，因此我们使用 &lt;strong&gt;Partially Synchronous&lt;/strong&gt; 模型作为折中方案。在 Partially Synchronous 模型中，假设&lt;strong&gt;&lt;em&gt;大部分情况下（most of time）系统表现良好，表现为 Synchronous；偶尔，可能会切换到 Asynchronous，其中所有定时保证都失效（该情况可能随时发生）&lt;/em&gt;&lt;/strong&gt;。Partially Synchronous 模型对许多实际的系统都比较适用，不过想要正确使用需要多加小心。&lt;/p&gt;

&lt;h3 id=&quot;2-3-4-violations-of-synchrony-in-practice&quot;&gt;2-3-4 Violations of synchrony in practice&lt;/h3&gt;

&lt;p&gt;网络通常具有可预测的延迟，不过偶尔延迟会增大，从而导致系统违背 Synchronous 模型，具体原因可能有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;消息丢失或者重试，导致延迟大幅增加&lt;/li&gt;
  &lt;li&gt;在网络分区修复前，消息不能被成功传递&lt;/li&gt;
  &lt;li&gt;如果网络阻塞导致数据包在交换机缓冲区中排队等待，也会增加延迟&lt;/li&gt;
  &lt;li&gt;网络重新配置同样会增大延迟，即使是在同一个数据中心，也可能会导致延迟超过一分钟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同样，节点通常也会以恒定的速度执行程序代码，偶尔也会因为意外导致程序暂停执行（pause）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;操作系统调度问题：正在运行的进程可能会被抢占，导致暂停，尤其当机器处于高负载的情况下&lt;/li&gt;
  &lt;li&gt;对于一些实现内存管理的语言，比如 Java，当垃圾回收器在运行的时候，需要时不时地暂停正在运行的线程（垃圾回收可能会长达几分钟）&lt;/li&gt;
  &lt;li&gt;缺页中断也会导致线程挂起，尤其是没有多少空闲内存时&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要注意，此处说的 pause 与前文对节点行为描述中的 crash 并不相同。暂停中的进程通常没有意识到自己处于暂停状态，虽然其他节点在没有收到暂停节点的响应时，可能认为其已经崩溃。但是，过了一段时间，暂停的进程会重新恢复运行。另外，重启崩溃的节点需要由程序显示处理，因为其内存状态已经完全丢失，需要从磁盘中重新加载持久化数据；而暂停的进程内存数据并没有丢失&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;综合以上多种原因，如果假设一个系统为 Synchronous 模型，可能并不安全。&lt;strong&gt;因此，大多数分布式系统需要被设计成 Partially synchronous 或者 Asynchronous。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-3-5-system-models-summary&quot;&gt;2-3-5 System models summary&lt;/h3&gt;

&lt;p&gt;在设计分布式系统模型时，需要对网络，节点行为，同步类型等进行合理假设，这些是分布式算法的基础：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Network: reliable, fair-loss, or arbitrary&lt;/li&gt;
  &lt;li&gt;Node: crash-stop, crash-recovery, or Byzantine&lt;/li&gt;
  &lt;li&gt;Timing: synchronous, partially synchronous, or asynchronous&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-4-fault-tolerance-and-high-availability&quot;&gt;2-4 Fault tolerance and high availability&lt;/h2&gt;

&lt;p&gt;对于网站来说，服务的可用性（availability）可能是最重要的。比如，在线商店想要在任何时候都能售卖产品：网站的中断意味着失去赚钱的机会。对于其他服务来说，可能与客户签订了协议保证服务的可用性，如果服务不可用会对其声誉造成损失。&lt;/p&gt;

&lt;p&gt;服务的可用性通常&lt;strong&gt;根据其在特定时间内正确响应请求的能力来衡量&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如何定义服务是可用的还是不可用：如果网站加载网页需要 5s，那么我们认为服务是可用的吗？如果耗时 30s, 1h 呢？服务的可用性预期被定义为 &lt;strong&gt;Service-Level Objective (SLO)：需要在指定超时时间内返回正确响应的请求的百分比&lt;/strong&gt;（由特定客户端在特定时间内测量）。Service-Level Aggrement (SLA) 是规定了一些 SLO 的协议，以及没有满足 SLO 的后果。&lt;/p&gt;

&lt;h3 id=&quot;2-4-1-fault-tolerance&quot;&gt;2-4-1 Fault tolerance&lt;/h3&gt;

&lt;p&gt;故障（faults，如节点崩溃或者网络中断）是影响可用性的常见原因。为了提高可用性，我们可以减少故障发生的频率，或者将系统设计成&lt;strong&gt;&lt;em&gt;即使某些组件故障，仍能继续提供服务&lt;/em&gt;&lt;/strong&gt;，这种方式被称为&lt;strong&gt;容错（fault tolerance）&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过购买高质量的硬件，同时引入冗余，可以降低故障发生的频率，但是这种方式并不能完全杜绝故障发生；因此，需要系统都采用容错的方式提高可用性。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;容错总是相对于最大容忍的故障节点数量&lt;/strong&gt;：一些分布式算法能够在崩溃节点数量少于一半的情况下继续运行，但是如果超过一半节点故障，则无法运行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;想要容忍没有限制的节点故障没有意义：当所有节点崩溃且无法恢复时，没有算法能够继续运行。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在某些系统中，单个组件的故障可能会导致整个系统的中断，这种组件被称为&lt;strong&gt;单点故障（single point of failure, SPOF）&lt;/strong&gt;。&lt;strong&gt;容错系统通常需要避免单点故障&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在这里，我们需要区分下 Fault &amp;amp; Failure:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Fault: 系统的某一部分不可用，可能是由于节点故障或者网络故障导致&lt;/li&gt;
  &lt;li&gt;Failure: 整个系统不可用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-4-2-failure-detection&quot;&gt;2-4-2 Failure detection&lt;/h3&gt;

&lt;p&gt;为了实现容错，首先需要能够检测故障，由故障检测器（failure detector）完成。故障检测器通常能够检测到节点崩溃故障，但是对于拜占庭（Byzantine）故障并不能总是检测出：虽然在某些 Byzantine 行为下会留下一些证据用于识别 malicious 节点。&lt;/p&gt;

&lt;p&gt;大部分情况下，故障检测器周期性地向其他节点发送消息，如果在预期时间内没有收到响应则将节点标记为崩溃（crash）。理想情况下，我们期望只有在节点真正崩溃时才会检测超时（这种检测器被称为 perfect failure detector）。但是，两将军问题表明这并不是一种完全准确的检测方式，没有收到响应可能是因为消息丢失（message loss）或者延迟（delay）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;基于超时检测的 perfect failure detector 只存在于具有可靠网络连接的同步（synchronous）且崩溃中止（crash-stop）系统中&lt;/em&gt;&lt;/strong&gt;。在异步（asynchronous）系统中，超时并不具备实际意义，因此也就不存在基于超时的故障。在部分同步（partially synchronous）系统中，不存在 perfect failure detector；但是存在另一种有用的故障检测器：eventually perfect failure detector。&lt;/p&gt;

&lt;p&gt;对于 eventually perfect failure detector，表现有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;可能暂时（temporarily）将一个正常（correct）的节点标记为崩溃（crash）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;可能暂时（temporarily）将一个崩溃（crash）的节点标记为正常（correct）&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;但是最终（eventually），当且仅当节点已经崩溃了，才会将其标记为崩溃&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;从中我们可以看到，检测并不是瞬时的，可能会存在错误的检测结果&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;后面将继续介绍如何使用这种故障检测器来设计容错机制，以及如何从节点崩溃中自动恢复。&lt;/p&gt;

&lt;h1 id=&quot;3-time-clocks-and-ordering-of-events&quot;&gt;3-Time, clocks, and ordering of events&lt;/h1&gt;

&lt;p&gt;在分布式系统中，我们经常需要测量时间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;基于超时的故障检测器需要计算时间用于决定检测是否超时&lt;/li&gt;
  &lt;li&gt;操作系统广泛依赖计时器用于任务调度，CPU 使用情况追踪等&lt;/li&gt;
  &lt;li&gt;应用程序通常会记录事件发生的事件，我们可以根据这些时间重建不同节点上同时发生的事件；或者判断不同节点不同事件发生的顺序&lt;/li&gt;
  &lt;li&gt;在日志文件和数据库中，也需要记录事件发生的时间&lt;/li&gt;
  &lt;li&gt;内存中的缓存需要有一定的实效性（过期失效）&lt;/li&gt;
  &lt;li&gt;应用性能测量&lt;/li&gt;
  &lt;li&gt;….&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们将区分两种类型的时钟：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;物理时钟（physical clocks）&lt;/strong&gt;：计算真实时间（count number of seconds elapsed）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;逻辑时钟（logical clocks）&lt;/strong&gt;：计算事件（count events, e.g. messages sent）&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：数字时钟（振荡器）不等于分布式系统中的时钟（时间戳）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-1-physical-clocks&quot;&gt;3-1 Physical clocks&lt;/h2&gt;

&lt;p&gt;物理时钟以秒为单位测量时间。物理时钟包括基于钟摆或者类似钟摆机制的模拟或机械时钟（analogue/mechanical clocks），也包括基于石英晶体震荡的数字时钟（digital clocks）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;物理时钟有时候也被称为挂在墙上的时钟（wall clock）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;石英时钟出现在大部分手表，计算机，手机等物品中。石英时钟比较便宜，但是并不完全精确（accurate）。由于制造的缺陷，某些时钟可能要比其他的运行快/慢，并且石英震动频率受温度影响。&lt;/p&gt;

&lt;p&gt;时钟震荡频率的快慢被称为&lt;strong&gt;漂移（drift）&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;漂移以 parts per million (ppm)为单位进行测量&lt;/li&gt;
  &lt;li&gt;1 ppm = 1 microsecond/second = 86 ms/day = 32 s/year&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;大部分计算机的时钟精度大约在 50ppm 以内&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-1-1-utc--tai&quot;&gt;3-1-1 UTC &amp;amp; TAI&lt;/h3&gt;

&lt;p&gt;如果需要提高时钟的精度，可以使用&lt;strong&gt;原子时钟（atomic clocks）&lt;/strong&gt;。原子时钟基于某些原子的量子力学特性，如铯或铷（&lt;strong&gt;International Atomic Time，TAI&lt;/strong&gt;，国际原子时间）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;事实上，国际单位制（SI）中一秒的时间单位被定义为铯-133 原子特定共振频率的9,192,631,770个周期。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;另一种获取高精度时钟的方法是依靠 GPS 等卫星定位系统。通过将 GPS 接收器连接到计算机，可以获得精确到几分之一微秒的时钟。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在数据中心，电磁干扰通常太大，无法获得良好的信号，因此 GPS 接收器需要在数据中心大楼的屋顶上安装天线&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;有一点需要指出，地球自转时间并不是严格的 24h，而且收到地震，潮汐等影响，自转周期并不固定。因此，基于量子力学的时钟（原子时钟）与基于天文学的时钟（日出日落）并不完全匹配。通过引入 &lt;strong&gt;UTC（Coordinated Universal Time）&lt;/strong&gt;解决这个问题：&lt;em&gt;UTC 基于原子时间，但包括考虑到地球自转变化的校正&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;日常生活中，我们使用的本地时区为 UTC 的偏移（offset）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;UTC 与 TAI 之间的区别是，UTC 包括了闰秒（leap seconds）。由于闰秒的存在，导致 1 小时不总是 3600 秒，1 天也不总是 86400 秒。在 UTC 时间范围内，1 天可能是 86399 秒，86400 秒或者 86401 秒。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;闰秒发生在每年 6 月 30 日与 12 月 31 日的 23:59:59 UTC&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;3-1-2-how-computers-represent-timestamps&quot;&gt;3-1-2 How computers represent timestamps&lt;/h3&gt;

&lt;p&gt;在计算机中，&lt;strong&gt;timestamp 用于表示一个特定的时间点&lt;/strong&gt;。有两种常见的表示 timestamp 的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Unix time&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ISO 8601&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于 Unix time，0 对应于 1970 年 1 月 1 日（UTC or GMT），也被称为 epoch。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 Java 中，存在一些微小的变化：Java 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.currentTimeMillis()&lt;/code&gt; 表示毫秒而不是秒&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Unix timestamp 直接忽略了闰秒&lt;/em&gt;，假装其不存在；并且这种方式也被 Posix 标准采用。对于那些只需要粗略计时的软件来说，这种方式是可行的，因为几秒的差异并不显著。&lt;/p&gt;

&lt;p&gt;然而，操作系统和分布式系统经常确实会依赖高精度 timestamp 来准确测量时间，其中 1s 的差异非常明显。这种情况下，如果直接忽略闰秒可能会存在风险。假如 Java 程序在闰秒内连续两次调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.currentTimeMillis()&lt;/code&gt; ，每次间隔 500ms。这两次调用结果之间的差值不会是 500，可能是 0，也可能是负数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2012 年 6 月 30 日闰秒处理不当是导致当天许多服务同时失败的原因&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如今，许多软件都额外处理闰秒，比较实用的方法是：当闰秒发生时，并不是在 23:59:59 与 00:00:00 之间插入 1s，而是将这 1s 分散到其他时间段内，可能会加快/减慢时钟的速度。这种fang 被称为抹平（smearing）闰秒。&lt;/p&gt;

&lt;h2 id=&quot;3-2-clock-synchronisation-and-monotonic-clocks&quot;&gt;3-2 Clock synchronisation and monotonic clocks&lt;/h2&gt;

&lt;h3 id=&quot;3-2-1-clock-synchronisation&quot;&gt;3-2-1 Clock synchronisation&lt;/h3&gt;

&lt;p&gt;由于原子时钟（atomic clocks）过于昂贵且笨重，无法内置于计算机与手机上，因此一般使用石英时钟（quartz clocks）。然而，由于时钟漂移（drift），时钟误差会越来越大，因此需要&lt;strong&gt;&lt;em&gt;定期从具有更准确时间源的服务器（原子钟或 GPS 接收器）获取当前时间&lt;/em&gt;&lt;/strong&gt;。一般是通过 Network Time Protocol (NTP) 进行同步。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所有主流操作系统都内置了NTP客户端&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;时钟服务器的层次结构排列为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第 0 层：原子时钟或者 GPS 接收器&lt;/li&gt;
  &lt;li&gt;第 1 层：直接与第 0 层设备同步&lt;/li&gt;
  &lt;li&gt;第 2 层：与第 2 层同步的服务器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于网络延迟的不确定性，通过网络进行时钟同步也存在一定问题。&lt;strong&gt;&lt;em&gt;为了减少偶然性带来的影响，NTP 采集了几个时间测量样本，并通过统计过滤器来消除异常值&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;与多个时钟服务器进行通信，丢弃异常值，并对剩下的取平均值&lt;/li&gt;
  &lt;li&gt;对同一台服务器进行多次请求，减少网络延迟导致的随机异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;时钟倾斜（skew）&lt;/strong&gt;指的是同一个时间点，两个不同时钟的差异。如何通过 NTP 评估客户端与时钟服务器之间的时钟倾斜？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;NTP Client 向 NTP Server 发送请求，请求消息中携带 Client 的当前 timestamp t1（Client 的时钟）&lt;/li&gt;
  &lt;li&gt;NTP Server 收到 Client 的请求，在处理请求前，先计算当前 timestamp t2（Server 时钟）&lt;/li&gt;
  &lt;li&gt;NTP Server 处理完请求并发送响应。响应消息中携带：t1（请求发送 timestamp），t2（请求接收 timestamp），t3（响应 timestamp，Server 时钟）&lt;/li&gt;
  &lt;li&gt;NTP Client 收到响应时，记录当前 timestamp t4（Client 时钟）&lt;/li&gt;
  &lt;li&gt;从 Client 的视角看，请求发出到接收的往返时间为 t4-t1，Server 处理请求的时间为 t3-t2，那么网络传输的时间为 (t4-t1)-(t3-t2)，单向网络延迟约 t = ((t4-t1)-(t3-t2))/2&lt;/li&gt;
  &lt;li&gt;当响应到达 Client 时，我们可以估计 NTP Server 在此刻的时间约为 t3+t&lt;/li&gt;
  &lt;li&gt;此时我们可以预估 Client 与 Server 的时钟偏差（skew）为：t4-(t3+t)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述对时钟偏差的预估依赖网络的往返延迟大致相同的假设。该假设可能是正确的，但是如果网络中的排队时间是网络延迟的重要因素，那么请求与响应的延迟会有很大不同（如某个节点的网络连接负载较重，而其他节点比较空闲）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;然而，大部分网络并无法提供往返延迟基本一致的保证&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;一旦 NTP Client 预估了与 NTP Server 之间的时钟偏差，接下来需要调整自身的时钟与 Server 保持一致。时钟同步的方法取决于时钟倾斜的范围（amount of the skew）t:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;|t|&amp;lt;125ms ，&lt;strong&gt;slew the clock&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Client 通过稍快或者稍慢的速度（500ppm）运行，在之后的几分钟内（5min）逐渐减小偏差&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;125ms &amp;lt; |t| &amp;lt; 1000s ，&lt;strong&gt;step the clock&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果此时仍然采用 slew 的方式，同步周期将会很长。因此，Client 采用 step 的方式强行将自身时钟与 Server 保持一致。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;会导致时钟突然向前或者向后跳了一段&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;|t| &amp;gt; 1000s，&lt;strong&gt;panic and do nothing&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;当偏移很大的时候（默认不超过 15min），NTP Client 会认为此时出现了异常，从而拒绝调整时钟，由运维人员去调整。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;因此，&lt;strong&gt;&lt;em&gt;时钟并不会一直保持同步&lt;/em&gt;&lt;/strong&gt;，运维人员需要关注时钟偏移的范围&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-2-2-time-of-day-clock-and-monotonic-clock&quot;&gt;3-2-2 Time-of-day clock and Monotonic clock&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;通过 NTP 进行时钟同步可能会导致时钟跳转，因此对那些需要测量经过时间的应用来说有比较大的影响&lt;/em&gt;。下面是 Java 计算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dosomething()&lt;/code&gt; 的耗时，有两种写法：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// bad&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elapsedMillis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// good&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elapsedNanos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这两种写法有什么区别，首先需要清楚 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentTimeMillis()&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nanoTime()&lt;/code&gt; 的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;currentTimeMillis()&lt;/code&gt; 表示是真实的时间（real-time），表示从 1970.01.01 开始经历的时间。当 NTP 跳转时，该时间也跳转。如果用其计算经过的时间，结果可能比实际值大或者小，甚至为负数。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nanoTime()&lt;/code&gt; 是一个单调时钟（monotonic clock），并不会受 NTP 跳转影响，只会向前计算（NTP slew 只会影响其向前的速度）。因此，用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nanoTime()&lt;/code&gt; 计算经过的时间相对更准确。不过，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nanoTime()&lt;/code&gt; 只是表示从某个任意时间点经过的时间（如计算机启动的时间点）；不同计算机的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nanoTime()&lt;/code&gt; 比较并不具备实际意义。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;大多数操作系统及编程语言都提供了这两种时间&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;3-3-causality-and-happens-before&quot;&gt;3-3 Causality and happens-before&lt;/h2&gt;

&lt;p&gt;在分布式系统中存在与时间密切相关的问题：&lt;strong&gt;事件排序&lt;/strong&gt;（order events）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，A 发送消息 m1 给 B,C 两个用户；B 在收到 m1 之后，回复 m2 给 A,C 。然而，即使网络是可靠的（reliable），也是会存在重排序的情况。所以可能存在 C 在收到 m1 前就收到了 m2 的现象。从 C 的视角看，结果令人疑惑：先收到了回复，再收到了问题，好像 B 能够未卜先知。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在现实生活中，这种现象不会发生，所以我们也希望在计算机系统中也不发生&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;进一步讨论这个问题，假设 m1 是在数据库中创建对象的指令，m2 是更新该对象的指令。如果节点在处理 m1 操作前就处理了 m2，那么结果就是首先更新一个不存在的对象，之后再创建一个随后不会被更新的对象。在数据库操作中，只有 m1 发生在 m2 之前才会有意义。&lt;/p&gt;

&lt;h3 id=&quot;3-3-1-physical-timestamps-inconsistent-with-causality&quot;&gt;3-3-1 Physical timestamps inconsistent with causality&lt;/h3&gt;

&lt;p&gt;那么对 C 来说，如何确定消息的正确顺序？&lt;/p&gt;

&lt;p&gt;由于&lt;em&gt;单调时钟（monotonic clock）&lt;/em&gt;在不同节点间（A &amp;amp; B）的比较没有实际意义，因此不可采用。&lt;/p&gt;

&lt;p&gt;尝试使用代表&lt;strong&gt;&lt;em&gt;真实时间的物理时钟时间戳&lt;/em&gt;&lt;/strong&gt;：&lt;em&gt;每个消息都附带当前时间戳&lt;/em&gt;。在这种情况下，我们可以合理预估 m2 拥有比 m1 更靠后的时间戳，因为 m2 是对 m1 的响应，所以 m2 一定在 m1 之后发生（happen after）。&lt;/p&gt;

&lt;p&gt;然而在部分同步（partially synchronous）的系统中，这种方式并不可靠。通过 NTP 或者类似协议进行的时钟同步并不能准确判断时钟偏差，尤其是在双向网络延迟不相同的情况下，这种不确定性会加大。因此，我们不能排除下面这种场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A 根据自身时钟将时间戳 t1 附着在消息 m1 上发送&lt;/li&gt;
  &lt;li&gt;B 收到 m1，并根据自身时钟获取当前时间戳 t2。由于 A 的时钟比 B 稍微快一点，导致 t2&amp;lt;t1。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此时，如果按照时间戳进行排序仍然会得到错误的顺序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-3-2-the-happens-before-relation&quot;&gt;3-3-2 The happens-before relation&lt;/h3&gt;

&lt;p&gt;什么是正确的顺序？我们使用 &lt;strong&gt;Happen-before relation&lt;/strong&gt; 来定义正确的顺序。该定义&lt;em&gt;假设每个节点只有一个正在执行的线程，因此对于同一个节点上的两个执行步骤可以明确其先后顺序&lt;/em&gt;。更正式地说，假设&lt;strong&gt;同一个节点上的操作严格全局有序（strict total order）&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于同一个进程的多个线程，可以把每个线程用独立的（separate node）节点表示&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;什么是 Happen-before？当操作 a 与 b 满足以下条件其中一个时，我们可以认为 a Happen-before b，记为 a→b：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;a 与 b 发生在同一个节点，并且 a 的本地执行顺序在 b 之前&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;a 表示发送消息 m，b 表示接收同一个消息 m（假设消息 m 是唯一的）&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;存在操作 c，并且满足 a→c，c→b&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以&lt;strong&gt;把这种顺序扩展到多个节点：定义同一个消息在接收之前被发送（忽略网络延迟）&lt;/strong&gt;。为了方便起见，假设每条消息都是唯一的，当接收到一条消息，总是可以确定其发送方及发送时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Happen-before 关系是偏序关系（partial order），&lt;/strong&gt;因此会出现 a→b 与 b→a 都不满足的情况，此时 a 与 b 称为 &lt;strong&gt;Concurrent&lt;/strong&gt;，记为 a || b。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;此处的 concurrent 并不是指 a &amp;amp; b 同时发生，而是指 &lt;strong&gt;&lt;em&gt;a &amp;amp; b 是独立的，不存在依赖关系&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;下面是 Happen-before 的示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-3-3-causality&quot;&gt;3-3-3 Causality&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Happen-before 是分布式系统中判断因果关系（causality）的一种方式&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因果关系（causality）&lt;/strong&gt;关注信息是否可以从一个事件传递到另一个事件，从而导致一个事件影响到另一个事件。在上面消息传递的例子中，m2 是对 m1 的回复，因此 m1 影响了 m2。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个事件是否真的影响了另一个事件是一个哲学问题；对我们来说 m2 发送前已经收到了 m1 才是我们关心的&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;因果关系的概念借鉴了物理学。人们普遍认为，信息不可能比光速传播得更快。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果有两个事件 a &amp;amp; b 在空间中相距足够远，但在时间上相近。那么事件 a 不可能在事件 b 之前到达 b 的位置，反之亦然。因此，事件 a &amp;amp; b 肯定不存在因果关系（causally unrelated）&lt;/li&gt;
  &lt;li&gt;如果事件 c 在空间上与 a 相近，并且在 a 发生后的一段时间，那么事件 a 可能会给 c 传递信号，从而影响 c&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分布式系统中的情况与之类似。&lt;/p&gt;

&lt;h1 id=&quot;4-broadcast-protocols-and-logical-time&quot;&gt;4-Broadcast protocols and logical time&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;广播协议（broadcast protocols）&lt;/strong&gt;或者&lt;strong&gt;多播协议（multicast protocols）&lt;/strong&gt;是指将一个消息发送给多个接收者的算法；主要用于构建更上一层的分布式算法。在实践中，有几种不同的广播协议，它们之间最大的区别在于消息发送的顺序（order）。&lt;/p&gt;

&lt;p&gt;正如上文描述的，顺序与时间 &amp;amp; 时钟密切相关。接下来，需要进一步研究时钟如何帮助追踪分布式系统中的顺序。&lt;/p&gt;

&lt;h2 id=&quot;4-1-logical-time&quot;&gt;4-1 Logical time&lt;/h2&gt;

&lt;p&gt;在之前的例子中，我们可以看到&lt;strong&gt;&lt;em&gt;物理时钟时间戳可能与因果关系并不一致（inconsistent with causality）&lt;/em&gt;&lt;/strong&gt;，即使使用类似 NTP 协议进行时钟同步。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;尽管 send(m1) → send(m2)，也可能存在 timestamp(m1) &amp;gt; timestamp(m2)&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;相比之下，逻辑时钟（logical clocks）更注重于分布式系统中的事件顺序。&lt;/p&gt;

&lt;h3 id=&quot;4-1-1-logical-vs-physical-clocks&quot;&gt;4-1-1 Logical vs. physical clocks&lt;/h3&gt;

&lt;p&gt;物理时钟：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算经过的秒数&lt;/li&gt;
  &lt;li&gt;可以用于很多方面，但是&lt;strong&gt;&lt;em&gt;可能会与因果关系不一致&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;逻辑时钟：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算事件发生的次数&lt;/li&gt;
  &lt;li&gt;用于&lt;strong&gt;&lt;em&gt;获取因果依赖关系（capture causal dependencies）：&lt;/em&gt;&lt;/strong&gt;(e1-&amp;gt;e2)=&amp;gt;(T(e1)&amp;lt;T(e2)).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有两种类型的逻辑时钟：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Lamport clocks&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Vector clocks&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-1-2-lamport-clocks&quot;&gt;4-1-2 Lamport clocks&lt;/h3&gt;

&lt;p&gt;Lamport 时间戳本质上是一个整数，用于计算已经发生的事件数量；与物理时钟没有直接关系。在每个节点，由于事件的发生，整数就会增加，相应地 Lamport 也会增加。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该算法的假设适用于 crash-stop 模型（如果 crash-recovery 模型将时间戳持久化存储，则也可以用于该模型中）&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;当消息通过网络发送，发送者就会&lt;strong&gt;&lt;em&gt;将当前的 Lamport 时间戳附在消息上&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当接收者收到消息后，会&lt;strong&gt;&lt;em&gt;将本地的 Lamport 时钟向前移动到消息携带的时间戳 + 1&lt;/em&gt;&lt;/strong&gt;。如果接收者的时钟已经领先于消息携带的时间戳，那么它只会在本地时间戳上递增。&lt;/p&gt;

&lt;p&gt;Lamport clocks 算法流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：每个节点初始化自己的本地时钟 t&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事件发生在本地&lt;/strong&gt;：本地时钟 t 递增：t = t + 1&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;发送消息&lt;/strong&gt;：本地时钟递增后 t = t + 1，将时间戳附在消息上发送（t, m）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;收到消息&lt;/strong&gt;：收到（t’, m）消息后，更新本地时间戳 t = max(t, t’) + 1，并将消息传递给程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Lamport 时间戳存在这样的性质：如果事件 a happen-before b，那么 b 的时间戳总是比 a 大；也就是说&lt;strong&gt;时间戳与因果关系保持一致&lt;/strong&gt;。然而，反过来并不这样：如果 b 的时间戳比 a 大，我们可以知道 b 不会在 a 之前发生，但是我们不知道是 a → b 还是 a || b。同时，&lt;strong&gt;两个不同的事件可能拥有相同的时间戳&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A 节点上的第三个事件与 B 节点上的第一个事件拥有相同时间戳&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果我们期望每个事件的都对应一个唯一时间戳，那么&lt;strong&gt;每个时间戳都可以使用发生该事件的节点的名称或标识符进行扩展&lt;/strong&gt;（如上图）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单节点范围内，每个事件被赋予唯一的时间戳&lt;/li&gt;
  &lt;li&gt;如果每个节点都有唯一的标识，那么时间戳与节点标识的组合为全局唯一（across all nodes）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上文介绍说 Happen-before 关系是偏序关系（partial order），通过&lt;strong&gt;使用 Lamport 时间戳我们可以把这种偏序关系扩展为全序关系（total order）：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对（timestamp, node name）对进行字典排序：首先比较 timestamp 的大小，如果 timestamp 相同则比较 node name，从而可以对任意两个 (timestamp, node) 对进行比较，确定全序关系&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们使用 -&amp;gt; 表示 Happen-before 关系，对于&lt;strong&gt;全序关系使用 ≺ 表示&lt;/strong&gt;。&lt;strong&gt;全序关系使得所有事件具有线性关系（linear order）&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对任意两个不同的事件 a , b，要么存在 a ≺ b，要么存在 b ≺ a.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;全序&lt;strong&gt;关系也是因果关系，换句话说，≺ 是偏序关系-&amp;gt; 的线性扩展（linear extension）&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不管什么时候，只要存在 a-&amp;gt;b，那么就可以得出 a ≺ b；对于 a ≺ b，我们不一定能得出 a-&amp;gt;b.&lt;/li&gt;
  &lt;li&gt;然而，如果 a||b ，我们可以得出 a ≺ b 或者 b ≺ a，这两个事件的顺序由具体的算法确定.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-1-3-vector-clocks&quot;&gt;4-1-3 Vector clocks&lt;/h3&gt;

&lt;p&gt;对于给定两个事件的 Lamport 时间戳，通常不能判断这两个事件是并发（concurrent）还是存在 Happen-before 关系。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果 b 的 Lamport 时间戳比 a 大，我们可以知道 b 不会在 a 之前发生，但是我们不知道是 a → b 还是 a || b；给定的两个 Lamport 时间戳虽然可以进行全局比较，但是不一定能够确定事件的先后顺序&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果我们想要检测两个事件是否是并发的，需要使用另一种逻辑时钟：&lt;strong&gt;向量时钟（vector clocks）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;与 Lamport 时间戳只使用一个整数（可能会附带 node name）不同，&lt;strong&gt;向量时钟是一组整数列表，每个整数对应系统中的一个节点&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果节点列表用 &amp;lt;N1,N2,N3…Nn&amp;gt; 表示，那么向量时钟用 &amp;lt;t1,t2,t3…tn&amp;gt; 表示，其中 ti 与 Ni 对应.&lt;/li&gt;
  &lt;li&gt;ti 表示在节点 Ni 上发生的事件数量&lt;/li&gt;
  &lt;li&gt;对于向量时钟 T=&amp;lt;t1,t2,t3…tn&amp;gt;，我们使用 T[i] 表示 ti.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lamport 时钟是标量，向量时钟是矢量；除了这点区别外，向量时钟算法与 Lamport 时钟算法很相似。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个节点初始化向量时钟 T := &amp;lt;0,0,…,0&amp;gt;，向量中的元素与系统节点一一对应&lt;/li&gt;
  &lt;li&gt;当事件发生在节点 Ni 时，该节点将向量时钟的第 i 个元素递增：T[i]=T[i]+1.&lt;/li&gt;
  &lt;li&gt;当通过网络发送消息 m 时，发送者递增自己的向量时钟 T[i]=T[i]+1，同时将当前向量时钟被附着在消息上一起发送： (T,m).&lt;/li&gt;
  &lt;li&gt;当收到消息后，接收者将消息中的向量时钟 (T’,m) 与自己本地的向量时钟 T 比较并合并：T[j] := max(T[j],T′[j]),j={1,2,3…n}，之后递增自己的向量时钟：T[i]=T[i]+1，再将消息 m 传递给程序.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面是向量时钟的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当节点 C 从 B 收到消息 m2 时，会将自己本地的向量时钟中表示节点 A 的元素也更新为 2，因为收到消息这个事件与发生在 A 上的两个事件有间接的因果关系（indirect causal）。因此，&lt;strong&gt;向量时间戳反映出了 Happen-before 关系的传递性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通过向量时钟可以定义偏序顺序：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果向量 T 的每个元素都等于另一个向量 T’ 中的对应元素，则 T=T’.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;T =T′ iff T[i] = T′[i] for all i∈{1,…,n}&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果向量 T 的每个元素都小于或者等于另一个向量 T’ 中的对应元素，则 T&amp;lt;=T’.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;T ≤T′  iff T[i] ≤ T′[i] for all i∈{1,…,n}&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果向量 T&amp;lt;=T’ 并且它们间至少存在一个元素不同，则 T&amp;lt;T’.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;T &amp;lt;T′ iff T ≤ T′ and T != T′&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果向量 T 的某个元素比向量 T’ 对应元素大，而 T’ 的另一个元素比 T 对应元素大，那么这两个向量无法比较：T||T’. 如 T = ⟨2,2,0⟩ , T′ = ⟨0,0,1⟩，其中 T[1] &amp;gt; T′[1] 但是 T[3] &amp;lt; T′[3].&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;T || T′ iff T !≤ T′ and T’ !≤ T&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;向量时间戳展现出的偏序关系与 Happen-before 定义的偏序关系完全对应。因此，&lt;strong&gt;向量时钟算法提供了计算 Happen-before 关系的机制&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-1-4-summary&quot;&gt;4-1-4 Summary&lt;/h3&gt;

&lt;p&gt;对于逻辑时钟，我们讨论了两种关键算法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Lamport 时钟：提供了全序关系（total order）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;向量时钟：计算 Happen-before 的偏序关系&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也有许多其他算法提出：如混合时钟（hybrid clocks）将逻辑时钟与物理时钟的特性结合起来。&lt;/p&gt;

&lt;h2 id=&quot;4-2-delivery-order-in-broadcast-protocols&quot;&gt;4-2 Delivery order in broadcast protocols&lt;/h2&gt;

&lt;p&gt;许多网络提供点对点协议（单播，unicast），其中每个消息都有特定的接收者。我们将要讨论广播协议（broadcast），该协议中每个消息被发送给某个组中的所有节点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;网络组中的成员可能是固定的，也可能允许节点的加入与离开&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;一些局域网在硬件层面提供了多播（multicast）或者广播（broadcast），如 IP 多播，但是在互联网上的通信通常只允许单播。不过，硬件层面的广播通常只能提供 Best-effort：允许消息丢失。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;之前讨论的 Node behavior 与 Synchrony model 可以扩展到广播组中&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果我们想在单播协议上构建广播协议，需要使用广播算法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发送者程序通过单播链路向其他节点发送消息&lt;/li&gt;
  &lt;li&gt;接收者程序通过单播链路接收消息&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;广播算法将消息发送给接收者应用程序&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有几种不同类型的广播协议，这些协议都是可靠的（reliable）：&lt;strong&gt;&lt;em&gt;所有消息最终都会发送给每个无故障节点（network  behavior: reliable），但是没有延迟保证（synchrony model: partially synchronous）&lt;/em&gt;&lt;/strong&gt;。这些广播协议在消息传递到每个节点的顺序上有所不同。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息顺序的差异是不同广播算法间重要的区分&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-2-1-fifo-broadcast&quot;&gt;4-2-1 FIFO broadcast&lt;/h3&gt;

&lt;p&gt;定义：&lt;strong&gt;如果消息 m1, m2 由同一个节点广播，并且 broadcast(m1) → broadcast(m2)，那么 m1 一定会在 m2 之前到达&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;FIFO 广播模型是最弱的（weakest），与 FIFO 网络链路密切相关。在该模型中，同一个节点发送的消息按照发送顺序到达；但是不同节点发送的消息可以以任意顺序到达。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;m1 一定会在 m3 之前到达：均由 A 节点发送；m2 相较于 m1, m3，可以在任意时间到达&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;另外，&lt;strong&gt;对于这些广播协议，我们假设一个节点不管什么时候广播消息，同时会将该消息发送给自己&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该特性在全序广播中将会被用到&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-2-2-causal-broadcast&quot;&gt;4-2-2 Causal broadcast&lt;/h3&gt;

&lt;p&gt;FIFO 广播可能会违反因果关系：在上图的示例中，节点 C 在收到 m1 前收到了 m2，即使 B 是在收到 m1 之后再广播 m2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Causal broadcast&lt;/strong&gt; 相对于 FIFO，能够提供更严格的顺序保证：&lt;strong&gt;确保消息按照因果关系到达&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 broadcast(m1) → broadcast(m2)，那么所有节点也必须按照该顺序收到 m1, m2。&lt;/li&gt;
  &lt;li&gt;如果 broadcast(m1) || broadcast(m2)，那么节点可以按照任意顺序接收 m1, m2。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在之前的示例中，如果节点 C 在接收到 m1 之前收到了 m2，那么运行在 C 上的广播算法会 &lt;strong&gt;&lt;em&gt;hold back（保留 or 缓冲）m2，直到接收到 m1&lt;/em&gt;&lt;/strong&gt;，从而确保消息按照因果顺序接收到。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A：broadcast(m1) → broadcast(m3)；B：broadcast(m1) → broadcast(m2)；同时 broadcast(m3) || broadcast(m2)，则节点 C 可以按照 (m1, m2, m3) 的顺序接收，也可以按照 (m1, m3,m2) 的顺序接收，这两个情况都与因果关系保持一致&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;4-2-3-total-order-broadcast&quot;&gt;4-2-3 Total order broadcast&lt;/h3&gt;

&lt;p&gt;Total order broadcast（全序广播）也被称为原子广播（atomic broadcast）。&lt;/p&gt;

&lt;p&gt;FIFO broadcast 与 Causal broadcast 允许不同的节点按照不同的顺序接收消息，与之不同的是，&lt;strong&gt;Total order broadcast 加强了不同节点间的一致性，保证所有节点都按照相同的顺序接收消息&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;接收的顺序没有准确定义，只要所有节点的顺序相同即可&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所有的节点都按照相同的顺序接收消息：(m1, m2, m3)&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所有的节点都按照相同的顺序接收消息：(m1, m3, m2)&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;只要所有节点能够对消息顺序达成一致，上述两种顺序都是有效的。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;与 Causal 广播一样，节点可能需要 hold back 消息直到该消息之前的消息都被接收&lt;/em&gt;。例如：节点 C 可能会按照任意的顺序收到 m2, m3，如果算法已经确定 m3 应该在 m2 之前收到，但是节点先收到了 m2，那么就会 hold back m2 直到收到 m3。&lt;/p&gt;

&lt;p&gt;另外，在 FIFO broadcast 与 Causal broadcast 中，当一个节点广播了一条消息，那么它可以将该消息立即发送给自己，并不需要与其他节点通信。但是&lt;strong&gt;&lt;em&gt;在 Total broadcast 中需要与其他节点通信以确定发送顺序&lt;/em&gt;&lt;/strong&gt;：在第一个场景中，由于 m2 需要在 m3 前收到，因此节点 A 需要从 B 收到 m2 之后才能将 m3 发送给自己。&lt;/p&gt;

&lt;h3 id=&quot;4-2-4-fifo-total-order-broadcast&quot;&gt;4-2-4 FIFO-total order broadcast&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;FIFO-total order broadcast 与 total order broadcast 类似，但是额外再加上 FIFO 的要求：同一个节点广播的消息需要按照发送的顺序送达&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在 Total order broadcast 中的两个例子实际上满足 FIFO-total order broadcast 要求，因为 m1 总是在 m3 前被接收。&lt;/p&gt;

&lt;h3 id=&quot;4-2-5-summary&quot;&gt;4-2-5 Summary&lt;/h3&gt;

&lt;p&gt;上述不同广播协议之间的层次关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;FIFO-total order broadcast 协议要比 Causal broadcast 更严格：每个有效的 FIFO-total order broadcast 协议都是有效的 Causal broadcast 协议（反过来并不是）。&lt;/p&gt;

&lt;h2 id=&quot;4-3-broadcast-algorithms&quot;&gt;4-3 Broadcast algorithms&lt;/h2&gt;

&lt;p&gt;接下来将会讨论实现广播协议的算法。整体来说，涉及两个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;确保每个节点都能收到每条消息&lt;/strong&gt;：通过重发丢失的消息，使得广播协议变得可靠（reliable）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;将消息按序送达&lt;/strong&gt;：在可靠的广播协议之上使得消息有序送达&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-3-1-deliver-message-reliably&quot;&gt;4-3-1 Deliver message reliably&lt;/h3&gt;

&lt;p&gt;广播算法实现的一次尝试：当一个节点想要广播一条消息时，它会通过可靠的网络连接（消息丢失后会重试）将消息分别发送给其他节点。然而，&lt;em&gt;在消息重发之前，发送者节点可能已经崩溃&lt;/em&gt;。这种情况下，会存在节点永远不会收到消息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/25.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了提高可用性，可以寻求其他节点的帮助：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当一个节点第一次收到某条特定的消息时，会将其转发到其他节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种方式被称为：&lt;strong&gt;&lt;em&gt;Eager reliable broadcast&lt;/em&gt;&lt;/strong&gt;。该算法能够保证，&lt;strong&gt;当一些节点崩溃后，剩余的所有非故障（non-faulty）节点都能收到每条消息&lt;/strong&gt;。但是一个明显的缺点是，该算法效率很低：在没有故障节点的情况下，每条消息都会被发送 O(n^2) 次（假设系统中有 n 个节点），同时每个节点对于每条消息会收到 n-1  次；&lt;strong&gt;导&lt;em&gt;致大量的网络冗余&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/26.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该算法发展了许多变体，从容错，所有节点收到消息的时间，使用的网络带宽等多个角度进行优化。其中一个比较常见的&lt;strong&gt;广播算法族是 Gossip protocols，也被称为 Epidemic protocols&lt;/strong&gt;。基本流程为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当准备广播消息时，节点将该消息发送给&lt;strong&gt;&lt;em&gt;随机选择的，少量，固定数目&lt;/em&gt;&lt;/strong&gt;的节点.&lt;/li&gt;
  &lt;li&gt;当节点首次收到该消息时，会将该消息转发给&lt;strong&gt;&lt;em&gt;固定数目的，随机选择&lt;/em&gt;&lt;/strong&gt;的节点.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;这种传播方式类似于流言，传染病在人群中传播的方式&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Gossip 协议并不严格保证每条消息都会被所有节点收到&lt;/strong&gt;：在每次随机选择时，可能有些节点总是被遗漏。然而，如果算法参数比较合理，那么这种可能性就会很低。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Gossip 协议保证广播效率的同时，兼顾了消息丢失，节点崩溃的情况&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/27.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过 Eager reliable broadcast 或 Gossip 协议，我们已经保证广播的可靠性（reliable），之后需要讨论在其之上实现具体的广播算法：FIFO, Causal, Total order broadcast。&lt;/p&gt;

&lt;h3 id=&quot;4-3-2-fifo-broadcast-algorithm&quot;&gt;4-3-2 FIFO broadcast algorithm&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/28.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个节点都的本地状态信息由以下组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;sendSeq&lt;/strong&gt;：计算当前节点广播消息的数量（每个消息都会标识该序列号）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;delivered&lt;/strong&gt;：当前节点从其他节点收到消息数目的向量：&amp;lt;0, 0, . . . , 0&amp;gt;，每个元素对应一个节点&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;buffer&lt;/strong&gt;：缓冲区，用于 hold back 接收的消息，直到该消息可以传递给应用进程（如等到之前的消息全部接收到）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每个被广播的消息有以下标识：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;i&lt;/strong&gt;：发送者节点 Ni 的标识&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sendSeq&lt;/strong&gt;：当前消息的序列号（由当前节点计算已经发送的消息数量）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FIFO 算法&lt;em&gt;检查每个发送方消息的序列号，如果与预期序列号匹配，则增加预期编号，确保来自特定发送方的消息有序传递给应用进程&lt;/em&gt;。&lt;/p&gt;

&lt;h3 id=&quot;4-3-3-causal-broadcast-algorithm&quot;&gt;4-3-3 Causal broadcast algorithm&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Causal 广播算法与 FIFO 算法类似，不过在每条广播消息上并不携带消息的序列号，而是&lt;strong&gt;&lt;em&gt;序列号向量&lt;/em&gt;&lt;/strong&gt;。该算法有时也被称为向量时钟（vector clocks）算法，不过它们之间有很大不同：向量时钟算法中的向量元素计算发生在每个节点上的事件数量，而该算法中向量元素由于计算从不同节点收到的消息数量。&lt;/p&gt;

&lt;p&gt;每个节点的本地状态仍然由：sendSeq, delivered, buffer 组成。&lt;/p&gt;

&lt;p&gt;当节点广播消息时，附带的信息有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;i：发送者节点 Ni 的标识&lt;/li&gt;
  &lt;li&gt;deps：表明该消息因果依赖性的向量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;deps 向量以 delivered 进行初始化：delivered 是当前节点从其他节点收到消息数目的向量；deps &lt;strong&gt;&lt;em&gt;在本地发送的所有消息必须按因果顺序出现在该广播消息之前。&lt;/em&gt;&lt;/strong&gt;初始化之后，将 deps 向量中对应该节点的元素更新为 sendSeq：确保此节点广播的每条消息都因果依赖同一节点广播的上一条消息。&lt;/p&gt;

&lt;h3 id=&quot;4-3-4-fifo-total-order-broadcast-algorithms&quot;&gt;4-3-4 (FIFO-)Total order broadcast algorithms&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Total order (FIFO-total order) 广播算法相对更复杂。如上图所示有两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;指定主节点的方式&lt;/li&gt;
  &lt;li&gt;通过使用 Lamport 时间戳的无主节点方式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不过这两种方法都不支持容错：单节点崩溃会导致其他节点都不能发送消息。&lt;/p&gt;

&lt;h1 id=&quot;5-replication&quot;&gt;5-Replication&lt;/h1&gt;

&lt;p&gt;Replication 是指在多个节点上维护相同数据的副本，每个节点被称为&lt;strong&gt;副本（replica）&lt;/strong&gt;。&lt;strong&gt;复制&lt;/strong&gt;是许多分布式数据库，文件系统及其他存储系统中的标准功能。同时，也&lt;strong&gt;是实现容错（fault tolerance）的主要机制&lt;/strong&gt;之一：如果一个副本故障，可以继续访问其他副本。&lt;/p&gt;

&lt;h2 id=&quot;5-1-manipulating-remote-state&quot;&gt;5-1 Manipulating remote state&lt;/h2&gt;

&lt;p&gt;如果数据没有发生变化，那么复制操作比较容易，因为只需要一次数据复制就行。因此，复制的主要问题是管理变更数据。在进一步深入复制流程的细节前，先探讨下在分布式系统中，数据是如何变更的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;考虑这样一个场景，假设用户对某条推文感兴趣，因此点了 “like” 操作；twitter 会把喜欢这条推文的人存储在数据库中，以便展示给当前用户及其他用户。&lt;/p&gt;

&lt;p&gt;我们把存储在数据库中的数据看作&lt;strong&gt;状态（state）&lt;/strong&gt;。由于网络问题，更新数据库的请求可能会丢失，或者更新成功后的确认操作也会丢失。通常我们通过重试请求来提高可靠性，但是如果重试操作处理不当，该请求可能会被多次处理，导致数据库中的状态异常。&lt;/p&gt;

&lt;p&gt;防止更新多次生效的一种方法是&lt;strong&gt;对请求去重（deduplicate requests）&lt;/strong&gt;。然而在 crash-recovery 系统模型中，需要将请求（或者请求的元数据）存储在稳定的存储介质中，这样即使在节点崩溃后也能检测出重复的请求。&lt;/p&gt;

&lt;p&gt;请求去重的一种替代方式是&lt;strong&gt;请求幂等（idempotent）&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;递增操作不是幂等的，但是向集合中添加一个元素是幂等的。因此，如果需要计数器操作，最好维护元素集合，并从集合导出计数值。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;幂等更新操作可以安全重试：执行多次与执行一次的效果一样&lt;/strong&gt;。幂等使得更新操作具有 &lt;strong&gt;exactly once&lt;/strong&gt; 语义：更新操作可能执行多次，但是影响与正好执行一次是相同的。&lt;/p&gt;

&lt;p&gt;对于重试操作的语义有以下几种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;At most once&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;发送请求，但是并不会重试，更新也会并不会执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;At least once&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;收到确认前一直重试，可能会多次更新&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Exactly once&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;重试 + 幂等；或者去重&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在分布式系统中，幂等是非常有用的特性：RPC 操作不可避免地要进行重试。&lt;/p&gt;

&lt;p&gt;然而，当多个更新操作在处理时，幂等具有明显的局限性。下面是几个示例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;添加后删除&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/33.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;client 1 将一个 userId A 添加到用户集合中，数据库添加成功但是响应丢失。&lt;/li&gt;
      &lt;li&gt;client 2 从数据库中读取该集合，其中包含了 client 1 刚刚添加的 userId A。&lt;/li&gt;
      &lt;li&gt;client 2 请求数据库将 userId A 从集合中移除，数据库操作成功并返回。&lt;/li&gt;
      &lt;li&gt;此时，client 1 并不知道 client 2 的删除操作，仍在重试刚才的添加请求；该重试操作重新将 userId A 添加到集合中。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;最后的结果不符合预期，因为 client 2 是在 client 1 更新之后的操作，符合因果关系；我们希望 userId A 最后被移除。在这种情况下，&lt;em&gt;幂等操作并不能实现安全重试&lt;/em&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一种形式的添加后删除&lt;/p&gt;

    &lt;p&gt;假设有两个数据副本 A，B。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/34.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;client 将数据 x 添加到两个副本中，添加成功&lt;/li&gt;
      &lt;li&gt;client 之后尝试将 x 从这两个副本中删除，但是对副本 B 的删除请求丢失了&lt;/li&gt;
      &lt;li&gt;client 在重试前崩溃了&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;client 尝试将数据 x 添加到两个副本中，但是向副本 A 添加数据的请求丢失了&lt;/li&gt;
      &lt;li&gt;client 在重试前崩溃了&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;虽然这两个场景的预期效果不一样：第一个场景中，想要从两个副本中删除数据；第二个场景中想要向两个副本中添加数据。但是最后结果都一样：x 存在副本 B 中，但是在副本 A 中不存在。&lt;/p&gt;

    &lt;p&gt;当两个部分协调其不一致的状态时，我们希望它们最后都处于 client 期望的状态。然而，如果副本间无法区分这两种情况，是无法做到的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决这种问题，我们需要做两件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;将逻辑时间戳附在每次的更新操作上，并将时间戳作为数据更新的一部分存储在数据库中&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;当想要将数据记录从数据库中删除时，我们并不真正删除该数据，而是看作一种特殊类型的更新操作，将其标记为删除，称为&lt;strong&gt;墓碑（tombstone）&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/36.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在许多分布式系统中，&lt;strong&gt;副本运行一个协议来检测 &amp;amp; 协调副本间的差异（被称为反熵，anti-entropy），最终所有副本都能保证数据的一致性&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由于墓碑，可以区分已经删除的记录和还未创建的记录&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于时间戳，可以区分哪个版本的记录更新，哪个版本更旧；从而可以丢弃旧的版本，保留新的版本&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/37.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在第一种添加后删除的场景中，重试操作的时间戳与之前请求的时间戳相同，因此重试操作并不会覆盖 client 2 的更新：因为 client 2 的操作时间戳更大，与之前的请求具有因果性&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;在每次更新操作中附带时间戳的方式对处理并发更新也很有用&lt;/em&gt;&lt;/strong&gt;。如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/38.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;client 1 想要将 x 的值更新为 v1（携带时间戳 t1）&lt;/li&gt;
  &lt;li&gt;与此同时，client 2 想要将 x 的值更新为 v2（携带时间戳 t2）&lt;/li&gt;
  &lt;li&gt;副本 A 首先收到 v2 ，之后收到 v1；副本 B 收到的顺序相反&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了确保两个副本最终状态相同，我们并&lt;em&gt;不依赖它们收到更新请求的顺序，而是根据时间戳的顺序&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;不过，该方法的具体细节依赖采用时间戳的类型。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Last writer wins (LWW)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果使用的是 Lamport 时间戳（能够提供全序关系），并发更新操作就可以进行排序（具体取决于时间戳比较的方式）。这种情况下，我们可以使用 &lt;strong&gt;&lt;em&gt;Last writer wins (LWW) 语义：拥有最大时间戳的更新操作有效，其他对同一 key 并发更新且时间戳较小的操作被丢弃&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;该方法执行比较简单，但是如果&lt;strong&gt;&lt;em&gt;多个更新操作并发执行，会导致数据丢失&lt;/em&gt;&lt;/strong&gt;。不过，这一点取决于具体的应用程序：对有些系统来说，丢弃并发更新是允许的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Multi-value register&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;当不能丢弃并发更新时，我们需要能够&lt;strong&gt;&lt;em&gt;检测并发更新是在什么时候发生的&lt;/em&gt;&lt;/strong&gt;，此时可以使用矢量时钟。矢量时钟具有偏序关系（帮助判断 Happen-before  关系），可以帮助我们判断新值是否应该覆盖旧值（当旧值 Happen-before 新值时可以覆盖）。同时，当多个更新操作并发时，我们可以保留所有并发更新的值。应用程序可以之后将冲突的值合并成一个值。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这些并发写入的值被称为 &lt;strong&gt;&lt;em&gt;conflicts&lt;/em&gt;&lt;/strong&gt; 或者 &lt;strong&gt;&lt;em&gt;siblings&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;/blockquote&gt;

    &lt;p&gt;向量时钟的一个缺点是成本较高：每个 client 是向量时钟的一个元素：&amp;lt;n1,n2,n3..ni&amp;gt;，&lt;strong&gt;&lt;em&gt;如果一个系统中有很多 client，那么向量时钟就会变得很长&lt;/em&gt;&lt;/strong&gt;，可能要比数据本身所占的空间要大。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Dynamo 系统使用的是这种方式，不过对向量时钟进行了优化，确保不会太长。也存在其他的优化方式。&lt;/p&gt;

    &lt;/blockquote&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/39.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;5-2-quorums&quot;&gt;5-2 Quorums&lt;/h2&gt;

&lt;p&gt;正如之前所说，复制可以提高系统的&lt;strong&gt;&lt;em&gt;可靠性（reliability）：当一个副本不可用时，剩下的副本可以继续处理请求&lt;/em&gt;&lt;/strong&gt;。导致副本不可用的原因有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点故障：崩溃或者硬件故障&lt;/li&gt;
  &lt;li&gt;网络分区：无法通过网络访问节点&lt;/li&gt;
  &lt;li&gt;有计划地维护：重启节点或进行服务升级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过，如何执行复制操作对系统可靠性有很大影响。&lt;em&gt;如果没有容错机制，那么拥有多个副本可能使得系统可靠性更差（worse）&lt;/em&gt;：部分越多，任意副本在任意时间出现故障的可能性越大。如果系统在一些副本故障的情况下仍能继续工作，那么可靠性提高：&lt;em&gt;所有副本同时出现故障的概率远远低于单个副本出现故障的概率&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;在继续讨论如何在复制中实现容错前，先看下一个示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有两个副本 A，B，对于 x 的值都初始化为 v0（关联时间戳为 t0）&lt;/li&gt;
  &lt;li&gt;client 尝试将 x 的值更新为 v1（时间戳 t1）；更新操作在副本 B 上操作成功，但是由于副本 A 暂时不可用，导致更新失败&lt;/li&gt;
  &lt;li&gt;之后，client 尝试读取其写入的值；读取操作在副本 A 上成功，但是在副本 B 上失败&lt;/li&gt;
  &lt;li&gt;结果，返回值并不是 client 之前的写入值 v1，而是初始值 v0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述场景是不符合预期的，因为从 client 的视角来看它写入的值似乎已经丢失了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设你在社交网络上刚刚发布一条动态，之后刷新页面，但是并没有看到刚刚的发布&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;为了解决这类问题，许多系统需要支持&lt;strong&gt;写后读一致性（Read-after- write consistency），也被称为 Read-your-writes consistency&lt;/strong&gt;。这样能够取保，&lt;em&gt;client 更新值之后，同一个 client 能够读取刚刚写入的值&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;严格来说，写后读一致性并不能确保 client 读取其刚刚写入的值，因为其他 client 可能同时并发覆盖了该值。因此，&lt;strong&gt;&lt;em&gt;写后读一致性能够保证读取最后写入的值或者之后的值&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;在上面示例中，我们可以通过&lt;em&gt;确保始终写入两个副本或者从两个副本中读&lt;/em&gt;来实现写后读一致性。但是，这意味着&lt;em&gt;读/写操作并不具备容错性&lt;/em&gt;：如果一个副本不可用，那么需要两个副本都响应的读取/写入操作就无法完成。&lt;/p&gt;

&lt;p&gt;我们可以通过使用三个副本来解决这个问题：把每个读写请求发送给全部三个副本，只要收到的响应数 ≥2，就可以认为请求成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/41.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;更新请求在副本 B，C 上执行成功；读取请求在副本 A，B 上执行成功&lt;/li&gt;
  &lt;li&gt;读写请求在 2/3 节点上执行成功；因此可以保证&lt;em&gt;读取的响应至少有一个来自最新写入的副本&lt;/em&gt;（副本 B）；通过比较响应的时间戳就可以判断最新数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在该示例中，响应写请求的副本集合 {B, C} 称为 &lt;strong&gt;&lt;em&gt;write quorum&lt;/em&gt;&lt;/strong&gt;；响应读请求的副本集合 {A, B} 被称为 &lt;strong&gt;&lt;em&gt;read quorum&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quorum 是请求响应的最小节点集合&lt;/strong&gt;。为了确保写后读一致性，write quorum 与 read quorum 必须存在非空交集。换句话说，read quorum 中至少包含一个已经确认写入的节点。&lt;/p&gt;

&lt;p&gt;在分布式系统中，通常选择 &lt;strong&gt;Majority quorum：严格包含一半以上节点的集合&lt;/strong&gt;。假设系统中有 {A, B, C} 节点集合，那么 majority quorum 为 {A, B}，{A, C}，{B, C}。一般来说，&lt;em&gt;对于拥有奇数节点的系统，(n+1)/2 的数目集合即为 majority quorum；对于拥有偶数节点的系统，n/2+1 的数目集合即为 majority quorum&lt;/em&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;majority quorum 的特性为：任何两个 majority quorum 至少存在一个共同节点&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;除了 majority quorum，其他形式的 quorum 也是可能的。&lt;/p&gt;

&lt;h3 id=&quot;5-2-1-read-and-write-quorum&quot;&gt;5-2-1 Read and write quorum&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;write quorum&lt;/strong&gt;：写入操作需要确认的副本数。&lt;strong&gt;read quorum&lt;/strong&gt;：读取操作需要确认的副本数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果 write quorum 为 w，read quorum 为 r，并且 r + w &amp;gt; n，那么读取操作能够获取到最新写入的值：读写 quorum 至少存在一个共同节点&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于 write quorum 为 w 的系统，可以容忍最多 n-w 个副本不可用；对于 read quorum为 r 的系统，可以最多容忍 n-r 个副本不可用&lt;/strong&gt;。对于 majority quorum 系统，3 个副本可以容忍 1 个不可用；5 个副本可以容忍 2 个不可用，以此类推。&lt;/p&gt;

&lt;h3 id=&quot;5-2-2-read-repair&quot;&gt;5-2-2 Read repair&lt;/h3&gt;

&lt;p&gt;在这种 quorum 机制的复制系统中，任意时刻都可能存在部分副本缺少更新。在上面的例子中，副本 A 没有将 x 更新为 v1。为了使副本间保持一致，可以使用之前讨论的反熵机制（anti-entropy）。&lt;/p&gt;

&lt;p&gt;另一种方式是 Client 帮助传播更新。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/42.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;client 从副本 B 读取到 (t1, v1)；从副本 A 中读取到 (t0, v0)；副本 C 未响应&lt;/li&gt;
  &lt;li&gt;由于 client 知道 (t1, v1) 为最新值，且需要传播到副本 A，所以可以向 A 发送更新请求：因为这不是新的更新操作而是之前更新的重试&lt;/li&gt;
  &lt;li&gt;client 也许会将更新请求发送给 C，即使其不知道 C 是否需要再次更新：如果 C 已经执行过这次更新，也仅仅是浪费一小部分带宽&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述的流程被称为&lt;strong&gt;读修复（read repair）&lt;/strong&gt;。client 可以对任意读请求进行读修复操作，而不管之前更新操作是否是当前 client 执行的。&lt;/p&gt;

&lt;h3 id=&quot;5-2-3-summary&quot;&gt;5-2-3 Summary&lt;/h3&gt;

&lt;p&gt;使用 quorum 复制模型的数据库通常被称为Dynamo风格，以 Amazon Dynamo 数据库命名。&lt;/p&gt;

&lt;h2 id=&quot;5-3-replication-using-broadcast&quot;&gt;5-3 Replication using broadcast&lt;/h2&gt;

&lt;p&gt;5.2 节介绍的 &lt;em&gt;quorum 复制方法使用的是 best-effort 广播：client 将每个读写请求广播到所有副本，但是使用的协议并不是可靠的（请求可能会丢失），同时不能提供顺序保证&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;另一种复制方法使用的是 第 4 节介绍的广播协议。首先讨论最可靠的广播协议：&lt;strong&gt;FIFO-total order broadcast&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;使用 FIFO-total order broadcast 比较容易构造一个复制系统，通过&lt;em&gt;将每个更新请求广播到所有副本，副本根据收到的每条消息更新自身状态&lt;/em&gt;。这种方式被称为 &lt;strong&gt;State Machine Replication（SMR）&lt;/strong&gt;：副本充当状态机，消息传递是其输入。&lt;/p&gt;

&lt;p&gt;我们只要求更新逻辑是&lt;strong&gt;稳定的（deterministic）&lt;/strong&gt;：&lt;em&gt;任何两个处于相同状态并拥有相同输入的副本最终一定处于相同的下一个状态&lt;/em&gt;。即使是错误也需要是确定的：如果一个更新操作在一个副本上成功的，但是在另一个副本上失败，那么这两个副本就会变得不一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/43.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;状态机复制的一个优点是：&lt;em&gt;只要执行逻辑是稳定的，那么从一个状态转移到下一个状态的执行逻辑可以是任意复杂度&lt;/em&gt;。例如，可以执行具有任意业务逻辑的数据库事务，该业务逻辑可能依赖广播消息和数据库当前状态。一些分布式数据库以这种方式执行复制，每个副本独立执行相同且稳定的事务代码，被称为&lt;strong&gt;主动复制（active replication）&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;该原理还被用于区块链，加密货币，分布式分类账：区块链中的“区块链”只不过是 FIFO-total order 协议传递的消息序列，每个副本确定性地执行这些块中描述的事务，以确定分类账的状态&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;状态机复制的缺点即为全序广播的限制。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;正如之前讨论 FIFO-total order 广播，当一个节点想要通过全序广播协议广播一条消息时，该节点不能立即将消息发送给自己。因此，当一个副本想要更新自身状态时，不能立即更新；必须经历广播过程，与其他节点协调，并等待其他节点的更新响应&lt;/li&gt;
  &lt;li&gt;同时，状态机复制的容错性取决于底层依赖的全序广播协议的容错性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尽管存在上述限制，基于全序广播的复制仍被广泛使用。&lt;/p&gt;

&lt;h3 id=&quot;5-3-1-database-leader-replica&quot;&gt;5-3-1 Database leader replica&lt;/h3&gt;

&lt;p&gt;之前说过，实现 FIFO-total order 广播协议的一个方法是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;指定一个节点作为 leader&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;通过 leader 路由所有的广播消息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个原理也广泛用于数据库复制。许多数据库系统指定一个副本作为 leader, primary 或者 master，任何对数据库更新的事务都必须在 leader 副本上执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/44.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，&lt;strong&gt;&lt;em&gt;leader 可能并发执行多个事务，不过会按照全局关系提交（commit）这些事务。当事务提交时，leader 副本将事务产生的数据变更广播给所有 follower 副本，之后 follower 副本将这些变更按照提交顺序应用到本地&lt;/em&gt;&lt;/strong&gt;。这种方法被称为 &lt;strong&gt;passive replication 或者 primary-backup replication&lt;/strong&gt;。可以看到这种方式相当于事务提交记录的全序广播。&lt;/p&gt;

&lt;p&gt;除了 FIFO-total order broadcast 协议，其他广播模型也可以用于复制，不过需要更加小心以确保副本间保持一致（仅仅确保更新逻辑是稳定的并不够）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/45.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;6-consensus&quot;&gt;6-Consensus&lt;/h1&gt;

&lt;p&gt;在 5.3 节看到了全序关系广播（total order broadcast）对实现状态机复制非常有用。而其中一种实现全序关系广播的方式是：指定一个节点作为 leader，由 leader 路由所有的消息。leader 只需要通过 FIFO broadcast 进行消息分发，足以确保所有的节点以相同的顺序收到相同的消息序列。&lt;/p&gt;

&lt;p&gt;然而，这种方法最大的问题是，&lt;strong&gt;leader 单点故障&lt;/strong&gt;：如果 leader 不可用，整个系统就会不可用。一种解决方案是进行人工干预：当 leder 不可用时，通知管理员重新配置新的 leader 节点。这个过程被为&lt;strong&gt;故障转移（failover）&lt;/strong&gt;，该方式常用于许多数据库系统中。&lt;/p&gt;

&lt;p&gt;在&lt;em&gt;提前计划 leader 不可用&lt;/em&gt;的情况下，故障转移能够运行良好，如需要重启更新 leader 节点。然而对于&lt;em&gt;突然或意料之外的 leader 不可用的情况（如节点崩溃，硬件故障，网络故障等）&lt;/em&gt;，由于人为介入的速度有限，故障转移会受到影响。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;管理员可能需要好几分钟才能响应，那么在此期间服务是不可用的&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;由此引出了一个新的问题，当旧 leader 不可用的时候，能否自动选择另一个节点作为新 leader？而这就是&lt;strong&gt;共识算法（consensus）&lt;/strong&gt;需要做的。&lt;/p&gt;

&lt;h2 id=&quot;6-1-introduction-to-consensus&quot;&gt;6-1 Introduction to consensus&lt;/h2&gt;

&lt;p&gt;对共识问题的简单描述：几个节点想要对某个值达成一致（aggreement）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个或者多个节点可能会提议（porpose）一个值，共识算法将决定（decide）其中一个值。共识算法保证决定的值是从提议的值中选取，所有节点都决定相同的值（除了故障节点）&lt;/strong&gt;。&lt;strong&gt;并且最终决定的值是不变的（当节点决定了某个值，就不会改变）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;需要说明，&lt;strong&gt;共识（consensus）与全序广播（total order broadcast）是等价的&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了将全序广播转化为共识，想要提议 value 的节点需要将其广播，全序广播传递的第一条消息被认为是决定值&lt;/li&gt;
  &lt;li&gt;为了将共识转化为全序广播，使用共识协议的一个单独实例来决定发送的消息。想要广播消息的节点会在一轮共识中提议该消息。共识算法之后确保所有节点对将要发送的消息序列达成一致&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个最著名的共识算法：&lt;strong&gt;&lt;em&gt;Paxos &amp;amp; Raft&lt;/em&gt;&lt;/strong&gt;。最初的 Paxos 只会对单个值达成共识。&lt;strong&gt;&lt;em&gt;Multi-Paxos&lt;/em&gt;&lt;/strong&gt; 是 Paxos 的推广，提供 FIFO-total order 广播。Raft 默认提供 FIFO-total order 广播。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/46.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-1-1-consensus-system-models&quot;&gt;6-1-1 Consensus system models&lt;/h3&gt;

&lt;p&gt;共识算法的关键取决于系统模型。Paxos &amp;amp; Raft 假设系统模型为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网络：fair-loss link&lt;/li&gt;
  &lt;li&gt;节点行为：crash-recovery&lt;/li&gt;
  &lt;li&gt;同步模型：partial synchrony&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;对于网络及节点行为的假设可以削弱为为拜占庭模型&lt;/em&gt;，此类算法用于区块链中。然而，&lt;em&gt;拜占庭容错共识算法比非拜占庭算法复杂得多，效率更低&lt;/em&gt;。因此我们更专注于 fair-loss link &amp;amp; crash-recovery 算法，这些算法在实际环境中很有用（比如受信网络的数据中心）。&lt;/p&gt;

&lt;p&gt;另一方面，&lt;em&gt;同步模型的假设不能从 partial synchrony 削弱为 asynchrony&lt;/em&gt;。因为共识算法需要故障检测器（failure detector），而故障检测器需要本地时钟来触发超时。如果没有时钟，那么确定性共识算法可能不会终止。事实上已经证明，&lt;em&gt;任何确定性异步（asynchronous）算法都不能解决保证终止的共识问题&lt;/em&gt;。这一事实被称为 &lt;strong&gt;FLP Result&lt;/strong&gt;，该理论是分布式系统中最重要的理论之一。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is no deterministic consensus algorithm that is guaranteed to terminate in an asynchronous crash-stop system model.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;6-1-2-leader-election&quot;&gt;6-1-2 Leader election&lt;/h3&gt;

&lt;p&gt;大多数共识算法的核心是&lt;strong&gt;选举（elect）流程&lt;/strong&gt;：当现存 leader 节点不可用时，需要选举一个新的 leader。不同共识算法之间的选举细节有所不同，我们将重点讨论 Raft 算法采取的方法（对其他算法也有借鉴意义）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当其他节点检测到 leader 不可用时（通常是因为持续一段时间没有从 leader 收到任何消息），就会发起 leader 选举流程。其中一个节点成为候选人（candicate），并要求其他节点投票是否接受该候选人作为新的 leader。如果法定数目（quorum）的节点投票给该候选人，那么其就会成为新的 leader&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果使用的是 majority quorum，只要大多数节点可用并且相互间可以通信，投票就会成功。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;如果同时存在多个 leader，不同的 leader 做的决定可能不一样，会导致违反全序广播的安全属性（被称为 &lt;strong&gt;split brain&lt;/strong&gt;）。因此，我们期望在进行 leader 选举时，任何时候都只会有一个 leader。在 Raft 算法中，“任何时候”的概念用&lt;strong&gt;任期（term）&lt;/strong&gt;来表述：&lt;strong&gt;&lt;em&gt;term 是一个整数，在开始进行 leader 选举时递增&lt;/em&gt;&lt;/strong&gt;。当 leader 当选时，&lt;strong&gt;投票算法能够保证在特定任期（term）内只会有一个 leader&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;不同任期内有不同的 leader&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/47.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-1-3-can-we-guarantee-there-is-only-one-leader&quot;&gt;6-1-3 Can we guarantee there is only one leader?&lt;/h3&gt;

&lt;p&gt;我们之前讨论过，在 partially synchronous 系统中，基于超时的故障检测器可能不准确：比如由于网络延迟增加，可能会将一个功能正常的节点标识为故障。考虑下面一个场景：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/48.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;node 1 是任期 t 内的 leader；node 1 与 node 2, 3 之间的网络暂时中断&lt;/li&gt;
  &lt;li&gt;node 2, 3 可能会检测到 node 1 故障，并在任期 t+1 内选举新的 leader；虽然 node 1 仍在正常运行&lt;/li&gt;
  &lt;li&gt;node 1 可能并没有注意到网络故障，也不知道已经选举出新 leader&lt;/li&gt;
  &lt;li&gt;因此，有两个节点都认为自己是 leader&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于这个原因，即使一个节点已经当选 leader，也需要谨慎操作。&lt;strong&gt;因为在任何时候，系统内都可能包含另一个更大任期（term）并且其从未感知到的 leader&lt;/strong&gt;。如果任何操作只需要 leader 同意，那么就会变得不安全。相反，&lt;strong&gt;当 leader 想要决定下一条准备发送的消息时，必须再次请求其他节点以得到法定节点数（quorum）的确认&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/49.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在第一次往返中，由于其他两个节点的投票，左侧节点当选为 leader，任期为 t&lt;/li&gt;
  &lt;li&gt;在第二次往返中，leader 提议下一条将要发送的消息，这两个 follower 确认没有比任期 t 更大的 leader 存在&lt;/li&gt;
  &lt;li&gt;最后，leader 发送消息 m 并广播给 followers，以此来保证之间的一致&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果另一个新的 leader 当选，那么旧 leader 就可以通过第二次往返中的确认消息发现新 leader。因为至少有一个节点参与第二轮 leader 选举并投票给新 leader。因此，&lt;strong&gt;即使多个 leader 可能同时存在，旧 leader 将不可能再决定新的消息，从而确保算法的安全性&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;6-2-the-raft-consensus-algorithm&quot;&gt;6-2 The Raft consensus algorithm&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;原文在这部分详细介绍了 Raft 算法的实现，鉴于 Raft 论文更详细，因此不在此处讨论&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h1 id=&quot;7-replica-consistency&quot;&gt;7-Replica consistency&lt;/h1&gt;

&lt;p&gt;在上文我们已经了解到两种复制方式：1. 使用 read/write quorum；2. 通过全序广播实现状态机复制。我们期望副本对相同的数据保持一致，但是没有准确定义 “consistent” 的含义。&lt;/p&gt;

&lt;p&gt;“consistency” 在不同的上下文中具有不同的含义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;在事务中，ACID 中的 C 代表一致性，即状态的属性&lt;/strong&gt;：数据库处于一致或者不一致的状态是指，该状态满足或者违反了应用程序定义的某些不变量。&lt;/li&gt;
  &lt;li&gt;在复制上下文中，我们非正式地使用&lt;strong&gt;一致性来表示副本之间的关系&lt;/strong&gt;：期望一个副本与另一个副本保持一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于对一致性没有一个真正的定义，我们讨论的是各种&lt;strong&gt;一致性模型（consistency models）&lt;/strong&gt;。之前介绍过一个一致性模型，read-after-write consistency：限制了同一节点写入同一项数据后的读取值。&lt;/p&gt;

&lt;h2 id=&quot;7-1-two-phase-commit&quot;&gt;7-1 Two-phase commit&lt;/h2&gt;

&lt;p&gt;首先讨论&lt;strong&gt;分布式事务（distributed transaction）&lt;/strong&gt;的一致性问题：&lt;em&gt;在多个节点上进行读写的事务操作&lt;/em&gt;。分布在这些节点上的数据可以是同一数据集的副本，也可以是一份数据集的不同子集；分布式事务对这两种情况都适用。&lt;/p&gt;

&lt;p&gt;事务的关键性质是原子性（atomicity）。当一个事务跨越多个节点时，我们仍然期望整个事务具有原子性：&lt;em&gt;要么所有节点必须提交事务并持久化更新操作，要么所有节点必须中止事务并丢弃或回滚其更新&lt;/em&gt;。因此，需要不同节点就事务是提交还是放弃达成一致（agreement）。&lt;/p&gt;

&lt;p&gt;这里说的一致与第 6 节介绍共识所说的一致并不相同，尽管两者看起来都是达成某种协议。下图介绍两者的区别：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/50.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;确保多个节点间实现原子提交最常见的算法是 &lt;strong&gt;Two-phase commit (2PC)&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;也有个 three-phase commit protocol&lt;strong&gt;，&lt;/strong&gt;不过其假设了不切实际的同步模型，因此不讨论&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;两阶段提交的流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/51.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当使用两阶段提交时，client 首先在参与事务的每个副本上执行常规的单节点事务，并在这些事务中执行正常的读写操作&lt;/li&gt;
  &lt;li&gt;当 client 准备提交事务时，会向 &lt;strong&gt;transaction coordinator&lt;/strong&gt; 发送提交请求：coordinator 是用于管理两阶段提交的节点（在某些系统中，coordinator 是 client 的一部分）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阶段一：coordinator 首先向参与事务的每个副本发送一个 prepare 消息；每个副本回复其能否提交事务&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;副本此时还没有真正提交事务，但是必须能够保证在阶段二收到 coordinator 的确定之后能够提交事务。这意味着，&lt;strong&gt;&lt;em&gt;副本必须将事务的所有更新写入磁盘，并在回复 prepare 消息之前检查任何完整性约束，同时继续为事务保留任何锁&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;coordinator 收集响应，并决定是否真正提交事务。如果所有节点回复 ok，coordinator 决定提交事务。如果任意节点想要中止事务，或者任意节点在指定超时时间没有回复，那么 coordinator 决定中止事务。&lt;/li&gt;
  &lt;li&gt;阶段二：coordinator 将最终决定发送给所有副本，副本收到后按照指示提交或中止事务。如果决定要提交，每个副本都保证能够提交事务（之前的 prepare 请求奠定了基础）。如果决定中止，副本将回滚事务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两阶段提交的问题是，coordinator 存在单点故障（single point of failure）。coordinator 可以将提交/中止事务的决定写入稳定存储中，以应对节点崩溃。但是可能会有很多事务在 coordintor 节点崩溃时，已经准备好单还没来得及提交或中止。&lt;strong&gt;&lt;em&gt;任何不确定的事务只能等到 coordinator 恢复之后才能结束：参与事务的节点不能单方面决定提交还是中止事务，因为可能会导致与 coordinator &amp;amp; 其他节点间的不一致，从而违反原子性&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过使用共识算法或者全序关系广播可以避免 coordinator 单点故障&lt;/strong&gt;。下图展示了基于 Paxos Commit 实现两阶段提交容错机制：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/61.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/62.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;核心思想是，&lt;strong&gt;每个参与事务的节点通过全序广播传播自己对于提交还是中止事务的投票&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;如果节点 A 怀疑节点 B 已经故障（比如在超时时间内没有收到节点 B 的投票），那么节点 A 可能尝试代表 B 投中止票&lt;/em&gt;。这就引入了一个竞争条件：如果节点 B 因为延迟，可能会在 A 代表自己投票的同时，广播自己的提交票。&lt;/p&gt;

&lt;p&gt;所有投票都会通过全序广播发送给每个节点，每个接受者独立计算投票。&lt;/p&gt;

&lt;h2 id=&quot;7-2-linearizability&quot;&gt;7-2 Linearizability&lt;/h2&gt;

&lt;p&gt;原子提交协议是在出现故障时，保证多个副本间一致性的一种方法：确保所有事务参与者要么提交要么中止事务。然而，当多个节点并发读取 &amp;amp; 修改共享数据时，仅仅靠所有节点采取相同的提交或中止决定是不够的。&lt;/p&gt;

&lt;p&gt;接下来介绍&lt;strong&gt;用于并发系统的一致性模型，被称为 Linearizability&lt;/strong&gt;。当提到 linearizability 时，人们有时会说强一致性（strong consistency），不过强一致性的概念相当模糊，不准确。我们使用 linearizability，因为其具有准确的定义。Linearizability 的非正式定义如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/52.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Linearizability 的概念不仅在分布式系统中有用，并且在单机共享内存并发中也很有用。值得注意的是，在具有多个 CPU 的计算机上，内存访问默认不满足 linearizability。因为每个 CPU 都有自己的缓存，在一个 CPU 上的更新并不会立即反映在另一个 CPU 的缓存中。因此，单机也表现的有点像复制系统。&lt;/p&gt;

&lt;p&gt;需要注意 Linearizability 与 Serializability 并不相同，虽然都意味着按照顺序排列。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Serializability 意味着事务执行与某些串行顺序执行的效果相同，但是并没有定义顺序是什么&lt;/li&gt;
  &lt;li&gt;Linearizability 定义了操作必须返回的值，并且取决于操作的并发性与相对顺序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;系统可以同时提供 Linearizability &amp;amp; Serializability：这两者结合被称为 strict serializability 或 one-copy serializability。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linearizability 的主要目的是保证节点能够获取系统的最新状态&lt;/strong&gt;：不会访问到过期的数据。之前讨论的写后读一致性虽然也能保证读取最新的值，但是该一致性模型的读写操作发生在同一个节点；而 Linearizability 将其推广到不同节点同时进行的操作。&lt;/p&gt;

&lt;h3 id=&quot;7-2-1-abd-making-quorum-readswrites-linearizable&quot;&gt;7-2-1 ABD: Making quorum reads/writes linearizable&lt;/h3&gt;

&lt;p&gt;从 client 的角度来看，每次操作都需要花费一些时间。假设操作的开始时间是应用程序发出请求的时刻，结束时间是操作结果返回到应用程序的时刻。在开始与结束之间，可能会发生各种网络通信操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/55.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们把 client 读写操作的时间段看作一个矩形，在矩形内记录下操作的影响：&lt;em&gt;set(x,v) 表示将 x 更新为 v，get(x) → v 表示读取 x 的返回结果为 v&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;Linearizability 不仅涉及 get 操作与前一个 set 操作的关系，还可以一个 get 操作与其他操作关联。下面是使用 quorum 进行读写操作，但并不满足 Linearizability 的示例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/56.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意不同操作的返回结果&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/55.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;client 2 的操作在 client 3 开始前就完成，但是 client 2 读取到了新值，client 3 却读取到了旧值&lt;/li&gt;
  &lt;li&gt;该结果违反了 Linearizability&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quorum 读写也可以满足 Linearizability。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简单起见，假设 set 操作只能由一个指定节点执行（稍后会移除该假设）&lt;/li&gt;
  &lt;li&gt;set 操作与之前一样：发送给所有副本，并等待 quorum 节点确定&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于 get 操作由额外的要求：client 将读取请求发送给所有副本，并等待回复。如果某些节点的回复比其他节点新，&lt;strong&gt;client 必须将最新值回写给所有未响应最新值的副本：read repair。只有在 client 确认最新值存储在 quorum 副本之后才能结束&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/distributed_system/56.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该方法被称为 &lt;strong&gt;ABD 算法：保证了线性读写，因为每当读写操作完成之后，读写操作的值都存在 quorum 副本中，因此后续的 quorum 读都能保证获取到该值（或者之后的值）&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;7-2-2-linearizable-compare-and-swap-cas&quot;&gt;7-2-2 Linearizable compare-and-swap (CAS)&lt;/h3&gt;

&lt;p&gt;ABD 算法虽然能提供线性化，但是其写操作可能会覆盖数据项的值，不管之前是什么值，被称为 blind write。如果多个 client 并发更新同一个数据，ABD 算法会采用 LWW（last write win）冲突解决策略：只有一个值被保留，其他值被丢弃。&lt;/p&gt;

&lt;p&gt;在一些应用中，我们期望&lt;strong&gt;&lt;em&gt;只有在数据项没有被其他节点并发修改时才进行覆盖操作，可以通过原子的 CAS（compare-and-swap）操作来实现&lt;/em&gt;&lt;/strong&gt;。那么如何在分布式复制系统中实现线性化 CAS 操作？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linearizability 的目的是使系统表现得好像只有一份数据副本，系统操作都是原子的&lt;/strong&gt;。虽然该系统实际上是复制系统。这使得 CAS 成为线性化上下文中应该支持的操作。&lt;/p&gt;

&lt;p&gt;通过使用全序广播，可以实现线性化 &amp;amp; 存在复制系统中的 CAS 操作。只需要广播每一个需要执行的操作，并在消息到达后执行该操作，类似状态复制机。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/57.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;7-3-eventual-consistency&quot;&gt;7-3 Eventual consistency&lt;/h2&gt;

&lt;p&gt;Linearizability 是分布式系统中非常方便的同步模型，因为它保证了系统的表现看起来像是只有一份数据副本，即使实际上是分布式复制系统。使得应用程序可以忽略分布式系统中的复杂性。然而&lt;strong&gt;&lt;em&gt;这种强一致的保证有一定成本，因此 Linearizability 并不一定适合所有程序&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;性能成本&lt;/strong&gt;：ABD 算法与以全序广播为基础的线性 CAS 算法都需要通过网络发送大量消息，并且由于网络延迟需要长时间等待&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可扩展性（scalability）成本&lt;/strong&gt;：在需要 leader 对更新操作进行序列化的算法中，如 Raft，leader 可能会称为瓶颈，限制单位时间内可以执行的操作数量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也许线性化最大的问题是，&lt;strong&gt;每个操作都需要与 quorum 副本进行通信&lt;/strong&gt;。如果一个节点暂时无法与足够多的节点通信，那么其将不能进行任何操作。尽管该节点正常运行，由于网络故障导致其实际不可用。&lt;/p&gt;

&lt;p&gt;考虑这个场景，我们的手机，平板，电脑等都有日历程序，不同设备之间可以相互同步日程。假设当前设备离线后我们像要更新日程，如果该应用程序的复制协议是线性化的，那么我们将无法进行更新操作，因为离线设备无法与 quorum 节点通信。相反，日历程序允许设备离线的情况下更新日程，并在后台稍后将更新同步。&lt;/p&gt;

&lt;p&gt;这种权衡被称为 &lt;strong&gt;CAP 理论（consistency, availability, and partition tolerance）&lt;/strong&gt;。CAP 理论指出，当出现网络分区时，我们需要作出选择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果选择线性一致性，那么一些节点就不能响应请求，因为其不能与 quorum 节点通信&lt;/li&gt;
  &lt;li&gt;也可以选择让副本继续响应请求，即使不能与其他副本进行通信。这种情况下，系统继续可用，但是不能保证线性一致性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有时，CAP 理论被表述为 “从3个中选择2个”，这种表述误导性。&lt;strong&gt;在不存在网络分区的情况下，系统可以同时保证 linearizable &amp;amp; available&lt;/strong&gt;。只有在网络分区存在的情况下才需要强制选择。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/58.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;允许每个副本仅根据其本地状态处理读写操作，而无需等待与其他副本通信的方法被称为乐观复制（optimistic replication）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;针对乐观复制系统提出了各种一致性模型，最著名的是&lt;strong&gt;最终一致性（eventual consistency）&lt;/strong&gt;。最终一致性的定义为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;如果没有对对象进行新的更新操作，最终所有读取操作都将返回上次更新的值&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;该定义比较弱：如果更新从未停止，那么该表述的前提假设就不成立&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;一个稍微强一点的一致性模型被称为 &lt;strong&gt;strong eventual consistency&lt;/strong&gt;。它基于这样一种思想：&lt;em&gt;当两个副本通信时，它们会收敛到同一状态（但是没有保证时间）&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/59.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在最终一致性和强最终一致性中，可能存在不同的节点同时更新同一对象，从而导致冲突。有许多算法被提出用来自动解决该冲突，比如 last-writer wins，或者合并冲突。&lt;/p&gt;

&lt;p&gt;下图是对我们讨论的一致性模型的总结：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/distributed_system/60.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>kkzhang</name></author><category term="system-design" /><summary type="html">翻译自 DDIA 作者 Martin Kleppmann 分布式系统课程：视频; 课件</summary></entry><entry><title type="html">状语从句</title><link href="http://localhost:4000/adverbial-clause.html" rel="alternate" type="text/html" title="状语从句" /><published>2022-03-02T00:00:00+08:00</published><updated>2022-03-02T00:00:00+08:00</updated><id>http://localhost:4000/adverbial-clause</id><content type="html" xml:base="http://localhost:4000/adverbial-clause.html">&lt;h1 id=&quot;1-介绍&quot;&gt;1-介绍&lt;/h1&gt;
&lt;p&gt;状语从句指句子用作状语时, 起副词作用的句子。它可以修饰谓语、非谓语动词、定语、状语或整个句子。根据其作用可分为时间、地点、原因、条件、目的、结果、让步、方式和比较等从句。
状语从句一般由连词(从属连词)引导，也可以由词组引起。从句位于句首或句中时通常用逗号与主句隔开，位于句尾时可以不用逗号隔开。&lt;/p&gt;

&lt;h1 id=&quot;2-地点状语从句&quot;&gt;2-地点状语从句&lt;/h1&gt;
&lt;h2 id=&quot;2-1-介绍&quot;&gt;2-1-介绍&lt;/h2&gt;

&lt;p&gt;地点状语从句表示地点，方位，通常由 where 引导。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He lives there. (there 做地点状语)&lt;/li&gt;
  &lt;li&gt;He lives in Inner Mongolia. (in inner Mongolia 做地点状语)&lt;/li&gt;
  &lt;li&gt;He lives where the climate is mild. (where … 做地点状语从句)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-2-引导词&quot;&gt;2-2-引导词&lt;/h2&gt;

&lt;p&gt;常用引导词 &lt;strong&gt;where&lt;/strong&gt;，特殊引导词 &lt;strong&gt;wherever, anywhere, everywhere.&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;引导词&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;where&lt;/td&gt;
      &lt;td&gt;在……地方&lt;/td&gt;
      &lt;td&gt;通常表示一个确定的地方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wherever&lt;/td&gt;
      &lt;td&gt;无论什么地方&lt;/td&gt;
      &lt;td&gt;表示任何地方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;anywhere&lt;/td&gt;
      &lt;td&gt;任何地方&lt;/td&gt;
      &lt;td&gt;表示任何地方&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;everywhere&lt;/td&gt;
      &lt;td&gt;到处&lt;/td&gt;
      &lt;td&gt;表示任何地方&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;We must camp where we can get water.&lt;/li&gt;
  &lt;li&gt;They will go where they are happy.&lt;/li&gt;
  &lt;li&gt;Wherever there is political upheaval, invariably there are refugees.&lt;/li&gt;
  &lt;li&gt;We have sworn to fight cruelty wherever we find it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-3-地点状语从句与定语从句的区别&quot;&gt;2-3-地点状语从句与定语从句的区别&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;where 引导定语从句时，where 是关系副词，并且 &lt;strong&gt;where 在从句中作地点状语&lt;/strong&gt;，&lt;strong&gt;前面有表示地点的先行词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;The bookshop where I bought this book is not far from here.&lt;/li&gt;
      &lt;li&gt;This is the house where I lived two years ago.&lt;/li&gt;
      &lt;li&gt;We will start at the point where we left off.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;where 引导状语从句时，where 是从属连词。&lt;strong&gt;where 引导的从句修饰主句的谓语动词，并且 where 前面没有表示地点的先行词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Wuhan lies where the Changjiang River and the Hanjiang River meet.&lt;/li&gt;
      &lt;li&gt;Make a mark where you have any doubts or questions.&lt;/li&gt;
      &lt;li&gt;I found my books where I had left them.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有时 where 引导的地点状语从句兼有抽象条件含义，&lt;strong&gt;可放在主句的前面&lt;/strong&gt;，而 where 引导的定语从句则不能
    &lt;ul&gt;
      &lt;li&gt;Where there is a will, there is a way.&lt;/li&gt;
      &lt;li&gt;Where there is water, there is life.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在有些情况下，where 引导的定语从句可转换为 where 引导的地点状语从句
    &lt;ul&gt;
      &lt;li&gt;A tall building was put up at the place where there used to be a desert
  = A tall building was put up where there used to be a desert.&lt;/li&gt;
      &lt;li&gt;Bamboo grows best in places where it is warm and where it rains often.
  = Bamboo grows best where it is warm and where it rains often.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;3-时间状语从句&quot;&gt;3-时间状语从句&lt;/h1&gt;
&lt;h2 id=&quot;3-1-介绍&quot;&gt;3-1-介绍&lt;/h2&gt;

&lt;p&gt;时间状语从句用表示时间的连词连接一个句子作状语。连接时间状语从句的连接词有: &lt;strong&gt;when, before, after, while, as soon as, until, since&lt;/strong&gt; 等。&lt;/p&gt;

&lt;h2 id=&quot;3-2-连接词&quot;&gt;3-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;3-2-1-when&quot;&gt;3-2-1 when&lt;/h3&gt;

&lt;p&gt;when 表示 “当…的时候”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;既可以表示时间段，也可以表示时间点&lt;/li&gt;
  &lt;li&gt;从句既可用延续性动词，也可用非延续性动词&lt;/li&gt;
  &lt;li&gt;从句动作&lt;strong&gt;既可与主句的动作同时发生，又可在主句的动作之前或之后发生&lt;/strong&gt;
例句：
    &lt;ul&gt;
      &lt;li&gt;When I met the Gills, I had been gardening for nearly ten years.&lt;/li&gt;
      &lt;li&gt;I’ll start to think about it when I have to write my report.&lt;/li&gt;
      &lt;li&gt;It was raining when we arrived.&lt;/li&gt;
      &lt;li&gt;When I came home, my wife was cooking dinner.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;如果 when 引导的时间状语从句的主语与主句的主语相同，并且从句的谓语动词为 be 动词时，可以省略主语 &amp;amp; be 动词&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When (you are) in trouble, ask her for help.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果 when 引导的从句的主语与主句的主语相同，可以用 &lt;strong&gt;“when + 分词” 代替状语从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When I came into the room ( When coming into the room), I found him lying there asleep.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-2-2-while&quot;&gt;3-2-2 while&lt;/h3&gt;

&lt;p&gt;while 表示 “当…的时候”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;只能表示一段时间，不能表示时间点&lt;/li&gt;
  &lt;li&gt;从句的谓语动词只能是延续性的&lt;/li&gt;
  &lt;li&gt;从句动作&lt;strong&gt;只能与主句同时发生或者存在&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例句：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Don’t interrupt him while he is thinking.&lt;/li&gt;
  &lt;li&gt;While Jim was mending his bike, Lin Tao came to see him.&lt;/li&gt;
  &lt;li&gt;She got married while working as a waitress.&lt;/li&gt;
  &lt;li&gt;You can’t do your homework while you’re watching TV.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-2-3-as&quot;&gt;3-2-3 as&lt;/h3&gt;

&lt;p&gt;as 表示 “当…时，一边…一边”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;侧重两个动作同时发生&lt;/strong&gt;（包括同一个主语同时进行两个动作）；或者一种动作随着另一个动作的变化而变化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Another policeman has been injured as fighting continued this morning.&lt;/li&gt;
  &lt;li&gt;I slipped on the ice as I ran home.&lt;/li&gt;
  &lt;li&gt;I saw him as he was getting off the bus.&lt;/li&gt;
  &lt;li&gt;As the wind rose, the noise increased.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-条件状语从句&quot;&gt;4-条件状语从句&lt;/h1&gt;
&lt;h2 id=&quot;4-1-介绍&quot;&gt;4-1-介绍&lt;/h2&gt;

&lt;p&gt;条件是指某一事情实现之后（状语从句中的动作），其他事情才会发生（主句中的动作），通常表示“如果”。
&lt;strong&gt;在句子中做条件状语的从句叫做条件状语从句（通常置于句首或句尾）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;引导条件状语从句的常用连词是 if，表示“如果”。其他连词有：&lt;strong&gt;unless&lt;/strong&gt;（除非），&lt;strong&gt;as/so long as&lt;/strong&gt;（只要）， &lt;strong&gt;providing/provided that&lt;/strong&gt;（假如），&lt;strong&gt;supposing that&lt;/strong&gt;, &lt;strong&gt;in case,&lt;/strong&gt; &lt;strong&gt;on condition that&lt;/strong&gt; 等。&lt;/p&gt;

&lt;h2 id=&quot;4-2-连接词&quot;&gt;4-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;4-2-1-if&quot;&gt;4-2-1 if&lt;/h3&gt;

&lt;p&gt;if 引导的条件状语从句分为两类：一种是真实条件句，一种是虚拟条件句。&lt;/p&gt;

&lt;p&gt;if 引导的条件状语从句表示在某种条件下，某事发生的可能性大。&lt;/p&gt;

&lt;p&gt;例句：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If you ask him, he will help you.&lt;/li&gt;
  &lt;li&gt;If you fail in the exam, you will let him down.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;if 引导的条件状语从句既可以放在主句之前，也可以放在主句之后。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If it rains, we will stop playing. = We will stop playing if it rains.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如果主句是将来时，从句要用一般现在时代替一般将来时&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If he runs, he will get there in time.&lt;/li&gt;
  &lt;li&gt;The cat will scratch you if you if you pull her tail.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-2-unless&quot;&gt;4-2-2 unless&lt;/h3&gt;

&lt;p&gt;unless 表示“除非，若不，除非在……的时候”，等同于 if … not。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You will fail to arrive there in time unless you start earlier.&lt;/li&gt;
  &lt;li&gt;Unless it rains, the game will be played.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-3-as-long-as--so-long-as&quot;&gt;4-2-3 as long as &amp;amp; so long as&lt;/h3&gt;

&lt;p&gt;as/so long as 表示“只要…”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;As long as my heart still beats, I will go on working for the people.&lt;/li&gt;
  &lt;li&gt;As long as the green hills are there, one need not worry about firewood.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-4-in-case&quot;&gt;4-2-4 in case&lt;/h3&gt;

&lt;p&gt;in case 表示“如果，万一”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In case I forget, please remind me about it.&lt;/li&gt;
  &lt;li&gt;Dad brought a notebook along to the beach, in case he was seized by sudden inspiration.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-5-on-condition-that&quot;&gt;4-2-5 on condition that&lt;/h3&gt;

&lt;p&gt;on condition (that) 表示“在…条件下”，引导的条件是&lt;strong&gt;主句发生的前提条件或者唯一条件&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I can tell you the truth on condition that you promise to keep a secret.&lt;/li&gt;
  &lt;li&gt;You can go swimming on condition (that) you don’t go too far from the river bank.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-6-supposing&quot;&gt;4-2-6 supposing&lt;/h3&gt;

&lt;p&gt;supposing 表示“如果，假设”，引导的条件状语从句表示一种假设的条件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Supposing it rains, shall we continue the sports meeting?&lt;/li&gt;
  &lt;li&gt;Supposing anything should go wrong, what would you do then?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-2-7-provided-that&quot;&gt;4-2-7 provided that&lt;/h3&gt;

&lt;p&gt;provided (that) 表示“假如，除非，以…为条件”，引导的从句表示一种假设条件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He will sign the contract provided we offer more favorable terms.&lt;/li&gt;
  &lt;li&gt;He won’t be against us in the meeting provided that we ask for his advice in advance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5-原因状语从句&quot;&gt;5-原因状语从句&lt;/h1&gt;
&lt;h2 id=&quot;5-1-介绍&quot;&gt;5-1-介绍&lt;/h2&gt;

&lt;p&gt;原因状语从句用来解释某件事发生的原因，最常用的从属连词为 &lt;strong&gt;because&lt;/strong&gt;，强调原因。&lt;/p&gt;

&lt;p&gt;除此之外，还有其他从属连词：&lt;strong&gt;as, since, for, now (that), when, seeing (that), considering (that), given (that), in that, for the reason that&lt;/strong&gt; 等。&lt;/p&gt;

&lt;h2 id=&quot;5-2-连接词&quot;&gt;5-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;5-2-1-because&quot;&gt;5-2-1 because&lt;/h3&gt;

&lt;p&gt;because 引导的原因状语从句一般放在主句后面。当从句放在主句前面时，需要用逗号隔开；而从句在后面时，可用或者不用逗号分隔。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We didn’t go for an outing last Saturday, &lt;strong&gt;&lt;em&gt;because&lt;/em&gt;&lt;/strong&gt; it was raining hard the whole day.&lt;/li&gt;
  &lt;li&gt;We didn’t go for an outing last Saturday &lt;strong&gt;&lt;em&gt;because&lt;/em&gt;&lt;/strong&gt; it was raining hard the whole day.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Because&lt;/em&gt;&lt;/strong&gt; it was raining hard the whole day, we didn’t go for an outing last Saturday.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;because 的&lt;strong&gt;语气一般比较强&lt;/strong&gt;，常用来回答 why 引导的疑问句。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;Why didn’t you come to my birthday party last night? - Because my sister was ill. I had to take care of her the whole night.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;because 不能与 so 连用&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;because of 也表示原因，为介词短语，后跟名词，代词，动名词及其短语。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He can’t go to school &lt;strong&gt;&lt;em&gt;because of&lt;/em&gt;&lt;/strong&gt; his illness.&lt;/li&gt;
  &lt;li&gt;He can’t go to school &lt;strong&gt;&lt;em&gt;because&lt;/em&gt;&lt;/strong&gt; he is ill.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;not because&lt;/strong&gt; 结构中的否定词有时用来否定主句，有时用来否定从句，容易引起歧义。如果想明否定主句，最好在 because 从句前用逗号隔开。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I didn’t go there yesterday, because I was afraid.（因为害怕，所以没去）&lt;/li&gt;
  &lt;li&gt;I went there yesterday, not because I was afraid.（去那里，并不是因为害怕）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-2-since&quot;&gt;5-2-2 since&lt;/h3&gt;

&lt;p&gt;since 可以理解为“既然”，用来表示双方已知的，显然的理由；相当于 now that，不过更为正式；语气比 because 弱，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;since 引导的原因状语从句常放在主句之前&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Since&lt;/em&gt;&lt;/strong&gt; you are free today, can you help me with the housework?&lt;/li&gt;
  &lt;li&gt;Now that you are grown up, you should rely on yourself.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;since 除了引导原因状语从句，还可以在后面接时间或者过去发生的事情，表示“自从…以来”。此时，&lt;strong&gt;从句常用一般过去时，主句常用完成时&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I have lived here since 2015.&lt;/li&gt;
  &lt;li&gt;She has learned English since she was two years old.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-3-as&quot;&gt;5-2-3 as&lt;/h3&gt;

&lt;p&gt;as 引导原因状语从句时，表示“附带说明的，双方已知的原因”，语气比 since 弱。位置比较灵活，但是常放在主句之前。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;As the wage of the job was low, there were few applicants for it.&lt;/li&gt;
  &lt;li&gt;As you are tired, you had better take a rest.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;除了引导原因状语从句，as 也可以用来引导时间状语从句与方式状语从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A sudden chill of horror sweeps over her as she feels the drip of saliva upon her hand.（时间状语从句）&lt;/li&gt;
  &lt;li&gt;She did it as I had told her to.（方式状语从句）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-4-for&quot;&gt;5-2-4 for&lt;/h3&gt;

&lt;p&gt;for 表示原因，但是并&lt;strong&gt;不构成主句行为发生的直接原因&lt;/strong&gt;，只是提供一些辅助性的补充说明。&lt;/p&gt;

&lt;p&gt;for 引导并列句，且只能放在主句之后并用逗号隔开。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It must have rained last night, for the street is wet all over.（主句与从句不构成直接因果关系）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-2-5-其他连接词&quot;&gt;5-2-5 其他连接词&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;She is much more mobile &lt;strong&gt;&lt;em&gt;now that&lt;/em&gt;&lt;/strong&gt; she has a car.（既然）&lt;/li&gt;
  &lt;li&gt;I won’t tell you &lt;strong&gt;&lt;em&gt;when&lt;/em&gt;&lt;/strong&gt; you won’t listen.（既然）&lt;/li&gt;
  &lt;li&gt;He looks young &lt;strong&gt;&lt;em&gt;considering&lt;/em&gt;&lt;/strong&gt; his age.（考虑到）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Given that&lt;/em&gt;&lt;/strong&gt; he was still a boy, I forgave him.（考虑到）&lt;/li&gt;
  &lt;li&gt;We aren’t going &lt;strong&gt;&lt;em&gt;for the simple reason that&lt;/em&gt;&lt;/strong&gt; we can’t afford it.（因为）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-目的状语从句&quot;&gt;6-目的状语从句&lt;/h1&gt;
&lt;h2 id=&quot;6-1-介绍&quot;&gt;6-1-介绍&lt;/h2&gt;

&lt;p&gt;目的状语从句：在句子中充当目的状语的从句，主要用来补充说明主句中&lt;strong&gt;谓语动词发生的目的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He got up early &lt;strong&gt;&lt;em&gt;so as to&lt;/em&gt;&lt;/strong&gt; catch the first morning bus.（so as to… 做目的状语）&lt;/li&gt;
  &lt;li&gt;He got up early &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; he could catch the first morning bus.（so that… 做目的状语从句）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-2-连接词&quot;&gt;6-2-连接词&lt;/h2&gt;

&lt;p&gt;连接目的状语从句的连接词有：&lt;strong&gt;so that, in order that, for fear that, in case&lt;/strong&gt; 等。&lt;/p&gt;

&lt;p&gt;目的状语从句的谓语动中通常含有：may, could, will, might, can, should, would 等情态动词。&lt;/p&gt;

&lt;h3 id=&quot;6-2-1-so-that&quot;&gt;6-2-1 so that&lt;/h3&gt;

&lt;p&gt;so that 表示“以便，为了”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I set up the computer so that they could work from home.&lt;/li&gt;
  &lt;li&gt;I’ll give you all the facts so that you can judge for yourself.&lt;/li&gt;
  &lt;li&gt;They put a screen around his bed so that the doctor could examine him.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;so that 有时可以&lt;strong&gt;省略 so&lt;/strong&gt;，只用 that 连接。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bring it closer (so) that I may see it better.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当主句与从句的主语相同时，可以用 &lt;strong&gt;so as to do 短语替代 so that&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;One should learn from past mistakes &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; he or she can avoid falling into the same old trap again.&lt;/li&gt;
  &lt;li&gt;One should learn from past mistakes &lt;strong&gt;&lt;em&gt;so as to&lt;/em&gt;&lt;/strong&gt; avoid falling into the same old trap again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意 so that 与 so … that 的区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;so that 表示目的状语从句：
    &lt;ul&gt;
      &lt;li&gt;He went to bed very early last night &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; he could get up early this morning.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;so … that 表示结果状语从句：
    &lt;ul&gt;
      &lt;li&gt;He stayed up &lt;strong&gt;&lt;em&gt;so&lt;/em&gt;&lt;/strong&gt; late last night &lt;strong&gt;&lt;em&gt;that&lt;/em&gt;&lt;/strong&gt; he couldn’t get up early this morning.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;6-2-2-in-order-that&quot;&gt;6-2-2 in order that&lt;/h3&gt;

&lt;p&gt;in order that 表示“为了，以便”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They flew there &lt;strong&gt;&lt;em&gt;in order that&lt;/em&gt;&lt;/strong&gt; they might be in time to attend the opening ceremony.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;In order that&lt;/em&gt;&lt;/strong&gt; we might get there on time, we should set out early.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当主句与从句的主语相同时，可用 &lt;strong&gt;in order to do 短语代替 in order that 从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I came &lt;strong&gt;&lt;em&gt;in order that&lt;/em&gt;&lt;/strong&gt; I could see Jack.&lt;/li&gt;
  &lt;li&gt;I came &lt;strong&gt;&lt;em&gt;in order to&lt;/em&gt;&lt;/strong&gt; see Jack.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-2-3-for-fear-that&quot;&gt;6-2-3 for fear that&lt;/h3&gt;

&lt;p&gt;for fear that 表示“以免，唯恐”。&lt;/p&gt;

&lt;p&gt;如果从句的情态动词时 should 时，此时 should 可以省略。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;He told us to keep quiet &lt;strong&gt;&lt;em&gt;for fear that&lt;/em&gt;&lt;/strong&gt; we might disturb others.&lt;/li&gt;
  &lt;li&gt;We hurried along &lt;strong&gt;&lt;em&gt;for fear that&lt;/em&gt;&lt;/strong&gt; we (should) be late.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当主句与从句的主语相同时，可以用 &lt;strong&gt;for fear of doing 短语代替 for fear that 从句&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We spoke quietly &lt;strong&gt;&lt;em&gt;for fear that&lt;/em&gt;&lt;/strong&gt; we should wake the guards.&lt;/li&gt;
  &lt;li&gt;We spoke quietly &lt;strong&gt;&lt;em&gt;for fear of&lt;/em&gt;&lt;/strong&gt; waking the guards.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-2-4-in-case&quot;&gt;6-2-4 in case&lt;/h3&gt;

&lt;p&gt;in case 表示“以防，万一”。&lt;/p&gt;

&lt;p&gt;从句一般使用情态动词 should，且 should 可省略；从句表示虚拟语气。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They watched him closely &lt;strong&gt;&lt;em&gt;in case&lt;/em&gt;&lt;/strong&gt; he (should) escape.&lt;/li&gt;
  &lt;li&gt;I stopped suddenly &lt;strong&gt;&lt;em&gt;in case&lt;/em&gt;&lt;/strong&gt; he (should) think that I was showing off.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;in case 还可以表示“假如，如果”。此时引导的从句不再使用虚拟语气，一般也不使用情态动词&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In case she comes back, let me know immediately.&lt;/li&gt;
  &lt;li&gt;I keep a warm coat at work in case it suddenly turns cold.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;in case of 表示“假如，如果发生”。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In case of fire, ring the alarm bell.&lt;/li&gt;
  &lt;li&gt;We have an auxiliary generator in case of power cuts.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;7-结果状语从句&quot;&gt;7-结果状语从句&lt;/h1&gt;
&lt;h2 id=&quot;7-1-介绍&quot;&gt;7-1-介绍&lt;/h2&gt;

&lt;p&gt;结果状语从句：在复合句中表示&lt;strong&gt;主句动作所导致结果&lt;/strong&gt;的从句，用于补充说明主句谓语动词发生的结果；通常位于主句的后面。&lt;/p&gt;

&lt;h2 id=&quot;7-2-连接词&quot;&gt;7-2-连接词&lt;/h2&gt;

&lt;p&gt;引导结果状语从句的连词主要有：so that, so…that, such…that 等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;so 用在形容词或副词之前，such 用在名词之前&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7-2-1-so-that&quot;&gt;7-2-1 so that&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;so that 既可以引导目的状语从句，表示“为了，以便”；也可以引导结果状语从句，表示“因此，以至于”&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;当引导目的状语从句时，从句一般包含情态动词&lt;/strong&gt;；当引导结果状语从句时，一般不包含&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;You make friends with people and then make unreasonable demands &lt;strong&gt;&lt;em&gt;so tha&lt;/em&gt;&lt;/strong&gt;t they reject you.（结果状语从句）&lt;/li&gt;
    &lt;li&gt;I’ll give you all the facts &lt;strong&gt;&lt;em&gt;so that&lt;/em&gt;&lt;/strong&gt; you can judge for yourself.（目的状语从句）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7-2-2-sosuchthat&quot;&gt;7-2-2 so/such…that&lt;/h3&gt;

&lt;p&gt;so/such…that 表示“如此…以至于…”。so 是副词，修饰形容词或副词，such 是形容词，修饰名词。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;so + adj./adv. + that&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;He speaks &lt;strong&gt;&lt;em&gt;so fast tha&lt;/em&gt;&lt;/strong&gt;t no one can catch him.&lt;/li&gt;
      &lt;li&gt;The ball struck him &lt;strong&gt;&lt;em&gt;so hard tha&lt;/em&gt;&lt;/strong&gt;t he nearly fell into the water.&lt;/li&gt;
      &lt;li&gt;I was &lt;strong&gt;&lt;em&gt;so busy here that&lt;/em&gt;&lt;/strong&gt; I had no time to write a letter.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;so + adj./adv. + (a/an) + n +that&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;There is &lt;strong&gt;&lt;em&gt;so rapid an increase&lt;/em&gt;&lt;/strong&gt; in population that a food shortage is caused.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;such ＋ a(an) ＋ adj. ＋ 可数名词单数 ＋ that&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;He is &lt;strong&gt;&lt;em&gt;such a clever boy&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;that&lt;/em&gt;&lt;/strong&gt; everybody likes him.&lt;/li&gt;
      &lt;li&gt;He was &lt;strong&gt;&lt;em&gt;such an honest man that&lt;/em&gt;&lt;/strong&gt; he was praised by the teacher.&lt;/li&gt;
      &lt;li&gt;He’s such a good person that we mustn’t blame him.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;such ＋ adj. ＋ 复数可数名词 ＋ that&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;He told us &lt;strong&gt;&lt;em&gt;such horrible stories that&lt;/em&gt;&lt;/strong&gt; we all scared.&lt;/li&gt;
      &lt;li&gt;They are &lt;strong&gt;&lt;em&gt;such fine teachers that&lt;/em&gt;&lt;/strong&gt; we all hold them in great respect.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;such + adj. + 不可数名词 + that&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;He has made &lt;strong&gt;&lt;em&gt;such great progress that&lt;/em&gt;&lt;/strong&gt; the teachers are pleased with him.&lt;/li&gt;
      &lt;li&gt;It is &lt;strong&gt;&lt;em&gt;such nice weather that&lt;/em&gt;&lt;/strong&gt; I would like to go to the beach.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意：&lt;strong&gt;so 与表示数量的代词 many, few, much, little 等连用已经形成固定搭配&lt;/strong&gt;， 这种情况下不能换用 such 的对应结构表示。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Our country has &lt;strong&gt;&lt;em&gt;so much coal&lt;/em&gt;&lt;/strong&gt; that she can export large quantities.&lt;/li&gt;
  &lt;li&gt;There were &lt;strong&gt;&lt;em&gt;so many people&lt;/em&gt;&lt;/strong&gt; in the street watching the fire that firefighters could not get close to the building.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当结果状语从句的主语与主句的主语相同时，&lt;strong&gt;可省略从句主语，从句谓语变非谓语&lt;/strong&gt;。此时 so… 就要换一个形式来陈述。&lt;strong&gt;so 是中性程度副词，如果从句是肯定句，那么 so 就要换为 enough&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;enough 只能在所修饰词的后面&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;He is so old that he can go to school alone. = He is old enough to go to school alone.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;8-让步状语从句&quot;&gt;8-让步状语从句&lt;/h1&gt;
&lt;h2 id=&quot;8-1-介绍&quot;&gt;8-1-介绍&lt;/h2&gt;

&lt;p&gt;让步状语从句一般翻译为 “尽管…”，“即使…”。&lt;/p&gt;

&lt;p&gt;引导让步状语从句的连接词有：&lt;strong&gt;though, although, as, even though, whether … or …, no matter + 疑问词, 疑问词-ever, regardless of + 名词/名词短语/名词从句, despite, despite of&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要注意，although，though 不可以与 but 连用，但是可以和 yet, still 连用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;8-2-连接词&quot;&gt;8-2-连接词&lt;/h2&gt;

&lt;h3 id=&quot;8-2-1-although--though&quot;&gt;8-2-1 although &amp;amp; though&lt;/h3&gt;

&lt;p&gt;这两个连词都表示“虽然，尽管”，一般情况下可以互换使用。&lt;/p&gt;

&lt;p&gt;though 通常用于口语，although 常用于正式情况。&lt;strong&gt;&lt;em&gt;两者均不可以和 but 连用，但是可以和 yet, still, nevertheless 连用&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Although/Though he was exhausted, he(still) kept on working.&lt;/li&gt;
  &lt;li&gt;Although/Though he is known to only a few, his reputation among them is very great.&lt;/li&gt;
  &lt;li&gt;Although/Though they’re expensive, they last forever and never go out of style.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;although 引导的让步状语从句通常位于主句之前，though 引导的让步状语从句位于主句前或者主句后均可。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;They’re very different, though they did seem to get on well when they met.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-2-2-as&quot;&gt;8-2-2 as&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;as 引导的让步状语从句必须用倒装&lt;/em&gt;&lt;/strong&gt;，而 though 引导的让步状语从句可用倒装，也可不用倒装。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;名词 + as/though + 主语 + 动词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;King as he was, he was unhappy.&lt;/li&gt;
      &lt;li&gt;Child as he is, he knows to help other.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;其中的动词常为&lt;strong&gt;&lt;em&gt;连系动词&lt;/em&gt;&lt;/strong&gt;，位于句首的名词为连系动词的表语。同时，位于句首的名词通常不用冠词。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Boy as/though he is, he likes to play with girls. = Though/Although he is a boy, he likes to play with girls.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;形容词 + as/though + 主语 + 动词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Patient as he was，he didn’t like waiting that long.&lt;/li&gt;
      &lt;li&gt;Beautiful though the necklace was，we thought it was over-priced.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;其中的动词也常为&lt;strong&gt;&lt;em&gt;连系动词&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;副词 + as/though + 主语 + 动词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Much as I like Paris, I couldn’t live there.&lt;/li&gt;
      &lt;li&gt;Fast as you read, you can’t finish the book in two days.&lt;/li&gt;
      &lt;li&gt;Heavily as it is raining, the football game has been decided not to be put off.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;有时候会将 much as 当作一个复合连词看，整体引导让步状语从句。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Much as I admire him as a writer，I do not like him as a man.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;动词原型 + as/though + 主语 + 动词&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Object as you may, I’ll go.&lt;/li&gt;
      &lt;li&gt;Try as he might, he couldn’t solve the problem.&lt;/li&gt;
      &lt;li&gt;Lose money as I did, we got a lot of experience.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;&lt;em&gt;主语后面的动词常为 could, may, might, did 等情态动词或者助动词&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;如果表示陈述事实，则用 do, did 等助动词；如果表示情态含义，则用情态动词&lt;/p&gt;

    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;8-2-3-whether&quot;&gt;8-2-3 whether&lt;/h3&gt;

&lt;p&gt;由 whether 引导的让步状语从句旨在说明正反两方面的可能性都不会影响主句的意向或结果，所以&lt;strong&gt;&lt;em&gt;语气是比较强烈的&lt;/em&gt;&lt;/strong&gt;，从而也更加坚定了主句的内容。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You’ll have to attend the ceremony whether you’re free or busy.&lt;/li&gt;
  &lt;li&gt;Whether you believe it or not, it’s true.&lt;/li&gt;
  &lt;li&gt;Whether or not they win this battle, they won’t win the war.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-2-4-no-matter--疑问词--疑问词-ever&quot;&gt;8-2-4 no matter + 疑问词 = 疑问词-ever&lt;/h3&gt;

&lt;p&gt;这两个连接词均表示 “不管 … 都 …”，“…. 都 ….”，引导让步状语从句时两者可以互换。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;No matter what happened, he would not mind.&lt;/li&gt;
  &lt;li&gt;Whatever happened, he would not mind.&lt;/li&gt;
  &lt;li&gt;No matter who you are, you must keep the law.&lt;/li&gt;
  &lt;li&gt;Whoever you are, you must keep the law.&lt;/li&gt;
  &lt;li&gt;When anyone does something for you, no matter how small and no matter whether he’s a superior or servant, it’s proper to say “Thank you”.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;no matter + 疑问词只能引导状语从句，而疑问词-ever 还可以引导名词性从句&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Whatever (=No matter what) you say, I won’t believe you.(让步状语从句)&lt;/li&gt;
  &lt;li&gt;I’ll eat whatever (≠no matter what) you give me.(宾语从句)&lt;/li&gt;
  &lt;li&gt;Whoever comes will be welcome.(主语从句)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;while 有时也可以引导让步状语从句，通常位于句首&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;While I like the color, I don’t like the shape.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-2-5-even-though--even-if&quot;&gt;8-2-5 even though &amp;amp; even if&lt;/h3&gt;

&lt;p&gt;两者均可以引导让步状语从句，但是有细微差别。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;even if 引导的状语从句通常是假设性的，表示“即使”，“纵然”，“就算”，“哪怕”
    &lt;ul&gt;
      &lt;li&gt;Even if I have to walk all the way I’ll get there.&lt;/li&gt;
      &lt;li&gt;Even if it rains tomorrow, we won’t change our plan.&lt;/li&gt;
      &lt;li&gt;Even if you saw him pick up the money, you can’t be sure he stole it.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;even though 引导的从句内容往往是真实的，用于引出不利于主句的信息，表示“尽管”，“虽然”
    &lt;ul&gt;
      &lt;li&gt;He went out even though it was raining.&lt;/li&gt;
      &lt;li&gt;He’s the best teacher even though he has the least experience.&lt;/li&gt;
      &lt;li&gt;Even though I didn’t know anybody at the party, I had a nice time.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;此时 even though 与 though, although 可以互换。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Even though/Though/Although we all tried our best, we lost the game.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际运用中，even though 与 even if 可以不加区别地混用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Even if /Even though she laughs at him, he likes her.&lt;/li&gt;
  &lt;li&gt;We thoroughly understand each other, even if /even though we don’t always agree.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>kkzhang</name></author><category term="english-study" /><summary type="html">1-介绍 状语从句指句子用作状语时, 起副词作用的句子。它可以修饰谓语、非谓语动词、定语、状语或整个句子。根据其作用可分为时间、地点、原因、条件、目的、结果、让步、方式和比较等从句。 状语从句一般由连词(从属连词)引导，也可以由词组引起。从句位于句首或句中时通常用逗号与主句隔开，位于句尾时可以不用逗号隔开。</summary></entry></feed>