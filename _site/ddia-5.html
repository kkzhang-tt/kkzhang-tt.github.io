<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>DDIA: 数据复制（一）</title><!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v3.9.1" />
<meta property="og:title" content="DDIA: 数据复制（一）" />
<meta name="author" content="kkzhang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="复制主要是指通过网络在多台机器上保存相同的数据副本。通过数据复制，我们期望能够达到以下目的：" />
<meta property="og:description" content="复制主要是指通过网络在多台机器上保存相同的数据副本。通过数据复制，我们期望能够达到以下目的：" />
<link rel="canonical" href="http://localhost:4000/ddia-5.html" />
<meta property="og:url" content="http://localhost:4000/ddia-5.html" />
<meta property="og:site_name" content="Find a needle in haystack" />
<meta property="og:image" content="http://localhost:4000/ddia/ddia_5_1.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-06-29T00:00:00+08:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="http://localhost:4000/ddia/ddia_5_1.png" />
<meta property="twitter:title" content="DDIA: 数据复制（一）" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"kkzhang"},"headline":"DDIA: 数据复制（一）","dateModified":"2021-06-29T00:00:00+08:00","@type":"BlogPosting","datePublished":"2021-06-29T00:00:00+08:00","description":"复制主要是指通过网络在多台机器上保存相同的数据副本。通过数据复制，我们期望能够达到以下目的：","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/ddia-5.html"},"image":"http://localhost:4000/ddia/ddia_5_1.png","url":"http://localhost:4000/ddia-5.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Find a needle in haystack" /><link rel="shortcut icon" type="image/x-icon" href="/logo.ico" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">../</a><article>
  <p class="post-meta">
    <time datetime="2021-06-29 00:00:00 +0800">2021-06-29</time>
  </p>
  
  <h1>DDIA: 数据复制（一）</h1>

  <p>复制主要是指<strong>通过网络在多台机器上保存相同的数据副本</strong>。通过数据复制，我们期望能够达到以下目的：</p>

<ul>
  <li><strong>降低访问延迟</strong>：使数据在地理位置上更接近用户</li>
  <li><strong>提高可用性</strong>（容错）：当部分节点异常，系统仍然可以继续提供服务</li>
  <li><strong>提高读吞吐量</strong>：多个数据副本可以同时提供数据访问服务</li>
</ul>

<blockquote>
  <p>在讨论数据复制时，假设集群中的每一台机器都能保存完整的数据集副本。</p>
</blockquote>

<p>数据复制的难点在于如何处理持续更新的数据；常见的数据复制方法有三种：<strong>主从复制，多主节点复制，无主节点复制</strong>。</p>

<h1 id="主从复制">主从复制</h1>

<p>每个保存数据库完整数据集的节点称为<em>副本</em>。当存在多个副本，如何保证不同副本之间的数据一致性是需要考虑的问题。常见的解决方案基于主从复制，其基本流程如下：</p>

<ol>
  <li>指定某个副本为主副本。当客户端写数据时，必须将写请求发送给主节点；而主节点首先将数据写入本地存储</li>
  <li>其他副本称为从副本。<em>主节点将新数据写入本地之后，再将数据更改作为复制的日志或者更改流发送给所有的从副本。每个从副本获得更改日志后将其应用到本地，并且严格保持与主副本相同的写入顺序。</em></li>
  <li>客户端从数据库中读数据时，可以在主副本或者从副本上执行查询。</li>
</ol>

<blockquote>
  <p>只有主副本可以接受写请求，从副本只读</p>
</blockquote>

<p><img src="/images/ddia/ddia_5_1.png" alt="" /></p>

<h1 id="同步复制与异步复制">同步复制与异步复制</h1>

<p>在将数据由主节点复制到从节点时，可以选择使用<strong><em>同步复制</em></strong>还是<strong><em>异步复制</em></strong>。</p>

<p>结合上图的流程，假设用户需要更新自己的首页头像图片，基本流程为：用户将更新请求发送到主节点，主节点收到更新请求并更新自身数据，之后将数据更新发送给从节点。之后，主节点通知用户更新完成。</p>

<p><img src="/images/ddia/ddia_5_2.png" alt="" /></p>

<blockquote>
  <p>主从复制，包括一个同步的从节点，一个异步的从节点</p>
</blockquote>

<p>在上图中，从节点 1 同步复制：<em>主节点需要等待直到从节点 1 完成写入</em>；</p>

<p>从节点 2 异步复制：<em>主节点发送完消息之后立即返回，不用等待从节点 2 的完成确认</em>。</p>

<p>对于异步复制，可能会导致从节点落后主节点较长的时间；比如从节点 2 在收到复制日志之前，有较大的延迟。</p>

<blockquote>
  <p>对于主从复制，系统并没有保证一定会在多久时间内完成复制</p>
</blockquote>

<h2 id="同步-vs-异步">同步 VS 异步</h2>

<ol>
  <li>同步复制的优点：一旦向用户确认，从节点可以明确保证<strong>完成了与主节点的更新同步，数据已经处于最新版本</strong>。即使此时主节点发生了故障，也是可以在从节点继续访问最新的数据。</li>
  <li>同步复制的缺点：如果同步的从节点无法完成同步确认（可能是从节点崩溃，或者网络故障等），那么用户写入就不能视为成功。<strong>主节点会阻塞其后所有的写操作，直到同步副本确认完成，从而影响整体的性能</strong>。</li>
  <li>异步复制的优点：不管从节点上数据多么滞后，主节点总是可以继续响应写请求，<strong>系统的吞吐性能更好</strong>。</li>
  <li>异步复制的缺点：如果主节点发生故障且不可恢复，那么所有尚未复制到从节点的写请求都会丢失。意味着即使向客户端确认了写操作，<strong>却无法保证数据的持久化</strong>。</li>
</ol>

<p>结合上述优缺点，如果把所有的从节点设置为同步复制，那么任何一个同步节点的中断都会导致整个系停滞不前。所以在实践中，通常是其中一个从节点是同步的，而其他节点是异步模式。这样可以保证至少两个节点拥有最新的数据副本，这种配置也被称为<strong>半同步</strong>。</p>

<h2 id="配置新的从节点">配置新的从节点</h2>

<p>如果需要增加新的副本以提高容错能力或者替换新的副本，那么就需要配置新的从节点，此时需要确保新的从节点与主节点保持数据一致。</p>

<blockquote>
  <p>在配置新的节点时，客户端仍然会不断地往主节点中更新数据，因此常规的文件拷贝方式会导致不同的节点上呈现出不同时间点的数据，不能保证数据一致；另外，锁定数据库（使其不可写）的方式会使得整个服务无法处理写请求，违反高可用的设计目标。</p>
</blockquote>

<p>不停机，数据服务不中断地配置新的从节点的步骤：</p>

<ol>
  <li>
    <p>在某个时间点对主节点的数据副本产生一个<strong>一致性快照</strong>（避免长时间锁定）</p>

    <blockquote>
      <p>创建快照时，快照与系统复制日志的<strong><em>某个确定位置</em></strong>相关联，在 MySQL 中称为 binlog coordinates，PostgteSQL 中称为 log sequence number</p>
    </blockquote>
  </li>
  <li>
    <p>将快照复制到新的从节点</p>
  </li>
  <li>
    <p>从节点连接到主节点并获取快照点之后发生的数据更改日志</p>
  </li>
  <li>
    <p>根据获得的日志，从节点将这些快照之后的所有数据变更应用到本地，这个过程称为追赶。之后可以继续复制变更日志，从而保证数据一致</p>
  </li>
</ol>

<h2 id="处理节点失效">处理节点失效</h2>

<p>我们期望通过主从复制来实现系统的高可用，即使部分节点失效，仍然能够保证系统总体的持续运行。</p>

<h3 id="从节点失效追赶式复制">从节点失效：追赶式复制</h3>

<p><em>从节点的磁盘上保存了接收到的数据变更日志</em>；如果从节点崩溃后重启，可以在将本地日志应用后，连接到主节点，<strong>请求中断期间所有的数据变更日志</strong>，并应用到本地来追赶主节点。之后就和正常情况一样持续接收来自主节点的数据流变化。</p>

<h3 id="主节点失效节点切换">主节点失效：节点切换</h3>

<p>主节点失效的话，需要涉及到主从身份的状态转换；切换过程如下：</p>

<ol>
  <li><strong>确认主节点失效</strong>：节点失效可能有多种原因：系统崩溃，停电，网络问题等；大部分系统都采用基于<strong>超时机制</strong>来确认节点的有效性：节点之间互相频繁发送心跳存活消息，如果发现某个节点在一段比较长时间内（如 30s）没有响应，那么就可以认为节点失效。</li>
  <li><strong>选举出新的主节点</strong>：新的主节点可以通过<strong>选举</strong>的方式来确认（多数节点达成共识）；也可以由之前选定的某<strong>控制节点来选定新的主节点</strong>。候选节点最好与原主节点之间的数据差异最小，可以减小数据丢失的风险。</li>
  <li><strong>重新配置系统使新主节点生效</strong>：新主节点确认之后，客户端需要将写请求路由到新的主节点，同时其他从节点要接受来自新主节点上的数据变更；而且我们要确保原主节点重新上线之后被降级为从节点，并认可新的主节点，不然可能会存在脑裂问题。</li>
</ol>

<p>在主从切换的过程中仍然存在许多问题：</p>

<ol>
  <li>如果系统使用异步复制，失效前原主节点并没有将最新数据复制到从节点；那么原主节点失效后重新上线，但是并没有意识到角色变化，仍然会尝试同步其他从节点，那么新的主节点就会收到冲突的写请求。常见的解决方案是，<strong>原主节点上未完成复制的写请求直接丢弃</strong>（可能会违背数据更新持久化）</li>
  <li>可能会有两个节点都认为自己是主节点（脑裂），这两个主节点都可能接受写请求，从而导致数据丢失或破坏。这种情况下，可以<strong>强制关闭其中一个节点</strong>。</li>
  <li>健康检测超时时间的设置：如果设置超时时间过长，那么主节点失效之后总体的恢复时间就较长；如果超时时间过短，那么就会导致不必要的主从切换，可能会对系统性能及可用性造成严重影响（响应时间增长，延迟增加等）</li>
</ol>

<h3 id="复制日志的实现">复制日志的实现</h3>

<ul>
  <li>基于语句复制：主节点记录每个写请求的操作语句，并将该语句作为日志发送给从节点</li>
  <li>基于预写日志(WAL)传输：所有对数据库的更新都会被记录到预写日志中，因此可以使用该日志在另一个节点上构建副本</li>
  <li>基于行的逻辑日志复制：逻辑日志是指一些列记录来描述数据表行级别的写请求，如 MySQL 中的 binlog</li>
  <li>基于触发器复制：通过触发器注册自己的应用层代码，使得当系统数据发生更改时，自动执行自定义代码</li>
</ul>

<h2 id="复制滞后">复制滞后</h2>

<p>支持容错（提高可用性）是使用复制的其中一个原因，可扩展性（使用多节点来处理更多的请求）和低延迟（将副本部署在地理上距离用户更近的地方）也是我们的目标。</p>

<p>主从复制中只有主节点支持写，从节点只读。我们可以通过添加较多的从节点来提高读请求的吞吐量；不过其复制方式只能选择异步复制。</p>

<blockquote>
  <p>如果使用同步复制所有从节点，那么单个节点故障或者网络中断都会使得整个系统无法写入；而节点越多，发生故障的概率越大。</p>
</blockquote>

<p>不过使用异步复制会使得主从节点之间产生数据不一致问题，这种不一致只是一个短暂的状态，如果停止写数据库，那么经过一段时间之后，从节点最终会与主节点的数据保持一致，被称为<strong>最终一致性</strong>。</p>

<blockquote>
  <p>最终一致性不能保证主从之间延迟的时间，理论上没有上限。</p>
</blockquote>

<h3 id="读自己的写">读自己的写</h3>

<p>对于读负载高，写负载低的系统，通常的实现方式是：提交数据发送到主节点，但是当用户读取数据时，数据可能来自从节点。</p>

<p>不过，对于异步复制来说，从节点数据存在滞后问题；如果用户在更新数据之后立马查看数据，那么<em>读请求可能会发送到滞后的从节点上</em>，从而无法查看到最新的数据。</p>

<p><img src="/images/ddia/ddia_5_3.png" alt="" /></p>

<blockquote>
  <p>用户发起写请求，然后在滞后的副本上读取数据，此时需要 read-after-write 一致性</p>
</blockquote>

<p>为了避免上述情况发生，需要实现“<strong>写后读一致性</strong>”，即“<strong>读写一致性</strong>”：<strong>用户读取自己更新的数据时，总能看到最近的更新；但是对其他用户没有任何保证，其他用户可能过段时间才能看到该更新</strong>。</p>

<p>实现读写一致性有多种方案：</p>

<ol>
  <li>用户总是在主节点读取与自己相关的数据，而在从节点读取其他用户的数据</li>
  <li>数据更新一段时间范围内（如一分钟）均从主节点读，超过该阈值则从从节点读；该方案需要监控主从延迟</li>
  <li>客户端请求时携带数据最近的更新时间戳，服务端收到请求之后先判断当前节点是否包含最新的数据（比较时间戳），如果包含则直接处理，否则将请求转发给另一个节点处理</li>
</ol>

<h3 id="单调读">单调读</h3>

<p>对于异步复制还可能出现另一种问题：用户从多个副本进行了多次读取，可能会出现前一次读取返回了较新的数据，后一次读取返回了旧数据；看起来感觉用户数据回滚了。</p>

<p><img src="/images/ddia/ddia_5_4.png" alt="" /></p>

<blockquote>
  <p>用户读取到最新内容之后有读到了过期的内容，此时需要单调读一致性</p>
</blockquote>

<p>为了避免数据回滚的现象，我们可以采用“<strong>单调读一致性</strong>”：这是一个比强一致性弱，但是比最终一致性强的保证。</p>

<p>为了实现单调读，我们需要<em>确保每个用户总是从固定的一个数据副本进行读取</em>（不同用户可以访问不同副本）。比如，根据用户 ID hash 来确定副本。</p>

<h3 id="前缀一致读">前缀一致读</h3>

<p><img src="/images/ddia/ddia_5_5.png" alt="" /></p>

<blockquote>
  <p>由于多个从节点的滞后程度不同，导致观察者先看到结果后看到原因</p>
</blockquote>

<p>为了防止这种问题，需要保证“<strong>前缀一致性读</strong>”：对于某个顺序的写请求，那么读取时也需要按照相同的顺序。</p>

<p>为了实现前缀一致性读，可以将具有因果关系的写入都交给同一个数据分区来完成。</p>

<h2 id="复制滞后的解决方案">复制滞后的解决方案</h2>

<p>对于最终一致性系统，我们需要考虑如果主从延迟增加到几分钟或者几小时，该系统表现是否符合预期。<strong>如果不符合预期，那么需要更强的一致性保证</strong>，比如写后读，单调读等。</p>

<p>如果需要强一致性，那么就需要引入共识机制。</p>

</article>
      </div>
    </main>
  </body>
</html>